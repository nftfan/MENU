<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MEME.FUN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    :root {
      --primary: #fff;
      --accent: #ffc107;
      --accent2: #3cbfff;
      --bg: #181824;
      --surface1: #24243a;
      --surface2: #191933;
      --divider: #303047;
      --border1: #ffc107;
      --border2: #3cbfff;
      --price-bg: #232336;
      --price-bg2: #12243a;
      --price-color: #ffe082;
      --price-color2: #81f7ff;
      --green: #3ad37a;
      --green-dark: #1b8c4a;
      --red: #ff5469;
      --red-dark: #b81e2f;
      --shadow1: 0 4px 18px #0002;
      --shadow2: 0 0px 14px #00eaff14 inset;
      --radius: 20px;
      --meme-circle-size: 168px;
      --btn-w: 112px;
      --btn-h: 34px;
    }
    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', Arial, sans-serif;
      background: var(--bg);
      color: var(--primary);
      font-size: 12px;
      box-sizing: border-box;
      height: 100%;
      width: 100vw;
      overflow: hidden !important;
      overscroll-behavior: none;
    }
    body {
      min-height: 100vh;
      max-width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      background: var(--bg);
    }
    .header {
      width: 100vw;
      background: var(--surface1);
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: space-between;
      height: 44px;
      letter-spacing: 1.1px;
      font-weight: bold;
      font-size: 13px;
      box-shadow: 0 2px 7px -2px #000b;
      border-bottom: 1.5px solid var(--divider);
      flex-shrink: 0;
      position: relative;
      z-index: 10;
      padding: 0 15px;
    }
    .header-logo {
      display: flex;
      align-items: center;
      gap: 4px;
    }
    #connect-btn {
      background: var(--accent);
      color: #232336;
      border: none;
      border-radius: 12px;
      padding: 5px 10px;
      font-size: 11px;
      font-weight: bold;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .tab-nav {
      display: flex;
      background: var(--surface2);
      width: 100%;
      border-bottom: 1px solid var(--divider);
      overflow-x: auto;
      white-space: nowrap;
      -webkit-overflow-scrolling: touch;
    }
    .tab-btn {
      padding: 10px 15px;
      cursor: pointer;
      color: var(--primary);
      font-weight: 600;
      font-size: 12px;
      text-align: center;
      flex: 1;
      opacity: 0.7;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }
    .tab-btn.active {
      opacity: 1;
      border-color: var(--accent);
      color: var(--accent);
    }
    .main-area {
      flex: 1;
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      background: var(--bg);
      padding: 0;
    }
    .tab-content {
      width: 100%;
      height: calc(100vh - 80px);
      overflow-y: auto;
      position: relative;
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    .section {
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      position: relative;
      z-index: 1;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
      min-height: 0;
      border-radius: 0;
      gap: 0.5rem;
    }
    .section-top {
      background: var(--surface1);
      border-bottom: 2.5px solid var(--border1);
      box-shadow: var(--shadow1);
      padding: 18px 0 0 0;
      margin: 0;
      align-items: center;
      min-height: 0;
    }
    .section-bottom {
      background: var(--surface2);
      border-top: 2.5px solid var(--border2);
      box-shadow: var(--shadow2);
      margin: 0;
      padding: 16px 0 0 0;
      border-radius: 0 0 0 0;
      align-items: center;
    }
    .section-title {
      font-size: 12px;
      font-weight: 700;
      margin: 0 0 6px 0;
      color: #ffd26e;
      letter-spacing: .9px;
      text-align: center;
      width: 100%;
      padding-top: 0;
      text-shadow: 0 2px 9px #2224;
      user-select: none;
    }
    .section-bottom .section-title {
      color: #65e6ff;
      margin-bottom: 6px;
      text-shadow: 0 2px 9px #0ff2;
    }
    .swipe-area {
      width: 100vw;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      gap: 0;
      padding: 0;
    }
    .swipe-btn {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 32px;
      cursor: pointer;
      margin: 0 10px;
      padding: 0;
      width: 38px;
      height: var(--meme-circle-size);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      border-radius: 50%;
      transition: background 0.14s;
      outline: none;
      user-select: none;
    }
    .swipe-btn:active {
      background: #23233655;
    }
    .meme-circle-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      min-width: var(--meme-circle-size);
    }
    .meme-circle {
      width: var(--meme-circle-size);
      height: var(--meme-circle-size);
      border-radius: 50%;
      overflow: hidden;
      background: linear-gradient(135deg, #25254a 60%, #3a354f 100%);
      box-shadow: 0 2px 18px 0 #0007, 0 2px 7px 0 #ffd96b10;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3.5px solid var(--border1);
      position: relative;
      flex-shrink: 0;
      transition: box-shadow 0.13s, border 0.14s;
    }
    .section-bottom .meme-circle {
      background: linear-gradient(135deg, #232b40 60%, #1b304a 100%);
      border: 3.5px solid var(--border2);
    }
    .meme-circle img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      filter: brightness(0.97) contrast(1.1);
    }
    .meme-circle.shake {
      animation: shake 0.4s;
    }
    @keyframes shake {
      0% { transform: translateX(0px) rotate(0deg);}
      18% { transform: translateX(-4px) rotate(-6deg);}
      35% { transform: translateX(4px) rotate(6deg);}
      50% { transform: translateX(-2px) rotate(-3deg);}
      62% { transform: translateX(2px) rotate(3deg);}
      75% { transform: translateX(-1px) rotate(-1deg);}
      100% { transform: translateX(0px) rotate(0deg);}
    }
    .meme-price {
      margin-top: 14px;
      font-size: 15px;
      color: var(--price-color);
      font-weight: 700;
      letter-spacing: 0.3px;
      background: var(--price-bg);
      border-radius: 13px;
      box-shadow: 0 1px 5px #0004;
      border: 1.5px solid var(--border1);
      padding: 6px 20px 4px 20px;
      min-width: 80px;
      text-align: center;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: -38px;
      pointer-events: none;
      user-select: none;
      text-shadow: 0 1px 10px #23233666;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .section-bottom .meme-price {
      border: 1.5px solid var(--border2);
      background: var(--price-bg2);
      color: var(--price-color2);
      text-shadow: 0 1px 8px #0ff2;
    }
    .buy-btn, .sell-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      border: none;
      border-radius: 17px;
      width: var(--btn-w);
      height: var(--btn-h);
      cursor: pointer;
      letter-spacing: .9px;
      outline: none;
      user-select: none;
      font-size: 15px;
      box-shadow: 0 2px 10px #0002;
      transition: background .15s, color .14s, box-shadow .15s, filter .13s;
      margin: 0 auto;
    }
    .buy-btn {
      background: var(--green);
      color: #fff;
      box-shadow: 0 2px 10px #25b95a33;
      border: 2px solid var(--green-dark);
      margin-top: 32px;
      margin-bottom: 10px;
    }
    .buy-btn:hover, .buy-btn:focus {
      background: #26d36b;
      color: #fff;
      filter: brightness(1.08);
      box-shadow: 0 2px 16px #3ad37a44;
    }
    .buy-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .sell-btn {
      background: var(--red);
      color: #fff;
      box-shadow: 0 2px 10px #ff546933;
      border: 2px solid var(--red-dark);
      margin-top: 18px;
      margin-bottom: 10px;
    }
    .sell-btn:hover, .sell-btn:focus,
    .section-bottom .sell-btn:hover {
      background: #ff3747;
      color: #fff;
      filter: brightness(1.05);
      box-shadow: 0 2px 16px #ff546944;
    }
    .sell-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .section-bottom .sell-btn {
      background: var(--red);
      color: #fff;
      box-shadow: 0 2px 10px #ff546933;
      border: 2px solid var(--red-dark);
      margin-top: 14px;
      margin-bottom: 10px;
    }
    .sell-price-row {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 18px 0 0 0;
      gap: 6px;
    }
    .sell-price-label {
      font-size: 12px;
      color: #65e6ff;
      margin-right: 2px;
      font-weight: 700;
      letter-spacing: 0.45px;
    }
    .sell-price-input {
      width: 54px;
      padding: 4px 10px;
      border: 1.5px solid #3cbfff;
      border-radius: 13px;
      font-size: 12px;
      outline: none;
      background: #181824;
      color: #81f7ff;
      text-align: right;
      transition: border 0.14s;
      box-shadow: 0 1px 6px #00eaff10 inset;
      font-weight: 600;
    }
    .sell-price-input:focus {
      border: 1.5px solid #81f7ff;
      background: #101020;
    }
    .sell-price-coin {
      color: #65e6ff;
      font-size: 18px;
      margin-left: 2px;
      vertical-align: middle;
      filter: drop-shadow(0 0 4px #3cbfff36);
    }
    
    /* Status bar */
    .status-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--surface1);
      color: var(--primary);
      padding: 8px 15px;
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      z-index: 100;
      border-top: 1px solid var(--divider);
    }
    .status-info { color: #64b5f6; }
    .status-success { color: var(--green); }
    .status-error { color: var(--red); }
    .status-warn { color: #ffb74d; }
    
    /* NFT lists */
    .nft-list {
      list-style: none;
      margin: 0;
      padding: 0 10px;
      width: 100%;
      box-sizing: border-box;
    }
    .loading-indicator, .error-message {
      text-align: center;
      padding: 20px;
      color: var(--primary);
    }
    .error-message {
      color: var(--red);
    }
    .nft-post {
      display: flex;
      padding: 10px;
      border-bottom: 1px solid var(--divider);
      align-items: center;
      justify-content: space-between;
    }
    .nft-post-left {
      display: flex;
      align-items: center;
      gap: 10px;
      max-width: 70%;
    }
    .serial-number {
      width: 20px;
      text-align: center;
      color: #a8a8b3;
      font-size: 12px;
    }
    .nft-avatar {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      object-fit: cover;
    }
    .nft-content {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    .nft-title {
      font-weight: 600;
      font-size: 13px;
      color: var(--primary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex;
      align-items: center;
      gap: 5px;
    }
    .nft-supply {
      font-size: 11px;
      color: #a8a8b3;
    }
    .nft-description {
      font-size: 11px;
      color: #a8a8b3;
      overflow: hidden;
      text-overflow: ellipsis;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
    }
    .nft-status-label {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 10px;
      margin-top: 3px;
      display: inline-block;
    }
    .nft-status-listed {
      background: var(--green-dark);
      color: #e0ffe0;
    }
    .nft-status-notlisted {
      background: var(--red-dark);
      color: #ffe0e0;
    }
    .nft-actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 5px;
    }
    .price-tab {
      background: var(--surface1);
      color: var(--accent);
      padding: 5px 10px;
      border-radius: 8px;
      font-weight: 600;
      font-size: 12px;
      text-align: center;
    }
    .nft-actions .buy-btn, .nft-actions .sell-btn {
      width: auto;
      height: auto;
      padding: 5px 10px;
      font-size: 11px;
      margin: 0;
    }
    .nft-actions .buy-btn .material-icons, 
    .nft-actions .sell-btn .material-icons,
    .nft-actions .delist-btn .material-icons {
      font-size: 14px;
      margin-right: 3px;
    }
    .delist-btn {
      background: #555;
      color: #fff;
      border: 1px solid #444;
      border-radius: 10px;
      padding: 3px 8px;
      font-size: 10px;
      display: flex;
      align-items: center;
      cursor: pointer;
    }
    .sold-out {
      display: flex;
      align-items: center;
      color: var(--red);
      font-size: 11px;
      font-weight: 600;
      gap: 4px;
    }
    .sold-out .material-icons {
      font-size: 14px;
    }
    
    /* Sell modal */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .modal-content {
      background: var(--surface1);
      border-radius: 15px;
      width: 90%;
      max-width: 300px;
      padding: 20px;
      box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h3 {
      margin: 0;
      color: var(--accent);
      font-size: 16px;
    }
    .modal-close {
      background: none;
      border: none;
      color: var(--primary);
      font-size: 20px;
      cursor: pointer;
    }
    .modal-body {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    .form-group label {
      font-size: 12px;
      color: var(--primary);
    }
    .form-group input {
      background: var(--bg);
      border: 1px solid var(--divider);
      border-radius: 8px;
      padding: 8px;
      color: var(--primary);
    }
    .modal-error {
      color: var(--red);
      font-size: 12px;
      margin-top: 5px;
      text-align: center;
    }
    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 10px;
    }
    .modal-footer button {
      padding: 8px 15px;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      border: none;
      font-size: 13px;
    }
    .modal-cancel {
      background: transparent;
      color: var(--primary);
      border: 1px solid var(--divider);
    }
    .modal-confirm {
      background: var(--red);
      color: white;
    }
    .count-badge {
      position: absolute;
      top: 10px;
      right: 15px;
      background: var(--surface1);
      color: var(--accent);
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 10px;
      font-weight: bold;
      border: 1px solid var(--accent);
    }
    
    @media (max-width: 600px) {
      :root {
        --meme-circle-size: 120px;
        --btn-w: 90px;
        --btn-h: 28px;
      }
      .meme-price { font-size: 11px; padding: 3px 10px 3px 10px; bottom: -23px;}
      .swipe-btn { width: 28px; font-size: 22px; }
      .buy-btn, .sell-btn { font-size: 11px;}
      .section-title { font-size: 10px;}
      .sell-price-input { width: 33px; font-size: 9px;}
      .sell-price-row { margin-top: 14px;}
      .buy-btn { margin-top: 24px; }
      .sell-btn { margin-top: 12px; }
      .section-bottom .sell-btn { margin-top: 10px; }
    }
    @media (max-width: 400px) {
      :root {
        --meme-circle-size: 90px;
        --btn-w: 62px;
        --btn-h: 18px;
      }
      .meme-price { font-size: 8px; padding: 2px 5px 2px 5px; bottom: -15px;}
      .buy-btn, .sell-btn { font-size: 8px;}
      .sell-price-input { width: 22px; font-size: 8px;}
      .swipe-btn { width: 18px; font-size: 15px; }
      .section-title { font-size: 8px;}
      .sell-price-row { margin-top: 8px;}
      .buy-btn { margin-top: 13px; }
      .sell-btn { margin-top: 7px; }
      .section-bottom .sell-btn { margin-top: 7px; }
    }
  </style>
</head>
<body>
  <div class="header">
    <div class="header-logo">
      <span class="material-icons" aria-label="emoji">emoji_emotions</span>
      MEME.FUN
    </div>
    <button id="connect-btn" onclick="connectWallet()">
      🔗 Connect Wallet
    </button>
  </div>
  
  <div class="tab-nav">
    <div id="tab-shop" class="tab-btn active">Memes</div>
    <div id="tab-mynfts" class="tab-btn">My Memes</div>
    <div id="tab-listings" class="tab-btn">Listings</div>
  </div>
  
  <div class="main-area">
    <!-- Shop Tab -->
    <div id="tab-content-shop" class="tab-content" style="display: block;">
      <span id="shop-count" class="count-badge">T: 0</span>
      <div id="shop-loading" class="loading-indicator">Loading NFTs...</div>
      <div id="shop-error" class="error-message" style="display: none;"></div>
      <ul id="shopGrid" class="nft-list"></ul>
    </div>
    
    <!-- My NFTs Tab -->
    <div id="tab-content-mynfts" class="tab-content">
      <span id="mynfts-count" class="count-badge">T: 0</span>
      <div id="my-loading" class="loading-indicator">Connect wallet to view your NFTs</div>
      <div id="my-error" class="error-message" style="display: none;"></div>
      <ul id="myGrid" class="nft-list"></ul>
    </div>
    
    <!-- Listings Tab -->
    <div id="tab-content-listings" class="tab-content">
      <span id="listings-count" class="count-badge">T: 0</span>
      <div id="listings-loading" class="loading-indicator">Loading user listings...</div>
      <div id="listings-error" class="error-message" style="display: none;"></div>
      <ul id="listingsGrid" class="nft-list"></ul>
    </div>
  </div>
  
  <!-- Status Bar -->
  <div id="statusBar" class="status-bar status-info">
    <span id="statusBarIcon" class="material-icons">info</span>
    Ready
  </div>
  
  <!-- Sell Modal -->
  <div id="sellModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3>Sell NFT #<span id="sellTokenId"></span></h3>
        <button class="modal-close" onclick="closeSellModal()">&times;</button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label>Available: <span id="sellMaxAmount">0</span></label>
          <input type="number" id="sellAmountInput" placeholder="Amount to sell" min="1">
        </div>
        <div class="form-group">
          <label>Price (POL per NFT)</label>
          <input type="number" id="sellPriceInput" placeholder="Price in POL" step="0.001" min="0">
        </div>
        <div id="sellModalError" class="modal-error"></div>
      </div>
      <div class="modal-footer">
        <button class="modal-cancel" onclick="closeSellModal()">Cancel</button>
        <button class="modal-confirm" onclick="confirmSellNFT()">Confirm</button>
      </div>
    </div>
  </div>

  <!-- Web3 Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
  <script>
    // --- CONFIG ---
    const POLYGON_PARAMS = {
      chainId: "0x89",
      chainName: "Polygon Mainnet",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: [
        "https://polygon-rpc.com/",
        "https://rpc.polygon.technology/",
        "https://rpc-mainnet.matic.network/",
      ],
      blockExplorerUrls: ["https://polygonscan.com/"],
    };
    const NFTFAN_SHOP_CA = "0x668F3F71D33E77ac12447C77231a4B373ce2A6fE";
    const NFTFAN_SHOP_ABI = [
      {
        inputs: [],
        stateMutability: "nonpayable",
        type: "constructor",
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
          {
            indexed: false,
            internalType: "address",
            name: "creator",
            type: "address",
          },
          {
            indexed: false,
            internalType: "string",
            name: "tokenURI",
            type: "string",
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "price",
            type: "uint256",
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256",
          },
        ],
        name: "NFTMinted",
        type: "event",
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
          {
            indexed: false,
            internalType: "address",
            name: "buyer",
            type: "address",
          },
          {
            indexed: false,
            internalType: "address",
            name: "seller",
            type: "address",
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "price",
            type: "uint256",
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256",
          },
        ],
        name: "NFTBought",
        type: "event",
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
          {
            indexed: false,
            internalType: "address",
            name: "seller",
            type: "address",
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "price",
            type: "uint256",
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256",
          },
        ],
        name: "NFTListed",
        type: "event",
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
        ],
        name: "NFTUnlisted",
        type: "event",
      },
      {
        anonymous: false,
        inputs: [
          {
            indexed: true,
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
          {
            indexed: false,
            internalType: "address",
            name: "seller",
            type: "address",
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "listingIndex",
            type: "uint256",
          },
          {
            indexed: false,
            internalType: "uint256",
            name: "amount",
            type: "uint256",
          },
        ],
        name: "ListingCancelled",
        type: "event",
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "account",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "id",
            type: "uint256",
          },
        ],
        name: "balanceOf",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256",
          },
        ],
        name: "buyNFT",
        outputs: [],
        stateMutability: "payable",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "listingIndex",
            type: "uint256",
          },
        ],
        name: "cancelListing",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
        ],
        name: "exists",
        outputs: [
          {
            internalType: "bool",
            name: "",
            type: "bool",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
        ],
        name: "getListings",
        outputs: [
          {
            components: [
              {
                internalType: "address",
                name: "seller",
                type: "address",
              },
              {
                internalType: "uint256",
                name: "amount",
                type: "uint256",
              },
              {
                internalType: "uint256",
                name: "price",
                type: "uint256",
              },
            ],
            internalType: "struct NFTFansShop.Listing[]",
            name: "",
            type: "tuple[]",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
        ],
        name: "getShopInventory",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
      {
        inputs: [],
        name: "getShopNFTs",
        outputs: [
          {
            internalType: "uint256[]",
            name: "ids",
            type: "uint256[]",
          },
          {
            internalType: "string[]",
            name: "uris",
            type: "string[]",
          },
          {
            internalType: "uint256[]",
            name: "prices",
            type: "uint256[]",
          },
          {
            internalType: "bool[]",
            name: "isForSale",
            type: "bool[]",
          },
          {
            internalType: "uint256[]",
            name: "shopAmounts",
            type: "uint256[]",
          },
          {
            internalType: "uint256[]",
            name: "maxSupplies",
            type: "uint256[]",
          },
          {
            internalType: "uint256[]",
            name: "currentSupplies",
            type: "uint256[]",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "string",
            name: "_tokenURI",
            type: "string",
          },
          {
            internalType: "uint256",
            name: "_price",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "_maxSupply",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256",
          },
        ],
        name: "mintNFT",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "_amount",
            type: "uint256",
          },
        ],
        name: "mintAdditional",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
      },
      {
        inputs: [],
        name: "nextTokenId",
        outputs: [
          {
            internalType: "uint256",
            name: "",
            type: "uint256",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
        ],
        name: "nftInfo",
        outputs: [
          {
            internalType: "string",
            name: "tokenURI",
            type: "string",
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256",
          },
          {
            internalType: "bool",
            name: "forSale",
            type: "bool",
          },
          {
            internalType: "address",
            name: "originalCreator",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "maxSupply",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "currentSupply",
            type: "uint256",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "_price",
            type: "uint256",
          },
        ],
        name: "sellNFT",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "address",
            name: "user",
            type: "address",
          },
        ],
        name: "tokensOfOwner",
        outputs: [
          {
            internalType: "uint256[]",
            name: "tokenIds",
            type: "uint256[]",
          },
          {
            internalType: "uint256[]",
            name: "amounts",
            type: "uint256[]",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
        ],
        name: "unlistNFT",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function",
      },
      {
        inputs: [
          {
            internalType: "uint256",
            name: "tokenId",
            type: "uint256",
          },
        ],
        name: "uri",
        outputs: [
          {
            internalType: "string",
            name: "",
            type: "string",
          },
        ],
        stateMutability: "view",
        type: "function",
      },
    ];

    let userAccount = null,
      web3,
      nftfanShop = null,
      lastError = null,
      statusTimeout = null;
    let sellModalTokenId = null,
      sellModalMaxAmount = null;

    function setStatusBar(type, message) {
      const statusBar = document.getElementById("statusBar");
      const iconSpan = document.getElementById("statusBarIcon");
      statusBar.className = `status-bar status-${type}`;
      if (iconSpan) {
        if (type === "success") iconSpan.textContent = "check_circle";
        else if (type === "error") iconSpan.textContent = "error";
        else if (type === "warn") iconSpan.textContent = "warning";
        else iconSpan.textContent = "info";
      }
      statusBar.style.display = "flex";
      statusBar.textContent = "";
      statusBar.appendChild(iconSpan);
      statusBar.appendChild(document.createTextNode(message));
    }

    function updateStatus(message, type = "info") {
      setStatusBar(type, message);
      // Status bar stays on screen; no timeout to hide it.
    }

    function logError(error, context = "") {
      lastError = `${context}: ${error.message || error}`;
    }

    function showError(elementId, message) {
      const errorEl = document.getElementById(elementId);
      errorEl.textContent = message;
      errorEl.style.display = "block";
      updateStatus(message, "error");
    }

    function hideError(elementId) {
      document.getElementById(elementId).style.display = "none";
    }

    async function connectWallet() {
      try {
        updateStatus("Connecting wallet...", "info");
        if (!window.ethereum) throw new Error("Please install MetaMask or a compatible wallet!");
        const chainId = await window.ethereum.request({ method: "eth_chainId" });
        if (chainId !== POLYGON_PARAMS.chainId) {
          updateStatus("Switching to Polygon network...", "info");
          try {
            await window.ethereum.request({
              method: "wallet_switchEthereumChain",
              params: [{ chainId: POLYGON_PARAMS.chainId }],
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              await window.ethereum.request({
                method: "wallet_addEthereumChain",
                params: [POLYGON_PARAMS],
              });
            } else {
              throw switchError;
            }
          }
        }
        const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
        userAccount = accounts[0];
        document.getElementById("connect-btn").textContent = formatAddress(userAccount);
        await setupContracts();
        updateStatus("Connected successfully", "success");
        loadShopNFTs();
        loadUserNFTs();
        loadUserListings();
      } catch (error) {
        console.error("connectWallet failed:", error);
        logError(error, "Wallet Connection");
        updateStatus("Connection failed: " + error.message, "error");
      }
    }

    async function setupContracts() {
      try {
        updateStatus("Setting up contracts...", "info");
        const rpcUrls = POLYGON_PARAMS.rpcUrls;
        let provider = null;
        if (window.ethereum) {
          provider = window.ethereum;
          console.log("Using MetaMask provider");
        } else {
          for (const rpcUrl of rpcUrls) {
            try {
              const testWeb3 = new Web3(rpcUrl);
              const blockNumber = await testWeb3.eth.getBlockNumber();
              console.log(`Connected to RPC ${rpcUrl}, block number: ${blockNumber}`);
              provider = rpcUrl;
              break;
            } catch (e) {
              console.error(`Failed to connect to RPC ${rpcUrl}:`, e);
            }
          }
        }
        if (!provider) throw new Error("No working RPC provider found");
        web3 = new Web3(provider);
        nftfanShop = new web3.eth.Contract(NFTFAN_SHOP_ABI, NFTFAN_SHOP_CA);
        console.log("Contract initialized at address:", NFTFAN_SHOP_CA);
        updateStatus("Contracts initialized", "success");
      } catch (error) {
        console.error("Contract setup failed:", error);
        logError(error, "Contract Setup");
        updateStatus("Contract setup failed: " + error.message, "error");
        throw error;
      }
    }

    async function fetchOpenSeaMeta(uri) {
      if (!uri) return null;
      try {
        if (uri.startsWith("ipfs://")) uri = "https://ipfs.io/ipfs/" + uri.slice(7);
        if (uri.startsWith("ar://")) uri = "https://arweave.net/" + uri.slice(5);
        const res = await fetch(uri, { mode: "cors" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      } catch (e) {
        console.error("fetchOpenSeaMeta failed for URI", uri, ":", e);
        updateStatus("Metadata fetch failed: " + (uri || "unknown"), "warn");
        return null;
      }
    }

    let permanentlySoldOutIds = JSON.parse(localStorage.getItem("nftfans_permanently_sold_out_ids") || "[]");

    function markPermanentlySoldOut(tokenId) {
      if (!permanentlySoldOutIds.includes(tokenId)) {
        permanentlySoldOutIds.push(tokenId);
        localStorage.setItem("nftfans_permanently_sold_out_ids", JSON.stringify(permanentlySoldOutIds));
      }
    }

    async function loadShopNFTs() {
      const shopGrid = document.getElementById("shopGrid");
      const loading = document.getElementById("shop-loading");
      const countEl = document.getElementById("shop-count");
      shopGrid.innerHTML = "";
      loading.style.display = "block";
      shopGrid.style.display = "none";
      countEl.style.display = "none";
      hideError("shop-error");
      try {
        updateStatus("Loading shop NFTs...", "info");
        if (!nftfanShop) await setupContracts();
        const result = await nftfanShop.methods.getShopNFTs().call();
        console.log("getShopNFTs result:", result);
        const { ids, uris, prices, isForSale, shopAmounts, maxSupplies } = result;
        if (!ids.length) {
          loading.textContent = "No NFTs in Shop";
          countEl.textContent = "T: 0";
          countEl.style.display = "block";
          updateStatus("No NFTs in shop", "info");
          return;
        }
        updateStatus(`Loading metadata for ${ids.length} NFTs...`, "info");
        const metaArr = await Promise.all(
          uris.map(async (uri, i) => {
            try {
              const meta = await fetchOpenSeaMeta(uri);
              console.log(`Metadata for URI ${uri}:`, meta);
              return meta;
            } catch (e) {
              console.error(`Failed to fetch metadata for URI ${uri}:`, e);
              return null;
            }
          })
        );
        let html = "";
        let visibleCount = 0;
        for (let i = 0; i < ids.length; i++) {
          const id = ids[i],
            meta = metaArr[i],
            name = meta?.name || `NFTFAN #${id}`,
            img = meta?.image || uris[i] || "https://via.placeholder.com/92x92?text=NFT",
            desc = meta?.description || "",
            price = web3.utils.fromWei(prices[i], "ether"),
            forSale = isForSale[i],
            available = shopAmounts[i],
            maxSupply = maxSupplies ? maxSupplies[i] : "";
          let statusBadge = "";
          if (forSale && available > 0) {
            statusBadge = `<span class="nft-status-label nft-status-listed">Listed</span>`;
          } else {
            statusBadge = `<span class="nft-status-label nft-status-notlisted">Not listed</span>`;
          }
          html += `<li class="nft-post">
            <div class="nft-post-left">
              <span class="serial-number">${++visibleCount}</span>
              <img class="nft-avatar" src="${img}" alt="NFT ${name}" onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
              <div class="nft-content">
                <div class="nft-title">${name}
                  ${maxSupply ? `<span class="nft-supply">· Max: ${maxSupply}</span>` : ""}
                </div>
                <div class="nft-description">${
                  desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
                }</div>
                ${statusBadge}
              </div>
            </div>
            <div class="nft-actions">
              <div class="price-tab">${price} POL</div>
              ${
                forSale && available != "0"
                  ? `<button class="buy-btn" onclick="buyNFT(${id}, '${prices[i]}', ${available})" ${
                      !userAccount ? "disabled" : ""
                    }><span class="material-icons">shopping_cart</span>Buy</button>`
                  : `<div class="sold-out"><span class="material-icons">block</span>Sold Out</div>`
              }
            </div>
          </li>`;
        }
        shopGrid.innerHTML = html;
        loading.style.display = "none";
        shopGrid.style.display = visibleCount > 0 ? "block" : "none";
        countEl.textContent = `T: ${visibleCount}`;
        countEl.style.display = "block";
        if (visibleCount === 0) {
          loading.textContent = "No NFTs available in shop.";
          loading.style.display = "block";
        }
        updateStatus("Shop loaded", "success");
      } catch (error) {
        console.error("loadShopNFTs failed:", error);
        logError(error, "Shop Loading");
        showError("shop-error", "Failed to load NFTs: " + error.message);
        countEl.textContent = "T: 0";
        countEl.style.display = "block";
      }
    }

    async function loadUserNFTs() {
      const myGrid = document.getElementById("myGrid");
      const loading = document.getElementById("my-loading");
      const countEl = document.getElementById("mynfts-count");
      myGrid.innerHTML = "";
      loading.style.display = "block";
      myGrid.style.display = "none";
      countEl.style.display = "none";
      hideError("my-error");
      if (!userAccount) {
        loading.textContent = "Connect wallet to view your NFTs.";
        countEl.textContent = "T: 0";
        countEl.style.display = "block";
        updateStatus("Connect wallet to view your NFTs", "info");
        return;
      }
      try {
        updateStatus("Loading your NFTs...", "info");
        if (!nftfanShop) await setupContracts();
        const tokens = await nftfanShop.methods.tokensOfOwner(userAccount).call();
        console.log("tokensOfOwner result:", tokens);
        const { tokenIds, amounts } = tokens;
        let metaArr = await Promise.all(
          tokenIds.map(async (id, idx) => {
            try {
              let meta = await nftfanShop.methods.nftInfo(id).call();
              console.log(`nftInfo for token ${id}:`, meta);
              let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
              console.log(`Metadata for token ${id}:`, metaJson);
              let listings = await nftfanShop.methods.getListings(id).call();
              console.log(`Listings for token ${id}:`, listings);
              let userListings = listings
                .map((l, index) => ({ ...l, listingIndex: index }))
                .filter((l) => l.seller.toLowerCase() === userAccount.toLowerCase() && Number(l.amount) > 0);
              console.log(`User listings for token ${id}:`, userListings);
              return { id, amount: amounts[idx], meta, metaJson, userListings };
            } catch (e) {
              console.error(`Failed to load data for token ${id}:`, e);
              return { id, amount: amounts[idx], meta: null, metaJson: null, userListings: [] };
            }
          })
        );
        // Include NFTs with listings even if amount is 0
        let additionalListings = [];
        const allShopNFTs = await nftfanShop.methods.getShopNFTs().call();
        for (let i = 0; i < allShopNFTs.ids.length; i++) {
          const id = allShopNFTs.ids[i];
          if (!tokenIds.includes(id)) {
            try {
              let listings = await nftfanShop.methods.getListings(id).call();
              let userListings = listings
                .map((l, index) => ({ ...l, listingIndex: index }))
                .filter((l) => l.seller.toLowerCase() === userAccount.toLowerCase() && Number(l.amount) > 0);
              if (userListings.length > 0) {
                let meta = await nftfanShop.methods.nftInfo(id).call();
                let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
                additionalListings.push({
                  id,
                  amount: 0,
                  meta,
                  metaJson,
                  userListings
                });
                console.log(`Added token ${id} with listings but no ownership`);
              }
            } catch (e) {
              console.error(`Failed to check listings for token ${id}:`, e);
            }
          }
        }
        metaArr = metaArr.concat(additionalListings);
        if (!metaArr.length) {
          loading.textContent = "You own no NFTs and have no active listings.";
          countEl.textContent = "T: 0";
          countEl.style.display = "block";
          updateStatus("No NFTs or listings found", "info");
          return;
        }
        let html = "";
        for (let i = 0; i < metaArr.length; i++) {
          const item = metaArr[i];
          const { id, amount, meta, metaJson, userListings } = item;
          const name = metaJson?.name || `NFTFAN #${id}`;
          const img =
            metaJson?.image || (meta?.tokenURI || "https://via.placeholder.com/92x92?text=NFT");
          const desc = metaJson?.description || "";
          const maxSupply = meta?.maxSupply || "";
          let listingsHtml = "";
          if (userListings.length > 0) {
            listingsHtml = `<div class="nft-listings" style="margin-top:5px;font-size:8px;color:#93c5fd;">Your Listings:</div>`;
            listingsHtml += userListings
              .map(
                (l, idx) => `
                  <div style="display:flex;gap:5px;align-items:center;margin-top:3px;">
                    <span>Price: ${web3.utils.fromWei(l.price, "ether")} POL</span>
                    <span>Amount: ${l.amount}</span>
                    <button class="delist-btn" onclick="cancelListing(${id}, ${l.listingIndex})">
                      <span class="material-icons">cancel</span>Delist
                    </button>
                  </div>`
              )
              .join("");
          }
          html += `<li class="nft-post">
            <div class="nft-post-left">
              <span class="serial-number">${i + 1}</span>
              <img class="nft-avatar" src="${img}" alt="NFT ${name}" 
                  onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
              <div class="nft-content">
                <div class="nft-title">${name}
                  ${maxSupply ? `<span class="nft-supply">· Max: ${maxSupply}</span>` : ""}
                </div>
                <div class="nft-description">${
                  desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
                }</div>
                <div class="nft-supply" style="margin-top:3px;color:#60a5fa;">You own: ${amount}</div>
                <button class="sell-btn" style="margin-top:5px;width:90px;" 
                        onclick="openSellModal(${id}, ${amount})" 
                        ${amount == 0 ? "disabled" : ""}>
                  <span class="material-icons">sell</span>Sell
                </button>
                ${listingsHtml}
              </div>
            </div>
          </li>`;
        }
        myGrid.innerHTML = html;
        loading.style.display = "none";
        myGrid.style.display = "block";
        countEl.textContent = `T: ${metaArr.length}`;
        countEl.style.display = "block";
        updateStatus("Your NFTs loaded", "success");
      } catch (error) {
        console.error("loadUserNFTs failed:", error);
        logError(error, "User NFTs Loading");
        showError("my-error", "Failed to load your NFTs: " + error.message);
        countEl.textContent = "T: 0";
        countEl.style.display = "block";
      }
    }

    async function loadUserListings() {
      const listingsGrid = document.getElementById("listingsGrid");
      const loading = document.getElementById("listings-loading");
      const countEl = document.getElementById("listings-count");
      listingsGrid.innerHTML = "";
      loading.style.display = "block";
      listingsGrid.style.display = "none";
      countEl.style.display = "none";
      hideError("listings-error");
      try {
        updateStatus("Loading user listings...", "info");
        if (!nftfanShop) await setupContracts();
        const result = await nftfanShop.methods.getShopNFTs().call();
        console.log("getShopNFTs for listings:", result);
        const { ids, uris } = result;
        if (!ids.length) {
          loading.textContent = "No NFTs in Shop";
          countEl.textContent = "T: 0";
          countEl.style.display = "block";
          updateStatus("No NFTs in shop", "info");
          return;
        }
        let allListings = [];
        for (let i = 0; i < ids.length; i++) {
          try {
            const id = ids[i];
            const uri = uris[i];
            const listings = await nftfanShop.methods.getListings(id).call();
            console.log(`Listings for token ${id}:`, listings);
            const meta = await nftfanShop.methods.nftInfo(id).call();
            console.log(`nftInfo for token ${id}:`, meta);
            const originalCreator = meta.originalCreator;
            const filtered = listings
              .map((l, index) => ({ ...l, id, uri, meta, listingIndex: index }))
              .filter(
                (l) =>
                  l.seller.toLowerCase() !== originalCreator.toLowerCase() &&
                  Number(l.amount) > 0
              );
            allListings = allListings.concat(filtered);
          } catch (e) {
            console.error(`Failed to load listings for token ${ids[i]}:`, e);
          }
        }
        if (!allListings.length) {
          loading.textContent = "No other user listings yet.";
          countEl.textContent = "T: 0";
          countEl.style.display = "block";
          updateStatus("No user listings", "info");
          return;
        }
        updateStatus(`Loading metadata for ${allListings.length} listings...
