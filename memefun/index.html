<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MEME.FUN NFT Marketplace</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    /* --- Your existing CSS here (trimmed for brevity, paste your CSS) --- */
    /* ... (same CSS as your original, keep your circle and layout styles!) ... */
 /* ... Keep your previous CSS here ... */
    /* For brevity, re-use your original CSS block from your HTML above,
       but you may want to tweak for the new grid/tab/modal elements.
       Below are some additions for extra UI: */
 :root {
      --primary: #fff;
      --accent: #ffc107;
      --accent2: #3cbfff;
      --bg: #181824;
      --surface1: #24243a;
      --surface2: #191933;
      --divider: #303047;
      --border1: #ffc107;
      --border2: #3cbfff;
      --price-bg: #232336;
      --price-bg2: #12243a;
      --price-color: #ffe082;
      --price-color2: #81f7ff;
      --green: #3ad37a;
      --green-dark: #1b8c4a;
      --red: #ff5469;
      --red-dark: #b81e2f;
      --shadow1: 0 4px 18px #0002;
      --shadow2: 0 0px 14px #00eaff14 inset;
      --radius: 20px;
      --meme-circle-size: 168px;
      --btn-w: 112px;
      --btn-h: 34px;
    }
    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', Arial, sans-serif;
      background: var(--bg);
      color: var(--primary);
      font-size: 12px;
      box-sizing: border-box;
      height: 100%;
      width: 100vw;
      overflow: hidden !important;
      overscroll-behavior: none;
    }
    body {
      min-height: 100vh;
      max-width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      background: var(--bg);
    }
    .header {
      width: 100vw;
      background: var(--surface1);
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      height: 44px;
      letter-spacing: 1.1px;
      font-weight: bold;
      font-size: 13px;
      box-shadow: 0 2px 7px -2px #000b;
      border-bottom: 1.5px solid var(--divider);
      flex-shrink: 0;
      position: relative;
      z-index: 10;
      gap: 4px;
      user-select: none;
    }
    .main-area {
      flex: 1;
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow: hidden;
      background: var(--bg);
      padding: 0;
    }
    .sections-wrapper {
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      padding: 0;
      margin: 0;
      gap: 0;
    }
    .section {
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      position: relative;
      z-index: 1;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
      min-height: 0;
      border-radius: 0;
      gap: 0.5rem;
    }
    .section-top {
      background: var(--surface1);
      border-bottom: 2.5px solid var(--border1);
      box-shadow: var(--shadow1);
      padding: 18px 0 0 0;
      margin: 0;
      align-items: center;
      min-height: 0;
    }
    .section-bottom {
      background: var(--surface2);
      border-top: 2.5px solid var(--border2);
      box-shadow: var(--shadow2);
      margin: 0;
      padding: 16px 0 0 0;
      border-radius: 0 0 0 0;
      align-items: center;
    }
    .section-title {
      font-size: 12px;
      font-weight: 700;
      margin: 0 0 6px 0;
      color: #ffd26e;
      letter-spacing: .9px;
      text-align: center;
      width: 100%;
      padding-top: 0;
      text-shadow: 0 2px 9px #2224;
      user-select: none;
    }
    .section-bottom .section-title {
      color: #65e6ff;
      margin-bottom: 6px;
      text-shadow: 0 2px 9px #0ff2;
    }
    .swipe-area {
      width: 100vw;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      gap: 0;
      padding: 0;
    }
    .swipe-btn {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 32px;
      cursor: pointer;
      margin: 0 10px;
      padding: 0;
      width: 38px;
      height: var(--meme-circle-size);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      border-radius: 50%;
      transition: background 0.14s;
      outline: none;
      user-select: none;
    }
    .swipe-btn:active {
      background: #23233655;
    }
    .meme-circle-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      min-width: var(--meme-circle-size);
    }
    .meme-circle {
      width: var(--meme-circle-size);
      height: var(--meme-circle-size);
      border-radius: 50%;
      overflow: hidden;
      background: linear-gradient(135deg, #25254a 60%, #3a354f 100%);
      box-shadow: 0 2px 18px 0 #0007, 0 2px 7px 0 #ffd96b10;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3.5px solid var(--border1);
      position: relative;
      flex-shrink: 0;
      transition: box-shadow 0.13s, border 0.14s;
    }
    .section-bottom .meme-circle {
      background: linear-gradient(135deg, #232b40 60%, #1b304a 100%);
      border: 3.5px solid var(--border2);
    }
    .meme-circle img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      filter: brightness(0.97) contrast(1.1);
    }
    .meme-circle.shake {
      animation: shake 0.4s;
    }
    @keyframes shake {
      0% { transform: translateX(0px) rotate(0deg);}
      18% { transform: translateX(-4px) rotate(-6deg);}
      35% { transform: translateX(4px) rotate(6deg);}
      50% { transform: translateX(-2px) rotate(-3deg);}
      62% { transform: translateX(2px) rotate(3deg);}
      75% { transform: translateX(-1px) rotate(-1deg);}
      100% { transform: translateX(0px) rotate(0deg);}
    }
    .meme-price {
      margin-top: 14px;
      font-size: 15px;
      color: var(--price-color);
      font-weight: 700;
      letter-spacing: 0.3px;
      background: var(--price-bg);
      border-radius: 13px;
      box-shadow: 0 1px 5px #0004;
      border: 1.5px solid var(--border1);
      padding: 6px 20px 4px 20px;
      min-width: 80px;
      text-align: center;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: -38px;
      pointer-events: none;
      user-select: none;
      text-shadow: 0 1px 10px #23233666;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .section-bottom .meme-price {
      border: 1.5px solid var(--border2);
      background: var(--price-bg2);
      color: var(--price-color2);
      text-shadow: 0 1px 8px #0ff2;
    }
    .buy-btn, .sell-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      border: none;
      border-radius: 17px;
      width: var(--btn-w);
      height: var(--btn-h);
      cursor: pointer;
      letter-spacing: .9px;
      outline: none;
      user-select: none;
      font-size: 15px;
      box-shadow: 0 2px 10px #0002;
      transition: background .15s, color .14s, box-shadow .15s, filter .13s;
      margin: 0 auto;
    }
    .buy-btn {
      background: var(--green);
      color: #fff;
      box-shadow: 0 2px 10px #25b95a33;
      border: 2px solid var(--green-dark);
      margin-top: 32px;
      margin-bottom: 10px;
    }
    .buy-btn:hover, .buy-btn:focus {
      background: #26d36b;
      color: #fff;
      filter: brightness(1.08);
      box-shadow: 0 2px 16px #3ad37a44;
    }
    .sell-btn {
      background: var(--red);
      color: #fff;
      box-shadow: 0 2px 10px #ff546933;
      border: 2px solid var(--red-dark);
      margin-top: 18px;
      margin-bottom: 10px;
    }
    .sell-btn:hover, .sell-btn:focus,
    .section-bottom .sell-btn:hover {
      background: #ff3747;
      color: #fff;
      filter: brightness(1.05);
      box-shadow: 0 2px 16px #ff546944;
    }
    .section-bottom .sell-btn {
      background: var(--red);
      color: #fff;
      box-shadow: 0 2px 10px #ff546933;
      border: 2px solid var(--red-dark);
      margin-top: 14px;
      margin-bottom: 10px;
    }
    .sell-price-row {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 18px 0 0 0;
      gap: 6px;
    }
    .sell-price-label {
      font-size: 12px;
      color: #65e6ff;
      margin-right: 2px;
      font-weight: 700;
      letter-spacing: 0.45px;
    }
    .sell-price-input {
      width: 54px;
      padding: 4px 10px;
      border: 1.5px solid #3cbfff;
      border-radius: 13px;
      font-size: 12px;
      outline: none;
      background: #181824;
      color: #81f7ff;
      text-align: right;
      transition: border 0.14s;
      box-shadow: 0 1px 6px #00eaff10 inset;
      font-weight: 600;
    }
    .sell-price-input:focus {
      border: 1.5px solid #81f7ff;
      background: #101020;
    }
    .sell-price-coin {
      color: #65e6ff;
      font-size: 18px;
      margin-left: 2px;
      vertical-align: middle;
      filter: drop-shadow(0 0 4px #3cbfff36);
    }
    @media (max-width: 600px) {
      :root {
        --meme-circle-size: 120px;
        --btn-w: 90px;
        --btn-h: 28px;
      }
      .meme-price { font-size: 11px; padding: 3px 10px 3px 10px; bottom: -23px;}
      .swipe-btn { width: 28px; font-size: 22px; }
      .buy-btn, .sell-btn { font-size: 11px;}
      .section-title { font-size: 10px;}
      .sell-price-input { width: 33px; font-size: 9px;}
      .sell-price-row { margin-top: 14px;}
      .buy-btn { margin-top: 24px; }
      .sell-btn { margin-top: 12px; }
      .section-bottom .sell-btn { margin-top: 10px; }
    }
    @media (max-width: 400px) {
      :root {
        --meme-circle-size: 90px;
        --btn-w: 62px;
        --btn-h: 18px;
      }
      .meme-price { font-size: 8px; padding: 2px 5px 2px 5px; bottom: -15px;}
      .buy-btn, .sell-btn { font-size: 8px;}
      .sell-price-input { width: 22px; font-size: 8px;}
      .swipe-btn { width: 18px; font-size: 15px; }
      .section-title { font-size: 8px;}
      .sell-price-row { margin-top: 8px;}
      .buy-btn { margin-top: 13px; }
      .sell-btn { margin-top: 7px; }
      .section-bottom .sell-btn { margin-top: 7px; }
    }
    .status-bar {
      display: none;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 600;
      padding: 8px 14px;
      margin: 0;
      border-radius: 0 0 18px 18px;
      box-shadow: 0 2px 8px #0003;
      position: fixed;
      top: 44px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      min-width: 200px;
      max-width: 90vw;
      background: #24243a;
      color: #fff;
      transition: background 0.18s;
      word-break: break-word;
    }
    .status-success { background: #212f23; color: #b6ffb0; }
    .status-error { background: #2a1818; color: #ffb7be; }
    .status-warn  { background: #333322; color: #ffeea6; }
    .status-info  { background: #22253a; color: #a3e1ff; }

    .tabs {
      display: flex;
      gap: 0;
      width: 100vw;
      background: #232336;
      border-bottom: 2px solid #303047;
      box-shadow: 0 2px 8px #0002;
      margin-bottom: 0;
      z-index: 9;
    }
    .tab-btn {
      flex: 1 1 0;
      text-align: center;
      font-size: 15px;
      font-weight: 600;
      padding: 13px 0 11px 0;
      background: none;
      border: none;
      color: #ffc107;
      cursor: pointer;
      outline: none;
      letter-spacing: .5px;
      border-bottom: 2.5px solid transparent;
      transition: color 0.14s, border 0.14s;
      user-select: none;
      position: relative;
    }
    .tab-btn.active {
      color: #3cbfff;
      border-bottom: 2.5px solid #3cbfff;
      background: #1a2030;
    }
    .tab-content {
      display: none;
      width: 100vw;
      min-height: 320px;
      background: var(--surface1);
      padding: 0 0 30px 0;
      overflow-x: hidden;
      position: relative;
    }
    .tab-content.active { display: block; }

    .nft-list {
      list-style: none;
      padding: 0;
      margin: 22px auto 0 auto;
      max-width: 540px;
      width: 97vw;
      display: flex;
      flex-direction: column;
      gap: 13px;
    }
    .nft-post {
      display: flex;
      background: var(--surface2);
      border-radius: 16px;
      box-shadow: 0 2px 8px #0002;
      overflow: hidden;
      border: 2px solid #232336;
      align-items: stretch;
    }
    .nft-post-left {
      display: flex;
      align-items: flex-start;
      gap: 11px;
      padding: 10px;
      flex: 1 1 0;
      min-width: 0;
    }
    .serial-number {
      font-size: 15px;
      color: #ffc107;
      font-weight: 800;
      margin-right: 7px;
      min-width: 23px;
      text-align: right;
    }
    .nft-avatar {
      width: 54px;
      height: 54px;
      object-fit: cover;
      border-radius: 9px;
      background: #151522;
      border: 1.5px solid #303047;
    }
    .nft-content {
      flex: 1;
      min-width: 0;
    }
    .nft-title {
      font-size: 16px;
      font-weight: 700;
      color: #ffe082;
      margin-bottom: 2px;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }
    .nft-description {
      font-size: 12px;
      color: #bfccea;
      margin-bottom: 2px;
      margin-top: 2px;
      line-height: 1.3em;
      max-width: 240px;
      word-break: break-word;
    }
    .nft-supply {
      font-size: 11px;
      color: #3cbfff;
      margin-left: 7px;
    }
    .nft-status-label {
      font-size: 10px;
      padding: 2px 7px;
      border-radius: 11px;
      margin-left: 7px;
      font-weight: 600;
      background: #333;
      border: 1px solid #303047;
      color: #bfccea;
    }
    .nft-status-listed { background: #1b8c4a; color: #caffc0; border-color: #3ad37a; }
    .nft-status-notlisted { background: #a15353; color: #ffd7d7; border-color: #ff5469; }

    .nft-actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: center;
      gap: 7px;
      padding: 10px 13px 10px 0;
      min-width: 90px;
    }
    .price-tab {
      font-size: 13px;
      color: #ffd26e;
      background: #232336;
      border-radius: 9px;
      padding: 3px 10px;
      font-weight: 700;
      margin-bottom: 4px;
      min-width: 65px;
      text-align: right;
      box-shadow: 0 1px 5px #0002;
      border: 1.5px solid #ffc107;
    }
    .buy-btn {
      background: #3ad37a;
      color: #fff;
      border-radius: 17px;
      border: 2px solid #1b8c4a;
      font-size: 15px;
      font-weight: 700;
      padding: 5px 17px;
      box-shadow: 0 2px 10px #25b95a33;
      margin-top: 0;
      margin-bottom: 0;
      cursor: pointer;
      letter-spacing: .9px;
      outline: none;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: background .13s, color .13s;
    }
    .buy-btn:disabled { opacity: 0.7; cursor: not-allowed; }
    .sell-btn, .delist-btn {
      background: #ff5469;
      color: #fff;
      border-radius: 17px;
      border: 2px solid #b81e2f;
      font-size: 13px;
      font-weight: 700;
      padding: 4px 13px;
      box-shadow: 0 2px 10px #ff546933;
      margin-top: 0;
      margin-bottom: 0;
      cursor: pointer;
      letter-spacing: .5px;
      outline: none;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: background .13s, color .13s;
    }
    .sell-btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .delist-btn { background: #505060; border: 2px solid #333; font-size: 12px; }
    .sold-out {
      font-size: 12px;
      color: #ff5469;
      display: flex;
      align-items: center;
      gap: 4px;
      margin-top: 4px;
    }
    .counter-row, .error-row {
      color: #ffb7be;
      font-size: 12px;
      margin: 6px 0 0 12px;
      display: none;
    }
    .counter-row.active, .error-row.active { display: block; }

    /* Sell Modal Overlay */
    #sellModal {
      display: none;
      position: fixed;
      z-index: 999;
      left: 0; top: 0; right: 0; bottom: 0;
      background: #0008;
      align-items: center;
      justify-content: center;
    }
    #sellModal .modal-content {
      background: #232336;
      color: #fff;
      padding: 28px 24px 24px 24px;
      border-radius: 18px;
      box-shadow: 0 4px 30px #0008;
      max-width: 95vw;
      min-width: 270px;
      width: 340px;
      font-size: 16px;
      display: flex;
      flex-direction: column;
      gap: 18px;
      align-items: stretch;
      position: relative;
    }
    #sellModal input[type="number"] {
      background: #161622;
      color: #c9f7ff;
      border: 1.5px solid #3cbfff;
      border-radius: 7px;
      font-size: 15px;
      padding: 7px 13px;
      width: 100%;
      margin-top: 6px;
      box-sizing: border-box;
      font-weight: 600;
    }
    #sellModalError {
      color: #ffb7be;
      font-size: 13px;
      margin-top: 2px;
    }
    #sellModal .close-btn {
      position: absolute;
      right: 13px;
      top: 13px;
      color: #aaa;
      background: none;
      border: none;
      font-size: 21px;
      cursor: pointer;
    }
    @media (max-width: 600px) {
      .nft-list { max-width: 98vw; }
      #sellModal .modal-content { min-width: 0; width: 97vw; }
    }
    .status-bar {
      display: none;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-weight: 600;
      padding: 8px 14px;
      margin: 0;
      border-radius: 0 0 18px 18px;
      box-shadow: 0 2px 8px #0003;
      position: fixed;
      top: 44px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 100;
      min-width: 200px;
      max-width: 90vw;
      background: #24243a;
      color: #fff;
      transition: background 0.18s;
      word-break: break-word;
    }
    .status-success { background: #212f23; color: #b6ffb0; }
    .status-error { background: #2a1818; color: #ffb7be; }
    .status-warn  { background: #333322; color: #ffeea6; }
    .status-info  { background: #22253a; color: #a3e1ff; }

    .tabs {
      display: flex;
      gap: 0;
      width: 100vw;
      background: #232336;
      border-bottom: 2px solid #303047;
      box-shadow: 0 2px 8px #0002;
      margin-bottom: 0;
      z-index: 9;
    }
    .tab-btn {
      flex: 1 1 0;
      text-align: center;
      font-size: 15px;
      font-weight: 600;
      padding: 13px 0 11px 0;
      background: none;
      border: none;
      color: #ffc107;
      cursor: pointer;
      outline: none;
      letter-spacing: .5px;
      border-bottom: 2.5px solid transparent;
      transition: color 0.14s, border 0.14s;
      user-select: none;
      position: relative;
    }
    .tab-btn.active {
      color: #3cbfff;
      border-bottom: 2.5px solid #3cbfff;
      background: #1a2030;
    }
    .tab-content {
      display: none;
      width: 100vw;
      min-height: 320px;
      background: var(--surface1);
      padding: 0 0 30px 0;
      overflow-x: hidden;
      position: relative;
    }
    .tab-content.active { display: block; }
    /* ... keep your meme circle and button CSS ... */
  </style>
</head>
<body>
  <div class="header">
    <span class="material-icons" aria-label="emoji">emoji_emotions</span>
    MEME.FUN NFT Marketplace
    <button id="connect-btn" style="margin-left:auto; margin-right:16px; font-weight:600; background:#ffc107; color:#232336; border:none; border-radius:12px; padding:7px 18px; cursor:pointer; font-size:14px;">ðŸ”— Connect Wallet</button>
  </div>
  <div id="statusBar" class="status-bar"><span id="statusBarIcon" class="material-icons" style="font-size:18px; margin-right:4px;">info</span><span>Ready</span></div>

  <div class="tabs">
    <button class="tab-btn active" id="tab-shop"><span class="material-icons" style="font-size:17px;margin-bottom:-3px;">storefront</span> Shop</button>
    <button class="tab-btn" id="tab-mynfts"><span class="material-icons" style="font-size:17px;margin-bottom:-3px;">account_circle</span> My NFTs</button>
    <button class="tab-btn" id="tab-listings"><span class="material-icons" style="font-size:17px;margin-bottom:-3px;">swap_horiz</span> Listings</button>
  </div>

  <div class="main-area">
    <!-- SHOP TAB with circle UI -->
    <div class="tab-content active" id="tab-content-shop">
      <div class="section-title" style="margin:17px 0 0 10px;">NFT SHOP</div>
      <div class="swipe-area">
        <button class="swipe-btn" id="shopLeftBtn" tabindex="0"><span class="material-icons">chevron_left</span></button>
        <div class="meme-circle-wrap">
          <div class="meme-circle" id="shopCircle"></div>
          <div class="meme-price" id="shopPrice"></div>
        </div>
        <button class="swipe-btn" id="shopRightBtn" tabindex="0"><span class="material-icons">chevron_right</span></button>
      </div>
      <button class="buy-btn" id="buyBtn"><span class="material-icons" style="font-size:16px;margin-right:6px;">shopping_cart</span>Buy</button>
      <div id="shop-error" class="error-row"></div>
    </div>
    <!-- MY NFT TAB with circle UI -->
    <div class="tab-content" id="tab-content-mynfts">
      <div class="section-title" style="margin:17px 0 0 10px;">MY NFTs</div>
      <div class="swipe-area">
        <button class="swipe-btn" id="myLeftBtn" tabindex="0"><span class="material-icons">chevron_left</span></button>
        <div class="meme-circle-wrap">
          <div class="meme-circle" id="myCircle"></div>
        </div>
        <button class="swipe-btn" id="myRightBtn" tabindex="0"><span class="material-icons">chevron_right</span></button>
      </div>
      <div class="sell-price-row">
        <span class="sell-price-label">Set Price:</span>
        <input class="sell-price-input" id="mySellPriceInput" type="number" min="0" step="0.01" value="0.02">
        <span class="material-icons sell-price-coin">monetization_on</span>
      </div>
      <button class="sell-btn" id="sellBtn"><span class="material-icons" style="font-size:16px;margin-right:6px;">sell</span>Sell</button>
      <div id="my-error" class="error-row"></div>
    </div>
    <!-- LISTINGS tab, keep as grid or compact display if wanted -->
    <div class="tab-content" id="tab-content-listings">
      <div class="section-title" style="margin:17px 0 0 10px;">User Listings</div>
      <div id="listings-loading" class="counter-row active" style="color:#bfccea;">Loading user listings...</div>
      <div id="listings-error" class="error-row"></div>
      <ul class="nft-list" id="listingsGrid"></ul>
    </div>
  </div>

  <!-- Sell Modal (hidden for now) -->
  <div id="sellModal" style="display:none;position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1000;align-items:center;justify-content:center;background:#0008;">
    <div class="modal-content" style="background:#232336;color:#fff;padding:28px 24px 24px 24px;border-radius:18px;max-width:95vw;min-width:270px;width:340px;font-size:16px;display:flex;flex-direction:column;gap:18px;align-items:stretch;position:relative;">
      <button class="close-btn" onclick="closeSellModal()" style="position:absolute;right:13px;top:13px;color:#aaa;background:none;border:none;font-size:21px;cursor:pointer;"><span class="material-icons">close</span></button>
      <div style="font-weight:700;">Sell NFT <span id="sellTokenId"></span></div>
      <div>Amount (max <span id="sellMaxAmount">?</span>): <input id="sellAmountInput" type="number" min="1" value="1" step="1" /></div>
      <div>Price (in MATIC): <input id="sellPriceInput" type="number" min="0.00001" step="0.00001" placeholder="e.g. 0.02" /></div>
      <div id="sellModalError" style="color:#ffb7be;font-size:13px;"></div>
      <button class="sell-btn" onclick="confirmSellNFT()" style="margin-top:11px;"><span class="material-icons" style="font-size:16px;margin-right:6px;">sell</span>Confirm Sell</button>
    </div>
  </div>

   <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
<script>
  // --- CONFIG ---
  const POLYGON_PARAMS = {
    chainId: "0x89",
    chainName: "Polygon Mainnet",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: [
      "https://polygon-rpc.com/",
      "https://rpc.polygon.technology/",
      "https://rpc-mainnet.matic.network/",
    ],
    blockExplorerUrls: ["https://polygonscan.com/"],
  };
  const NFTFAN_SHOP_CA = "0x668F3F71D33E77ac12447C77231a4B373ce2A6fE";
    const NFTFAN_SHOP_ABI = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "creator",
        type: "address",
      },
      {
        indexed: false,
        internalType: "string",
        name: "tokenURI",
        type: "string",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NFTMinted",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "buyer",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NFTBought",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NFTListed",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "NFTUnlisted",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "listingIndex",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "ListingCancelled",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "buyNFT",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "listingIndex",
        type: "uint256",
      },
    ],
    name: "cancelListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "exists",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "getListings",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "seller",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256",
          },
        ],
        internalType: "struct NFTFansShop.Listing[]",
        name: "",
        type: "tuple[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "getShopInventory",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getShopNFTs",
    outputs: [
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]",
      },
      {
        internalType: "string[]",
        name: "uris",
        type: "string[]",
      },
      {
        internalType: "uint256[]",
        name: "prices",
        type: "uint256[]",
      },
      {
        internalType: "bool[]",
        name: "isForSale",
        type: "bool[]",
      },
      {
        internalType: "uint256[]",
        name: "shopAmounts",
        type: "uint256[]",
      },
      {
        internalType: "uint256[]",
        name: "maxSupplies",
        type: "uint256[]",
      },
      {
        internalType: "uint256[]",
        name: "currentSupplies",
        type: "uint256[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_tokenURI",
        type: "string",
      },
      {
        internalType: "uint256",
        name: "_price",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_maxSupply",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "mintNFT",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "mintAdditional",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "nextTokenId",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "nftInfo",
    outputs: [
      {
        internalType: "string",
        name: "tokenURI",
        type: "string",
      },
      {
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        internalType: "bool",
        name: "forSale",
        type: "bool",
      },
      {
        internalType: "address",
        name: "originalCreator",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "maxSupply",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "currentSupply",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_price",
        type: "uint256",
      },
    ],
    name: "sellNFT",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address",
      },
    ],
    name: "tokensOfOwner",
    outputs: [
      {
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]",
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "unlistNFT",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
];

  let userAccount = null,
    web3,
    nftfanShop = null,
    lastError = null,
    statusTimeout = null;
  let sellModalTokenId = null,
    sellModalMaxAmount = null;

 function setStatusBar(type, message) {
  const statusBar = document.getElementById("statusBar");
  const iconSpan = document.getElementById("statusBarIcon");
  statusBar.className = `status-bar status-${type}`;
  if (iconSpan) {
    if (type === "success") iconSpan.textContent = "check_circle";
    else if (type === "error") iconSpan.textContent = "error";
    else if (type === "warn") iconSpan.textContent = "warning";
    else iconSpan.textContent = "info";
  }
  statusBar.style.display = "flex";
  statusBar.textContent = "";
  statusBar.appendChild(iconSpan);
  statusBar.appendChild(document.createTextNode(message));
}

function updateStatus(message, type = "info") {
  setStatusBar(type, message);
  // Status bar stays on screen; no timeout to hide it.
}

function logError(error, context = "") {
  lastError = `${context}: ${error.message || error}`;
}

function showError(elementId, message) {
  const errorEl = document.getElementById(elementId);
  errorEl.textContent = message;
  errorEl.style.display = "block";
  updateStatus(message, "error");
}

function hideError(elementId) {
  document.getElementById(elementId).style.display = "none";
}

  async function connectWallet() {
    try {
      updateStatus("Connecting wallet...", "info");
      if (!window.ethereum) throw new Error("Please install MetaMask or a compatible wallet!");
      const chainId = await window.ethereum.request({ method: "eth_chainId" });
      if (chainId !== POLYGON_PARAMS.chainId) {
        updateStatus("Switching to Polygon network...", "info");
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: POLYGON_PARAMS.chainId }],
          });
        } catch (switchError) {
          if (switchError.code === 4902) {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [POLYGON_PARAMS],
            });
          } else {
            throw switchError;
          }
        }
      }
      const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
      userAccount = accounts[0];
      document.getElementById("connect-btn").textContent = formatAddress(userAccount);
      await setupContracts();
      updateStatus("Connected successfully", "success");
      loadShopNFTs();
      loadUserNFTs();
      loadUserListings();
    } catch (error) {
      console.error("connectWallet failed:", error);
      logError(error, "Wallet Connection");
      updateStatus("Connection failed: " + error.message, "error");
    }
  }

  async function setupContracts() {
    try {
      updateStatus("Setting up contracts...", "info");
      const rpcUrls = POLYGON_PARAMS.rpcUrls;
      let provider = null;
      if (window.ethereum) {
        provider = window.ethereum;
        console.log("Using MetaMask provider");
      } else {
        for (const rpcUrl of rpcUrls) {
          try {
            const testWeb3 = new Web3(rpcUrl);
            const blockNumber = await testWeb3.eth.getBlockNumber();
            console.log(`Connected to RPC ${rpcUrl}, block number: ${blockNumber}`);
            provider = rpcUrl;
            break;
          } catch (e) {
            console.error(`Failed to connect to RPC ${rpcUrl}:`, e);
          }
        }
      }
      if (!provider) throw new Error("No working RPC provider found");
      web3 = new Web3(provider);
      nftfanShop = new web3.eth.Contract(NFTFAN_SHOP_ABI, NFTFAN_SHOP_CA);
      console.log("Contract initialized at address:", NFTFAN_SHOP_CA);
      updateStatus("Contracts initialized", "success");
    } catch (error) {
      console.error("Contract setup failed:", error);
      logError(error, "Contract Setup");
      updateStatus("Contract setup failed: " + error.message, "error");
      throw error;
    }
  }

  async function fetchOpenSeaMeta(uri) {
    if (!uri) return null;
    try {
      if (uri.startsWith("ipfs://")) uri = "https://ipfs.io/ipfs/" + uri.slice(7);
      if (uri.startsWith("ar://")) uri = "https://arweave.net/" + uri.slice(5);
      const res = await fetch(uri, { mode: "cors" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      console.error("fetchOpenSeaMeta failed for URI", uri, ":", e);
      updateStatus("Metadata fetch failed: " + (uri || "unknown"), "warn");
      return null;
    }
  }

  let permanentlySoldOutIds = JSON.parse(localStorage.getItem("nftfans_permanently_sold_out_ids") || "[]");

  function markPermanentlySoldOut(tokenId) {
    if (!permanentlySoldOutIds.includes(tokenId)) {
      permanentlySoldOutIds.push(tokenId);
      localStorage.setItem("nftfans_permanently_sold_out_ids", JSON.stringify(permanentlySoldOutIds));
    }
  }

async function loadShopNFTs() {
  const shopGrid = document.getElementById("shopGrid");
  const loading = document.getElementById("shop-loading");
  const countEl = document.getElementById("shop-count");
  shopGrid.innerHTML = "";
  loading.style.display = "block";
  shopGrid.style.display = "none";
  countEl.style.display = "none";
  hideError("shop-error");
  try {
    updateStatus("Loading shop NFTs...", "info");
    if (!nftfanShop) await setupContracts();
    const result = await nftfanShop.methods.getShopNFTs().call();
    console.log("getShopNFTs result:", result);
    const { ids, uris, prices, isForSale, shopAmounts, maxSupplies } = result;
    if (!ids.length) {
      loading.textContent = "No NFTs in Shop";
      countEl.textContent = "ART: 0";
      countEl.style.display = "block";
      updateStatus("No NFTs in shop", "info");
      return;
    }
    updateStatus(`Loading metadata for ${ids.length} NFTs...`, "info");
    const metaArr = await Promise.all(
      uris.map(async (uri, i) => {
        try {
          const meta = await fetchOpenSeaMeta(uri);
          console.log(`Metadata for URI ${uri}:`, meta);
          return meta;
        } catch (e) {
          console.error(`Failed to fetch metadata for URI ${uri}:`, e);
          return null;
        }
      })
    );
    let html = "";
    let visibleCount = 0;
    for (let i = 0; i < ids.length; i++) {
      const id = ids[i],
        meta = metaArr[i],
        name = meta?.name || `NFTFAN #${id}`,
        img = meta?.image || uris[i] || "https://via.placeholder.com/92x92?text=NFT",
        desc = meta?.description || "",
        price = web3.utils.fromWei(prices[i], "ether"),
        forSale = isForSale[i],
        available = shopAmounts[i],
        maxSupply = maxSupplies ? maxSupplies[i] : "";
      let statusBadge = "";
      if (forSale && available > 0) {
        statusBadge = `<span class="nft-status-label nft-status-listed">Listed</span>`;
      } else {
        statusBadge = `<span class="nft-status-label nft-status-notlisted">Not listed</span>`;
      }
      html += `<li class="nft-post">
        <div class="nft-post-left">
          <span class="serial-number">${++visibleCount}</span>
          <img class="nft-avatar" src="${img}" alt="NFT ${name}" onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
          <div class="nft-content">
            <div class="nft-title">${name}
              ${maxSupply ? `<span class="nft-supply">Â· Max: ${maxSupply}</span>` : ""}
            </div>
            <div class="nft-description">${
              desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
            }</div>
            ${statusBadge}
          </div>
        </div>
        <div class="nft-actions">
          <div class="price-tab">${price} POL</div>
          ${
            forSale && available != "0"
              ? `<button class="buy-btn" onclick="buyNFT(${id}, '${prices[i]}', ${available})" ${
                  !userAccount ? "disabled" : ""
                }><span class="material-icons">shopping_cart</span>Buy</button>`
              : `<div class="sold-out"><span class="material-icons">block</span>Sold Out</div>`
          }
        </div>
      </li>`;
    }
    shopGrid.innerHTML = html;
    loading.style.display = "none";
    shopGrid.style.display = visibleCount > 0 ? "block" : "none";
    countEl.textContent = `T: ${visibleCount}`;
    countEl.style.display = "block";
    if (visibleCount === 0) {
      loading.textContent = "No NFTs available in shop.";
      loading.style.display = "block";
    }
    updateStatus("Shop loaded", "success");
  } catch (error) {
    console.error("loadShopNFTs failed:", error);
    logError(error, "Shop Loading");
    showError("shop-error", "Failed to load NFTs: " + error.message);
    countEl.textContent = "T: 0";
    countEl.style.display = "block";
  }
}

 async function loadUserNFTs() {
  const myGrid = document.getElementById("myGrid");
  const loading = document.getElementById("my-loading");
  const countEl = document.getElementById("mynfts-count");
  myGrid.innerHTML = "";
  loading.style.display = "block";
  myGrid.style.display = "none";
  countEl.style.display = "none";
  hideError("my-error");
  if (!userAccount) {
    loading.textContent = "Connect wallet to view your NFTs.";
    countEl.textContent = "T: 0";
    countEl.style.display = "block";
    updateStatus("Connect wallet to view your NFTs", "info");
    return;
  }
  try {
    updateStatus("Loading your NFTs...", "info");
    if (!nftfanShop) await setupContracts();
    const tokens = await nftfanShop.methods.tokensOfOwner(userAccount).call();
    console.log("tokensOfOwner result:", tokens);
    const { tokenIds, amounts } = tokens;
    let metaArr = await Promise.all(
      tokenIds.map(async (id, idx) => {
        try {
          let meta = await nftfanShop.methods.nftInfo(id).call();
          console.log(`nftInfo for token ${id}:`, meta);
          let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
          console.log(`Metadata for token ${id}:`, metaJson);
          let listings = await nftfanShop.methods.getListings(id).call();
          console.log(`Listings for token ${id}:`, listings);
          let userListings = listings
            .map((l, index) => ({ ...l, listingIndex: index }))
            .filter((l) => l.seller.toLowerCase() === userAccount.toLowerCase() && Number(l.amount) > 0);
          console.log(`User listings for token ${id}:`, userListings);
          return { id, amount: amounts[idx], meta, metaJson, userListings };
        } catch (e) {
          console.error(`Failed to load data for token ${id}:`, e);
          return { id, amount: amounts[idx], meta: null, metaJson: null, userListings: [] };
        }
      })
    );
    // Include NFTs with listings even if amount is 0
    let additionalListings = [];
    const allShopNFTs = await nftfanShop.methods.getShopNFTs().call();
    for (let i = 0; i < allShopNFTs.ids.length; i++) {
      const id = allShopNFTs.ids[i];
      if (!tokenIds.includes(id)) {
        try {
          let listings = await nftfanShop.methods.getListings(id).call();
          let userListings = listings
            .map((l, index) => ({ ...l, listingIndex: index }))
            .filter((l) => l.seller.toLowerCase() === userAccount.toLowerCase() && Number(l.amount) > 0);
          if (userListings.length > 0) {
            let meta = await nftfanShop.methods.nftInfo(id).call();
            let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
            additionalListings.push({
              id,
              amount: 0,
              meta,
              metaJson,
              userListings
            });
            console.log(`Added token ${id} with listings but no ownership`);
          }
        } catch (e) {
          console.error(`Failed to check listings for token ${id}:`, e);
        }
      }
    }
    metaArr = metaArr.concat(additionalListings);
    if (!metaArr.length) {
      loading.textContent = "You own no NFTs and have no active listings.";
      countEl.textContent = "T: 0";
      countEl.style.display = "block";
      updateStatus("No NFTs or listings found", "info");
      return;
    }
    let html = "";
    for (let i = 0; i < metaArr.length; i++) {
      const item = metaArr[i];
      const { id, amount, meta, metaJson, userListings } = item;
      const name = metaJson?.name || `NFTFAN #${id}`;
      const img =
        metaJson?.image || (meta?.tokenURI || "https://via.placeholder.com/92x92?text=NFT");
      const desc = metaJson?.description || "";
      const maxSupply = meta?.maxSupply || "";
      let listingsHtml = "";
      if (userListings.length > 0) {
        listingsHtml = `<div class="nft-listings" style="margin-top:5px;font-size:8px;color:#93c5fd;">Your Listings:</div>`;
        listingsHtml += userListings
          .map(
            (l, idx) => `
              <div style="display:flex;gap:5px;align-items:center;margin-top:3px;">
                <span>Price: ${web3.utils.fromWei(l.price, "ether")} POL</span>
                <span>Amount: ${l.amount}</span>
                <button class="delist-btn" onclick="cancelListing(${id}, ${l.listingIndex})">
                  <span class="material-icons">cancel</span>Delist
                </button>
              </div>`
          )
          .join("");
      }
      html += `<li class="nft-post">
        <div class="nft-post-left">
          <span class="serial-number">${i + 1}</span>
          <img class="nft-avatar" src="${img}" alt="NFT ${name}" 
               onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
          <div class="nft-content">
            <div class="nft-title">${name}
              ${maxSupply ? `<span class="nft-supply">Â· Max: ${maxSupply}</span>` : ""}
            </div>
            <div class="nft-description">${
              desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
            }</div>
            <div class="nft-supply" style="margin-top:3px;color:#60a5fa;">You own: ${amount}</div>
            <button class="sell-btn" style="margin-top:5px;width:90px;" 
                    onclick="openSellModal(${id}, ${amount})" 
                    ${amount == 0 ? "disabled" : ""}>
              <span class="material-icons">sell</span>Sell
            </button>
            ${listingsHtml}
          </div>
        </div>
      </li>`;
    }
    myGrid.innerHTML = html;
    loading.style.display = "none";
    myGrid.style.display = "block";
    countEl.textContent = `T: ${metaArr.length}`;
    countEl.style.display = "block";
    updateStatus("Your NFTs loaded", "success");
  } catch (error) {
    console.error("loadUserNFTs failed:", error);
    logError(error, "User NFTs Loading");
    showError("my-error", "Failed to load your NFTs: " + error.message);
    countEl.textContent = "T: 0";
    countEl.style.display = "block";
  }
}

async function loadUserListings() {
  const listingsGrid = document.getElementById("listingsGrid");
  const loading = document.getElementById("listings-loading");
  const countEl = document.getElementById("listings-count");
  listingsGrid.innerHTML = "";
  loading.style.display = "block";
  listingsGrid.style.display = "none";
  countEl.style.display = "none";
  hideError("listings-error");
  try {
    updateStatus("Loading user listings...", "info");
    if (!nftfanShop) await setupContracts();
    const result = await nftfanShop.methods.getShopNFTs().call();
    console.log("getShopNFTs for listings:", result);
    const { ids, uris } = result;
    if (!ids.length) {
      loading.textContent = "No NFTs in Shop";
      countEl.textContent = "T: 0";
      countEl.style.display = "block";
      updateStatus("No NFTs in shop", "info");
      return;
    }
    let allListings = [];
    for (let i = 0; i < ids.length; i++) {
      try {
        const id = ids[i];
        const uri = uris[i];
        const listings = await nftfanShop.methods.getListings(id).call();
        console.log(`Listings for token ${id}:`, listings);
        const meta = await nftfanShop.methods.nftInfo(id).call();
        console.log(`nftInfo for token ${id}:`, meta);
        const originalCreator = meta.originalCreator;
        const filtered = listings
          .map((l, index) => ({ ...l, id, uri, meta, listingIndex: index }))
          .filter(
            (l) =>
              l.seller.toLowerCase() !== originalCreator.toLowerCase() &&
              Number(l.amount) > 0
          );
        allListings = allListings.concat(filtered);
      } catch (e) {
        console.error(`Failed to load listings for token ${ids[i]}:`, e);
      }
    }
    if (!allListings.length) {
      loading.textContent = "No other user listings yet.";
      countEl.textContent = "T: 0";
      countEl.style.display = "block";
      updateStatus("No user listings", "info");
      return;
    }
    updateStatus(`Loading metadata for ${allListings.length} listings...`, "info");
    let html = "";
    for (let i = 0; i < allListings.length; i++) {
      const l = allListings[i];
      let metaJson = await fetchOpenSeaMeta(l.meta.tokenURI);
      console.log(`Metadata for listing ${l.id}:`, metaJson);
      let name = metaJson?.name || `NFTFAN #${l.id}`;
      let img =
        metaJson?.image || l.meta.tokenURI || "https://via.placeholder.com/92x92?text=NFT";
      let desc = metaJson?.description || "";
      let price = web3.utils.fromWei(l.price, "ether");
      html += `<li class="nft-post">
        <div class="nft-post-left">
          <span class="serial-number">${i + 1}</span>
          <img class="nft-avatar" src="${img}" alt="NFT ${name}" 
               onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
          <div class="nft-content">
            <div class="nft-title">${name}
              ${l.meta.maxSupply ? `<span class="nft-supply">Â· Max: ${l.meta.maxSupply}</span>` : ""}
            </div>
            <div class="nft-description">${
              desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
            }</div>
            <div class="nft-supply" style="margin-top:3px;color:#60a5fa;">Seller: ${formatAddress(
              l.seller
            )}</div>
          </div>
        </div>
        <div class="nft-actions">
          <div class="price-tab">${price} POL</div>
          <button class="buy-btn" onclick="buyUserListing('${l.id}', '${l.seller}', '${
            l.price
          }', '${l.amount}')" ${!userAccount ? "disabled" : ""}>
            <span class="material-icons">shopping_cart</span>Buy
          </button>
        </div>
      </li>`;
    }
    listingsGrid.innerHTML = html;
    loading.style.display = "none";
    listingsGrid.style.display = "block";
    countEl.textContent = `T: ${allListings.length}`;
    countEl.style.display = "block";
    updateStatus("User listings loaded", "success");
  } catch (error) {
    console.error("loadUserListings failed:", error);
    logError(error, "User Listings Loading");
    showError("listings-error", "Failed to load user listings: " + error.message);
    countEl.textContent = "T: 0";
    countEl.style.display = "block";
  }
}

  window.buyNFT = async function (tokenId, priceWei, availableAmount) {
    if (!userAccount) return updateStatus("Connect your wallet first!", "error");
    let amount = 1;
    if (availableAmount > 1) {
      let input = prompt(`How many would you like to buy? (max ${availableAmount})`, "1");
      if (!input) return;
      amount = parseInt(input);
      if (isNaN(amount) || amount < 1 || amount > availableAmount)
        return updateStatus("Invalid amount", "error");
    }
    try {
      updateStatus("Processing purchase...", "info");
      await nftfanShop.methods.buyNFT(tokenId, amount).send({
        from: userAccount,
        value: (BigInt(priceWei) * BigInt(amount)).toString(),
      });
      updateStatus("NFT bought successfully!", "success");
      await loadShopNFTs();
      await loadUserNFTs();
      await loadUserListings();
    } catch (error) {
      console.error("buyNFT failed:", error);
      logError(error, "NFT Purchase");
      updateStatus("Purchase failed: " + error.message, "error");
    }
  };

  window.buyUserListing = async function (tokenId, seller, priceWei, availableAmount) {
    if (!userAccount) return updateStatus("Connect your wallet first!", "error");
    let amount = 1;
    if (availableAmount > 1) {
      let input = prompt(`How many would you like to buy from user? (max ${availableAmount})`, "1");
      if (!input) return;
      amount = parseInt(input);
      if (isNaN(amount) || amount < 1 || amount > availableAmount)
        return updateStatus("Invalid amount", "error");
    }
    try {
      updateStatus("Processing purchase...", "info");
      await nftfanShop.methods.buyNFT(tokenId, amount).send({
        from: userAccount,
        value: (BigInt(priceWei) * BigInt(amount)).toString(),
      });
      updateStatus("NFT bought successfully!", "success");
      await loadShopNFTs();
      await loadUserNFTs();
      await loadUserListings();
    } catch (error) {
      console.error("buyUserListing failed:", error);
      logError(error, "NFT User Listing Purchase");
      updateStatus("Purchase failed: " + error.message, "error");
    }
  };

 window.cancelListing = async function (tokenId, listingIndex) {
  if (!userAccount) return updateStatus("Connect your wallet first!", "error");
  if (!confirm("Are you sure you want to delist this NFT?")) return;
  try {
    updateStatus("Delisting NFT...", "info");
    await nftfanShop.methods
      .cancelListing(tokenId, listingIndex)
      .send({ from: userAccount });
    updateStatus("NFT delisted successfully!", "success");
    await loadShopNFTs();
    await loadUserNFTs();
    await loadUserListings();
  } catch (error) {
    console.error("cancelListing failed:", error);
    logError(error, "Delist NFT");
    updateStatus("Delist failed: " + error.message, "error");
  }
};

  window.openSellModal = function (tokenId, maxAmount) {
    sellModalTokenId = tokenId;
    sellModalMaxAmount = maxAmount;
    document.getElementById("sellModal").style.display = "flex";
    document.getElementById("sellTokenId").textContent = tokenId;
    document.getElementById("sellMaxAmount").textContent = maxAmount;
    document.getElementById("sellAmountInput").value = "";
    document.getElementById("sellAmountInput").max = maxAmount;
    document.getElementById("sellPriceInput").value = "";
    document.getElementById("sellModalError").textContent = "";
  };

  window.closeSellModal = function () {
    document.getElementById("sellModal").style.display = "none";
    sellModalTokenId = null;
    sellModalMaxAmount = null;
  };

  window.confirmSellNFT = async function () {
    const amount = parseInt(document.getElementById("sellAmountInput").value);
    const price = document.getElementById("sellPriceInput").value;
    document.getElementById("sellModalError").textContent = "";
    if (!userAccount) return document.getElementById("sellModalError").textContent = "Connect your wallet first!";
    if (!amount || isNaN(amount) || amount < 1 || amount > sellModalMaxAmount)
      return document.getElementById("sellModalError").textContent = "Invalid amount!";
    if (!price || isNaN(price) || Number(price) <= 0)
      return document.getElementById("sellModalError").textContent = "Invalid price!";
    let priceWei = "0";
    try {
      priceWei = web3.utils.toWei(price, "ether");
    } catch {
      return document.getElementById("sellModalError").textContent = "Invalid price.";
    }
    try {
      updateStatus("Processing sale...", "info");
      await nftfanShop.methods.sellNFT(sellModalTokenId, amount, priceWei).send({ from: userAccount });
      updateStatus("NFT listed for sale!", "success");
      closeSellModal();
      await loadShopNFTs();
      await loadUserNFTs();
      await loadUserListings();
    } catch (error) {
      console.error("confirmSellNFT failed:", error);
      logError(error, "NFT Sale");
      updateStatus("Sale listing failed: " + error.message, "error");
      document.getElementById("sellModalError").textContent = "Sale failed: " + error.message;
    }
  };

  window.onclick = function (event) {
    const modal = document.getElementById("sellModal");
    if (event.target === modal) closeSellModal();
  };

  function formatAddress(address) {
    if (!address) return "";
    return `${address.slice(0, 5)}...${address.slice(-4)}`;
  }

  if (window.ethereum) {
    window.ethereum.on("accountsChanged", function (accounts) {
      userAccount = accounts[0] || null;
      const connectBtn = document.getElementById("connect-btn");
      connectBtn.textContent = userAccount ? formatAddress(userAccount) : "ðŸ”— Connect Wallet";
      if (userAccount) {
        setupContracts().then(() => {
          loadShopNFTs();
          loadUserNFTs();
          loadUserListings();
          updateStatus("Account changed", "success");
        });
      } else {
        updateStatus("Wallet disconnected", "info");
      }
    });
    window.ethereum.on("chainChanged", function (chainId) {
      updateStatus("Network changed - reconnecting...", "info");
      setupContracts().then(() => {
        loadShopNFTs();
        loadUserNFTs();
        loadUserListings();
        updateStatus("Network changed", "success");
      });
    });
    nftfanShop.events
      .ListingCancelled({})
      .on("data", async (event) => {
        updateStatus(`Listing for NFT #${event.returnValues.tokenId} cancelled`, "success");
        await loadShopNFTs();
        await loadUserNFTs();
        await loadUserListings();
      })
      .on("error", (error) => {
        console.error("ListingCancelled event error:", error);
        updateStatus("Failed to process listing cancellation event", "error");
      });
  }

window.addEventListener("DOMContentLoaded", async () => {
  try {
    console.log('Initializing app...');
    updateStatus("Initializing...", "info");
    await setupContracts();
    console.log('Contracts set up successfully');
    await loadShopNFTs();
    console.log('Shop NFTs loaded');
    await loadUserListings();
    console.log('User listings loaded');
    await loadUserNFTs();
    console.log('User NFTs loaded');
    updateStatus("Ready", "success");
    // Bind tab button events
    const tabButtons = {
      'listings': document.getElementById('tab-listings'),
      'shop': document.getElementById('tab-shop'),
      'mynfts': document.getElementById('tab-mynfts')
    };
    Object.keys(tabButtons).forEach(tab => {
      if (tabButtons[tab]) {
        tabButtons[tab].addEventListener('click', () => {
          console.log(`Tab button clicked: ${tab}`);
          showTab(tab);
        });
      } else {
        console.error(`Tab button not found: tab-${tab}`);
      }
    });
  } catch (error) {
    console.error("Initialization failed:", error);
    logError(error, "Initialization");
    updateStatus("Initialization failed: " + error.message, "error");
    showError("shop-error", "Failed to initialize the application. Please refresh.");
  }
});
  
function showTab(tab) {
  try {
    console.log(`Switching to tab: ${tab}`);
    const tabContents = ['shop', 'mynfts', 'listings'];
    tabContents.forEach((t) => {
      const content = document.getElementById(`tab-content-${t}`);
      if (content) {
        content.style.display = 'none';
      } else {
        console.error(`Tab content element not found: tab-content-${t}`);
      }
    });
    const selectedContent = document.getElementById(`tab-content-${tab}`);
    if (selectedContent) {
      selectedContent.style.display = 'block';
    } else {
      throw new Error(`Invalid tab content ID: tab-content-${tab}`);
    }
    tabContents.forEach((t) => {
      const btn = document.getElementById(`tab-${t}`);
      if (btn) {
        btn.classList.remove('active');
      } else {
        console.error(`Tab button element not found: tab-${t}`);
      }
    });
    const selectedBtn = document.getElementById(`tab-${tab}`);
    if (selectedBtn) {
      selectedBtn.classList.add('active');
    } else {
      throw new Error(`Invalid tab button ID: tab-${tab}`);
    }
    if (tab === 'shop') {
      loadShopNFTs().catch((e) => {
        console.error('loadShopNFTs failed in showTab:', e);
        updateStatus('Failed to load shop NFTs', 'error');
      });
    } else if (tab === 'mynfts') {
      loadUserNFTs().catch((e) => {
        console.error('loadUserNFTs failed in showTab:', e);
        updateStatus('Failed to load your NFTs', 'error');
      });
    } else if (tab === 'listings') {
      loadUserListings().catch((e) => {
        console.error('loadUserListings failed in showTab:', e);
        updateStatus('Failed to load user listings', 'error');
      });
    } else {
      throw new Error(`Invalid tab: ${tab}`);
    }
    console.log(`Tab switched successfully: ${tab}`);
  } catch (error) {
    console.error('showTab failed:', error);
    updateStatus(`Failed to switch to ${tab} tab: ${error.message}`, 'error');
  }
}

</script>
  <script>
    // --- Your provided full JS from the previous message is assumed to be here ---
    // ... (the full NFTFAN_SHOP ABI, and all functions, connectWallet, setupContracts, etc) ...

    // --- Circle UI logic for SHOP and MY NFTs ---
    let shopNFTs = [], shopIdx = 0, shopNFTsMeta = [];
    let myNFTs = [], myIdx = 0, myNFTsMeta = [];

    // Swap UI for SHOP
    async function showShopNFT(idxChange = 0) {
      if (shopNFTs.length === 0) {
        document.getElementById('shopCircle').innerHTML = '';
        document.getElementById('shopPrice').innerHTML = '';
        return;
      }
      shopIdx = (shopIdx + idxChange + shopNFTs.length) % shopNFTs.length;
      const nft = shopNFTs[shopIdx];
      const meta = shopNFTsMeta[shopIdx] || {};
      document.getElementById('shopCircle').innerHTML = `<img src="${meta.image || 'https://via.placeholder.com/300x300?text=NFT'}" alt="${meta.name || 'NFT'}">`;
      document.getElementById('shopPrice').innerText = nft.price ? (web3.utils.fromWei(nft.price, "ether") + " MATIC") : '';
    }

    // Swap UI for MY NFTs
    async function showMyNFT(idxChange = 0) {
      if (myNFTs.length === 0) {
        document.getElementById('myCircle').innerHTML = '';
        return;
      }
      myIdx = (myIdx + idxChange + myNFTs.length) % myNFTs.length;
      const nft = myNFTs[myIdx];
      const meta = myNFTsMeta[myIdx] || {};
      document.getElementById('myCircle').innerHTML = `<img src="${meta.image || 'https://via.placeholder.com/300x300?text=NFT'}" alt="${meta.name || 'NFT'}">`;
      document.getElementById('mySellPriceInput').value = '';
    }

    // Fetch SHOP NFTs and display in circle
    async function fetchShopCircleNFTs() {
      if (!nftfanShop) await setupContracts();
      const result = await nftfanShop.methods.getShopNFTs().call();
      shopNFTs = [];
      shopNFTsMeta = [];
      for (let i = 0; i < result.ids.length; i++) {
        if (result.isForSale[i] && Number(result.shopAmounts[i]) > 0) {
          shopNFTs.push({ id: result.ids[i], price: result.prices[i], uri: result.uris[i] });
          let meta = await fetchOpenSeaMeta(result.uris[i]);
          shopNFTsMeta.push(meta || {});
        }
      }
      shopIdx = 0;
      showShopNFT(0);
    }

    // Fetch MY NFTs and display in circle
    async function fetchMyCircleNFTs() {
      if (!userAccount) return;
      if (!nftfanShop) await setupContracts();
      const tokens = await nftfanShop.methods.tokensOfOwner(userAccount).call();
      myNFTs = [];
      myNFTsMeta = [];
      for (let i = 0; i < tokens.tokenIds.length; i++) {
        if (Number(tokens.amounts[i]) > 0) {
          const id = tokens.tokenIds[i];
          let meta = await nftfanShop.methods.nftInfo(id).call();
          let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
          myNFTs.push({ id, meta });
          myNFTsMeta.push(metaJson || {});
        }
      }
      myIdx = 0;
      showMyNFT(0);
    }

    // SHOP swipe events
    document.getElementById('shopLeftBtn').onclick = () => showShopNFT(-1);
    document.getElementById('shopRightBtn').onclick = () => showShopNFT(1);

    // MY NFT swipe events
    document.getElementById('myLeftBtn').onclick = () => showMyNFT(-1);
    document.getElementById('myRightBtn').onclick = () => showMyNFT(1);

    // Buy button for SHOP NFT
    document.getElementById('buyBtn').onclick = async function() {
      if (!userAccount) return updateStatus("Connect your wallet first!", "error");
      if (!shopNFTs[shopIdx]) return;
      const nft = shopNFTs[shopIdx];
      try {
        updateStatus("Processing purchase...", "info");
        await nftfanShop.methods.buyNFT(nft.id, 1).send({
          from: userAccount,
          value: nft.price
        });
        updateStatus("NFT bought successfully!", "success");
        await fetchShopCircleNFTs();
        await fetchMyCircleNFTs();
      } catch (e) {
        updateStatus("Buy failed: " + (e?.message || e), "error");
      }
    };

    // Sell button for MY NFT
    document.getElementById('sellBtn').onclick = function() {
      if (!userAccount) return updateStatus("Connect your wallet first!", "error");
      if (!myNFTs[myIdx]) return;
      const nft = myNFTs[myIdx];
      // Show modal to set price/amount, prefill with 1 and price
      document.getElementById("sellModal").style.display = "flex";
      document.getElementById("sellTokenId").textContent = nft.id;
      document.getElementById("sellMaxAmount").textContent = nft.meta.currentSupply || "1";
      document.getElementById("sellAmountInput").value = "1";
      document.getElementById("sellAmountInput").max = nft.meta.currentSupply || "1";
      document.getElementById("sellPriceInput").value = "";
      document.getElementById("sellModalError").textContent = "";
      window.sellModalTokenId = nft.id;
      window.sellModalMaxAmount = nft.meta.currentSupply || 1;
    };

    // Confirm sell modal logic is in your main JS (window.confirmSellNFT etc.)

    // Connect wallet button
    document.getElementById('connect-btn').onclick = connectWallet;

    // Tab logic (show/hide tab-content)
    function showTab(tab) {
      ['shop','mynfts','listings'].forEach(t => {
        document.getElementById('tab-content-'+t).style.display = (t===tab) ? 'block' : 'none';
        document.getElementById('tab-'+t).classList.toggle('active', t===tab);
      });
      if(tab==='shop') fetchShopCircleNFTs();
      if(tab==='mynfts') fetchMyCircleNFTs();
      if(tab==='listings') loadUserListings();
    }
    document.getElementById('tab-shop').onclick = () => showTab('shop');
    document.getElementById('tab-mynfts').onclick = () => showTab('mynfts');
    document.getElementById('tab-listings').onclick = () => showTab('listings');

    // Init on DOMContentLoaded
    window.addEventListener("DOMContentLoaded", async () => {
      updateStatus("Initializing...", "info");
      await setupContracts();
      await fetchShopCircleNFTs();
      await fetchMyCircleNFTs();
      updateStatus("Ready", "success");
    });

    // Add your full contract logic, event handlers, and helper functions as before!
    // (All from your big JS code in your message.)
  </script>
</body>
</html>
