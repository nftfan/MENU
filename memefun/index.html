<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MEME.FUN</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>
  <!-- Ethers.js -->
  <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    /* ... CSS remains unchanged ... */
    :root {
      --primary: #fff;
      --accent: #ffc107;
      --accent2: #3cbfff;
      --bg: #181824;
      --surface1: #24243a;
      --surface2: #191933;
      --divider: #303047;
      --border1: #ffc107;
      --border2: #3cbfff;
      --price-bg: #232336;
      --price-bg2: #12243a;
      --price-color: #ffe082;
      --price-color2: #81f7ff;
      --green: #3ad37a;
      --green-dark: #1b8c4a;
      --red: #ff5469;
      --red-dark: #b81e2f;
      --shadow1: 0 4px 18px #0002;
      --shadow2: 0 0px 14px #00eaff14 inset;
      --radius: 20px;
      --meme-circle-size: 168px;
      --btn-w: 112px;
      --btn-h: 34px;
    }
    html, body {
      margin: 0;
      padding: 0;
      font-family: 'Inter', Arial, sans-serif;
      background: var(--bg);
      color: var(--primary);
      font-size: 12px;
      box-sizing: border-box;
      height: 100%;
      width: 100vw;
      overflow: hidden !important;
      overscroll-behavior: none;
    }
    body {
      min-height: 100vh;
      max-width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      background: var(--bg);
    }
    .header {
      width: 100vw;
      background: var(--surface1);
      color: var(--accent);
      display: flex;
      align-items: center;
      justify-content: center;
      height: 44px;
      letter-spacing: 1.1px;
      font-weight: bold;
      font-size: 13px;
      box-shadow: 0 2px 7px -2px #000b;
      border-bottom: 1.5px solid var(--divider);
      flex-shrink: 0;
      position: relative;
      z-index: 10;
      gap: 4px;
      user-select: none;
    }
    .wallet-upload-bar {
      width: 100vw;
      background: var(--surface1);
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 10px;
      padding: 6px 18px 6px 0;
      box-sizing: border-box;
      position: relative;
      z-index: 11;
      border-bottom: 1.5px solid var(--divider);
    }
    .wallet-btn, .upload-btn {
      background: var(--accent2);
      color: #fff;
      border: none;
      padding: 5px 12px 5px 10px;
      border-radius: 12px;
      font-weight: 600;
      font-size: 12px;
      cursor: pointer;
      box-shadow: 0 1px 4px #263e5b23;
      display: flex;
      align-items: center;
      gap: 5px;
      transition: background .15s;
      z-index: 20;
      outline: none;
      letter-spacing: .4px;
      min-width: 100px;
      justify-content: center;
    }
    .wallet-btn[disabled], .upload-btn[disabled] {
      opacity: 0.7;
      pointer-events: none;
    }
    .upload-btn {
      background: var(--accent);
      color: #222;
      min-width: 88px;
      margin-right: 2px;
    }
    .wallet-btn .material-icons, .upload-btn .material-icons {
      font-size: 18px;
      margin-right: 2px;
    }
    .main-area {
      flex: 1;
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      overflow: hidden;
      background: var(--bg);
      padding: 0;
    }
    .sections-wrapper {
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      padding: 0;
      margin: 0;
      gap: 0;
    }
    .section {
      width: 100vw;
      display: flex;
      flex-direction: column;
      align-items: center;
      overflow: hidden;
      position: relative;
      z-index: 1;
      padding: 0;
      margin: 0;
      box-sizing: border-box;
      min-height: 0;
      border-radius: 0;
      gap: 0.5rem;
    }
    .section-top {
      background: var(--surface1);
      border-bottom: 2.5px solid var(--border1);
      box-shadow: var(--shadow1);
      padding: 18px 0 0 0;
      margin: 0;
      align-items: center;
      min-height: 0;
    }
    .section-bottom {
      background: var(--surface2);
      border-top: 2.5px solid var(--border2);
      box-shadow: var(--shadow2);
      margin: 0;
      padding: 16px 0 0 0;
      border-radius: 0 0 0 0;
      align-items: center;
    }
    .section-title {
      font-size: 12px;
      font-weight: 700;
      margin: 0 0 6px 0;
      color: #ffd26e;
      letter-spacing: .9px;
      text-align: center;
      width: 100%;
      padding-top: 0;
      text-shadow: 0 2px 9px #2224;
      user-select: none;
    }
    .section-bottom .section-title {
      color: #65e6ff;
      margin-bottom: 6px;
      text-shadow: 0 2px 9px #0ff2;
    }
    .swipe-area {
      width: 100vw;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0;
      gap: 0;
      padding: 0;
    }
    .swipe-btn {
      background: none;
      border: none;
      color: var(--accent);
      font-size: 32px;
      cursor: pointer;
      margin: 0 10px;
      padding: 0;
      width: 38px;
      height: var(--meme-circle-size);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
      border-radius: 50%;
      transition: background 0.14s;
      outline: none;
      user-select: none;
    }
    .swipe-btn:active {
      background: #23233655;
    }
    .meme-circle-wrap {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      position: relative;
      min-width: var(--meme-circle-size);
    }
    .meme-circle {
      width: var(--meme-circle-size);
      height: var(--meme-circle-size);
      border-radius: 50%;
      overflow: hidden;
      background: linear-gradient(135deg, #25254a 60%, #3a354f 100%);
      box-shadow: 0 2px 18px 0 #0007, 0 2px 7px 0 #ffd96b10;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 3.5px solid var(--border1);
      position: relative;
      flex-shrink: 0;
      transition: box-shadow 0.13s, border 0.14s;
    }
    .section-bottom .meme-circle {
      background: linear-gradient(135deg, #232b40 60%, #1b304a 100%);
      border: 3.5px solid var(--border2);
    }
    .meme-circle img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      filter: brightness(0.97) contrast(1.1);
    }
    .meme-circle.shake {
      animation: shake 0.4s;
    }
    @keyframes shake {
      0% { transform: translateX(0px) rotate(0deg);}
      18% { transform: translateX(-4px) rotate(-6deg);}
      35% { transform: translateX(4px) rotate(6deg);}
      50% { transform: translateX(-2px) rotate(-3deg);}
      62% { transform: translateX(2px) rotate(3deg);}
      75% { transform: translateX(-1px) rotate(-1deg);}
      100% { transform: translateX(0px) rotate(0deg);}
    }
    .meme-price {
      margin-top: 14px;
      font-size: 15px;
      color: var(--price-color);
      font-weight: 700;
      letter-spacing: 0.3px;
      background: var(--price-bg);
      border-radius: 13px;
      box-shadow: 0 1px 5px #0004;
      border: 1.5px solid var(--border1);
      padding: 6px 20px 4px 20px;
      min-width: 80px;
      text-align: center;
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: -38px;
      pointer-events: none;
      user-select: none;
      text-shadow: 0 1px 10px #23233666;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .section-bottom .meme-price {
      border: 1.5px solid var(--border2);
      background: var(--price-bg2);
      color: var(--price-color2);
      text-shadow: 0 1px 8px #0ff2;
    }
    .buy-btn, .sell-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      border: none;
      border-radius: 17px;
      width: var(--btn-w);
      height: var(--btn-h);
      cursor: pointer;
      letter-spacing: .9px;
      outline: none;
      user-select: none;
      font-size: 15px;
      box-shadow: 0 2px 10px #0002;
      transition: background .15s, color .14s, box-shadow .15s, filter .13s;
      margin: 0 auto;
    }
    .buy-btn {
      background: var(--green);
      color: #fff;
      box-shadow: 0 2px 10px #25b95a33;
      border: 2px solid var(--green-dark);
      margin-top: 32px;
      margin-bottom: 10px;
    }
    .buy-btn:hover, .buy-btn:focus {
      background: #26d36b;
      color: #fff;
      filter: brightness(1.08);
      box-shadow: 0 2px 16px #3ad37a44;
    }
    .sell-btn {
      background: var(--red);
      color: #fff;
      box-shadow: 0 2px 10px #ff546933;
      border: 2px solid var(--red-dark);
      margin-top: 18px;
      margin-bottom: 10px;
    }
    .sell-btn:hover, .sell-btn:focus,
    .section-bottom .sell-btn:hover {
      background: #ff3747;
      color: #fff;
      filter: brightness(1.05);
      box-shadow: 0 2px 16px #ff546944;
    }
    .section-bottom .sell-btn {
      background: var(--red);
      color: #fff;
      box-shadow: 0 2px 10px #ff546933;
      border: 2px solid var(--red-dark);
      margin-top: 14px;
      margin-bottom: 10px;
    }
    .sell-price-row {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 18px 0 0 0;
      gap: 6px;
    }
    .sell-price-label {
      font-size: 12px;
      color: #65e6ff;
      margin-right: 2px;
      font-weight: 700;
      letter-spacing: 0.45px;
    }
    .sell-price-input {
      width: 54px;
      padding: 4px 10px;
      border: 1.5px solid #3cbfff;
      border-radius: 13px;
      font-size: 12px;
      outline: none;
      background: #181824;
      color: #81f7ff;
      text-align: right;
      transition: border 0.14s;
      box-shadow: 0 1px 6px #00eaff10 inset;
      font-weight: 600;
    }
    .sell-price-input:focus {
      border: 1.5px solid #81f7ff;
      background: #101020;
    }
    .sell-price-coin {
      color: #65e6ff;
      font-size: 18px;
      margin-left: 2px;
      vertical-align: middle;
      filter: drop-shadow(0 0 4px #3cbfff36);
    }
    #uploadInput {
      display: none;
    }
    .modal-bg {
      display: none;
      position: fixed;
      z-index: 200;
      left: 0; top: 0; right: 0; bottom: 0;
      background: #000a;
      align-items: center;
      justify-content: center;
    }
    .modal-bg.active {
      display: flex;
    }
    .modal {
      background: var(--surface1);
      border-radius: 18px;
      padding: 28px 18px 18px 18px;
      box-shadow: 0 2px 20px #000a;
      min-width: 220px;
      max-width: 94vw;
      color: #ffd26e;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      position: relative;
    }
    .modal label {
      color: var(--primary);
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 5px;
      letter-spacing: 0.1px;
      display: block;
      text-align: left;
      width: 100%;
    }
    .modal input[type="number"],
    .modal input[type="text"] {
      width: 180px;
      padding: 6px 12px;
      border: 1.5px solid var(--accent2);
      border-radius: 10px;
      font-size: 13px;
      font-weight: 600;
      background: #181824;
      color: var(--accent2);
      text-align: left;
      margin-bottom: 6px;
      transition: border 0.14s;
      box-sizing: border-box;
    }
    .modal input[type="number"]:focus,
    .modal input[type="text"]:focus {
      border: 1.5px solid var(--accent2);
      background: #101020;
      outline: none;
    }
    .modal-btn-row {
      display: flex;
      gap: 16px;
      margin-top: 10px;
      width: 100%;
      justify-content: center;
    }
    .modal-btn {
      padding: 7px 20px;
      border-radius: 12px;
      border: none;
      font-weight: 700;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 8px #0003;
      background: var(--accent2);
      color: #fff;
      transition: filter .14s;
    }
    .modal-btn:active {
      filter: brightness(0.93);
    }
    .modal-close {
      position: absolute;
      right: 12px;
      top: 8px;
      cursor: pointer;
      color: #65e6ff;
      background: none;
      border: none;
      font-size: 22px;
      z-index: 10;
    }
    .modal-error {
      color: #ff5469;
      font-size: 12px;
      margin-top: -3px;
      margin-bottom: 3px;
      font-weight: 500;
    }
    .meme-name {
      display: block;
      margin: 6px auto 0 auto;
      text-align: center;
      font-size: 14px;
      color: #ffd26e;
      font-weight: 700;
      text-shadow: 0 1px 6px #0008;
      max-width: 140px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      letter-spacing: .1px;
    }
    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      z-index: 1000;
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
    }
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 5px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--accent);
      animation: spin 1s ease-in-out infinite;
    }
    .loading-text {
      color: white;
      margin-top: 15px;
      font-weight: bold;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .demo-mode-badge {
      position: fixed;
      bottom: 10px;
      right: 10px;
      background: rgba(0,0,0,0.5);
      color: #fff;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 10px;
      z-index: 100;
    }
    @media (max-width: 600px) {
      :root {
        --meme-circle-size: 120px;
        --btn-w: 90px;
        --btn-h: 28px;
      }
      .meme-price { font-size: 11px; padding: 3px 10px 3px 10px; bottom: -23px;}
      .swipe-btn { width: 28px; font-size: 22px; }
      .buy-btn, .sell-btn { font-size: 11px;}
      .section-title { font-size: 10px;}
      .sell-price-input { width: 33px; font-size: 9px;}
      .sell-price-row { margin-top: 14px;}
      .buy-btn { margin-top: 24px; }
      .sell-btn { margin-top: 12px; }
      .section-bottom .sell-btn { margin-top: 10px; }
      .wallet-upload-bar {
        padding-right: 6px;
        gap: 6px;
      }
      .wallet-btn, .upload-btn {
        font-size: 10px;
        min-width: 70px;
        padding: 4px 8px 4px 8px;
      }
      .upload-btn {
        min-width: 65px;
      }
    }
    @media (max-width: 400px) {
      :root {
        --meme-circle-size: 90px;
        --btn-w: 62px;
        --btn-h: 18px;
      }
      .meme-price { font-size: 8px; padding: 2px 5px 2px 5px; bottom: -15px;}
      .buy-btn, .sell-btn { font-size: 8px;}
      .sell-price-input { width: 22px; font-size: 8px;}
      .swipe-btn { width: 18px; font-size: 15px; }
      .section-title { font-size: 8px;}
      .sell-price-row { margin-top: 8px;}
      .buy-btn { margin-top: 13px; }
      .sell-btn { margin-top: 7px; }
      .section-bottom .sell-btn { margin-top: 7px; }
      .wallet-upload-bar {
        padding-right: 2px;
        gap: 3px;
      }
    }
  </style>
</head>
<body>
  <div class="header">
    <span class="material-icons" aria-label="emoji">emoji_emotions</span>
    MEME.FUN
  </div>
  <div class="wallet-upload-bar">
    <button class="upload-btn" id="uploadBtn">
      <span class="material-icons">cloud_upload</span>
      Upload Meme
    </button>
    <input type="file" accept="image/*" id="uploadInput" />
    <button class="wallet-btn" id="connectWalletBtn">
      <span class="material-icons">account_balance_wallet</span>
      Connect Wallet
    </button>
  </div>
  <div class="main-area">
    <div class="sections-wrapper">
      <!-- Top Section: MEMES -->
      <div class="section section-top">
        <div class="section-title">MEMES</div>
        <div class="swipe-area">
          <button class="swipe-btn" id="memeLeftBtn" tabindex="0"><span class="material-icons">chevron_left</span></button>
          <div class="meme-circle-wrap">
            <div class="meme-circle" id="memeCircle"></div>
            <span class="meme-name" id="memeName"></span>
            <div class="meme-price" id="memePrice"></div>
          </div>
          <button class="swipe-btn" id="memeRightBtn" tabindex="0"><span class="material-icons">chevron_right</span></button>
        </div>
        <button class="buy-btn" id="buyBtn"><span class="material-icons" style="font-size:16px;margin-right:6px;">shopping_cart</span>Buy</button>
      </div>

      <!-- Bottom Section: MY MEMES (uploaded AND bought)-->
      <div class="section section-bottom">
        <div class="section-title">MY MEMES</div>
        <div class="swipe-area">
          <button class="swipe-btn" id="myMemeLeftBtn" tabindex="0"><span class="material-icons">chevron_left</span></button>
          <div class="meme-circle-wrap">
            <div class="meme-circle" id="myMemeCircle"></div>
            <span class="meme-name" id="myMemeName"></span>
          </div>
          <button class="swipe-btn" id="myMemeRightBtn" tabindex="0"><span class="material-icons">chevron_right</span></button>
        </div>
        <div class="sell-price-row">
          <span class="sell-price-label">Set Price:</span>
          <input class="sell-price-input" id="sellPriceInput" type="number" min="0" step="0.01" value="0.02">
          <span class="material-icons sell-price-coin">monetization_on</span>
        </div>
        <button class="sell-btn" id="mySellBtn"><span class="material-icons" style="font-size:16px;margin-right:6px;">sell</span>Sell</button>
      </div>
    </div>
  </div>

  <!-- Upload Meme Modal -->
  <div class="modal-bg" id="uploadModalBg">
    <div class="modal" id="uploadModal">
      <button class="modal-close" id="modalCloseBtn" title="Close">&times;</button>
      <div>
        <label for="memeNameInput">Meme Name:</label>
        <input type="text" id="memeNameInput" maxlength="40" placeholder="Enter meme name" autocomplete="off">
      </div>
      <div>
        <label for="memePriceInput">Set Price for Meme (MATIC):</label>
        <input type="number" min="0" step="0.0001" id="memePriceInput" value="0.01">
      </div>
      <div class="modal-error" id="modalError"></div>
      <div class="modal-btn-row">
        <button class="modal-btn" id="submitMemeBtn">Submit Meme</button>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-spinner"></div>
    <div class="loading-text" id="loadingText">Processing transaction...</div>
  </div>
  
  <script>
    // ---- CONFIG SECTION ----
    const CONTRACT_ADDRESS = "0x21373d81452b6bf9CA7750c8FE7FC3f026cDa65b";
    const CONTRACT_ABI = [
      // --- Only include necessary ABI entries for web3 features ---
      "function mint(address to, string memory uri_) external payable returns (uint256)",
      "function listMeme(uint256 tokenId, uint256 amount, uint256 price) external",
      "function unlistMeme(uint256 tokenId) external",
      "function buyMeme(uint256 tokenId, uint256 amount) external payable",
      "function getListing(uint256 tokenId) external view returns (uint256 price, uint256 amount, address seller)",
      "function creator(uint256 tokenId) external view returns (address)",
      "function balanceOf(address account, uint256 id) external view returns (uint256)",
      "function isApprovedForAll(address account, address operator) external view returns (bool)",
      "function setApprovalForAll(address operator, bool approved) external",
      "function uri(uint256 id) external view returns (string memory)",
      "function nextTokenId() external view returns (uint256)"
    ];
    const MINT_FEE = "0.1"; // MATIC

    // Polygon network parameters (mainnet)
    const polygonChainId = '0x89';
    const polygonChainData = {
      chainId: polygonChainId,
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com/'],
      blockExplorerUrls: ['https://polygonscan.com/']
    };

    // ---- FIREBASE SETUP ----
    const firebaseConfig = {
      apiKey: "AIzaSyCYSOx_niWPHLDisCjAQzK8UJSe5TfwtLI",
      authDomain: "nftfanactive.firebaseapp.com",
      databaseURL: "https://nftfanactive-default-rtdb.firebaseio.com",
      projectId: "nftfanactive",
      storageBucket: "nftfanactive.appspot.com",
      messagingSenderId: "311309982791",
      appId: "1:311309982791:web:3e55bba6b78feb57ea6562",
      measurementId: "G-3TRDL9749N"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // Cloudinary config
    const CLOUDINARY_UPLOAD_PRESET = "unsigned_nft";
    const CLOUDINARY_CLOUD_NAME = "dvndw130d";
    const CLOUDINARY_UPLOAD_URL = `https://api.cloudinary.com/v1_1/${CLOUDINARY_CLOUD_NAME}/image/upload`;

    // ---- APP STATE ----
    let provider, signer, contract, currentAccount = null;
    let memes = [];
    let memeIdx = 0;
    let myMemes = [];
    let myMemeIdx = 0;

    // ---- UI Elements ----
    const connectWalletBtn = document.getElementById('connectWalletBtn');
    const loadingOverlay = document.getElementById('loadingOverlay');
    const loadingText = document.getElementById('loadingText');
    const uploadBtn = document.getElementById('uploadBtn');
    const uploadInput = document.getElementById('uploadInput');
    const uploadModalBg = document.getElementById('uploadModalBg');
    const modalCloseBtn = document.getElementById('modalCloseBtn');
    const memePriceInput = document.getElementById('memePriceInput');
    const memeNameInput = document.getElementById('memeNameInput');
    const submitMemeBtn = document.getElementById('submitMemeBtn');
    const modalError = document.getElementById('modalError');
    const sellPriceInput = document.getElementById("sellPriceInput");
    const mySellBtn = document.getElementById("mySellBtn");

    // ---- HELPERS ----
    function showLoading(message = 'Processing transaction...') {
      loadingText.textContent = message;
      loadingOverlay.style.display = 'flex';
    }

    function hideLoading() {
      loadingOverlay.style.display = 'none';
    }

    async function switchToPolygon() {
      if (!window.ethereum) return false;
      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: polygonChainId }]
        });
        return true;
      } catch (switchError) {
        // Add chain if not present
        if (switchError.code === 4902 || 
            (switchError.data && switchError.data.originalError && switchError.data.originalError.code === 4902)) {
          try {
            await window.ethereum.request({
              method: 'wallet_addEthereumChain',
              params: [polygonChainData]
            });
            return true;
          } catch (addError) {
            console.error('Error adding Polygon network:', addError);
            return false;
          }
        } else {
          console.error('Error switching to Polygon:', switchError);
          return false;
        }
      }
    }

    // ---- WALLET CONNECTION ----
    async function connectWallet() {
      if (typeof window.ethereum === 'undefined') {
        alert("MetaMask not detected. Please install MetaMask extension to continue.");
        return;
      }
      connectWalletBtn.disabled = true;
      connectWalletBtn.innerHTML = '<span class="material-icons">hourglass_top</span>Connecting...';
      try {
        const switched = await switchToPolygon();
        if (!switched) throw new Error("Failed to switch to Polygon network");
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        currentAccount = await signer.getAddress();
        contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

        // Show address in button
        const displayAddress = currentAccount.slice(0, 6) + '...' + currentAccount.slice(-4);
        connectWalletBtn.innerHTML = '<span class="material-icons">check_circle</span>' + displayAddress;
        connectWalletBtn.disabled = true;

        // Load user's memes after connecting wallet
        await listenAndDisplayMyMemes(currentAccount, updateMyMemesUI);
      } catch (error) {
        connectWalletBtn.innerHTML = '<span class="material-icons">account_balance_wallet</span>Connect Wallet';
        connectWalletBtn.disabled = false;
        if (error.code !== 4001) {
          console.error("Wallet connection error:", error);
          alert("Failed to connect wallet: " + (error.message || "Unknown error"));
        }
      }
    }

    connectWalletBtn.addEventListener('click', connectWallet);

    // Handle account/network changes
    if (window.ethereum) {
      window.ethereum.on('accountsChanged', async function (accounts) {
        if (!accounts.length) {
          currentAccount = null;
          connectWalletBtn.innerHTML = '<span class="material-icons">account_balance_wallet</span>Connect Wallet';
          connectWalletBtn.disabled = false;
          myMemes = [];
          myMemeIdx = 0;
          updateMyMemeCircle(false);
        } else {
          currentAccount = accounts[0];
          connectWalletBtn.innerHTML = '<span class="material-icons">check_circle</span>' + 
            currentAccount.slice(0, 6) + '...' + currentAccount.slice(-4);
          connectWalletBtn.disabled = true;
          await listenAndDisplayMyMemes(currentAccount, updateMyMemesUI);
        }
      });

      window.ethereum.on('chainChanged', async (chainId) => {
        if (chainId !== polygonChainId) {
          alert("Please switch to the Polygon network to use this app");
          connectWalletBtn.disabled = false;
          connectWalletBtn.innerHTML = '<span class="material-icons">account_balance_wallet</span>Connect Wallet';
        } else if (currentAccount) {
          provider = new ethers.providers.Web3Provider(window.ethereum, "any");
          signer = provider.getSigner();
          contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        }
      });
    }

    // ---- FIREBASE FUNCTIONS ----
    function saveMemeToFirebase({ url, price, name, owner, tokenId, timestamp = Date.now() }) {
      const memeRef = db.ref('memes').push();
      return memeRef.set({
        url,
        price,
        name,
        owner,
        tokenId,
        originalUploader: owner,
        timestamp
      });
    }

    function listenAndDisplayMemes(updateCallback) {
      db.ref('memes').orderByChild('timestamp').on('value', snapshot => {
        const memeArr = [];
        snapshot.forEach(child => {
          memeArr.push({ ...child.val(), key: child.key });
        });
        memeArr.reverse();
        updateCallback(memeArr);
      }, error => {
        console.error("Firebase error:", error);
        alert("Failed to load memes. Please check your connection and try again.");
      });
    }

    function listenAndDisplayMyMemes(owner, updateCallback) {
      db.ref('memes').orderByChild('owner').equalTo(owner).on('value', snapshot => {
        const memeArr = [];
        snapshot.forEach(child => {
          memeArr.push({ ...child.val(), key: child.key });
        });
        memeArr.reverse();
        updateCallback(memeArr);
      }, error => {
        console.error("Firebase error:", error);
        alert("Failed to load your memes. Please check your connection and try again.");
      });
    }

    // ---- NFT MINT AND LIST ----
    let selectedFile = null;

    function openModal() {
      uploadModalBg.classList.add('active');
      modalError.innerText = "";
      memePriceInput.value = "0.01";
      memeNameInput.value = "";
      memeNameInput.focus();
    }

    function closeModal() {
      uploadModalBg.classList.remove('active');
      selectedFile = null;
    }

    modalCloseBtn.onclick = closeModal;
    uploadModalBg.onclick = (e) => { if (e.target === uploadModalBg) closeModal(); }

    uploadBtn.addEventListener('click', () => {
      if (!currentAccount) {
        alert("Please connect your wallet before uploading a meme.");
        return;
      }
      uploadInput.value = "";
      uploadInput.click();
    });

    uploadInput.addEventListener('change', async (event) => {
      const file = event.target.files && event.target.files[0];
      if (!file) return;
      if (!file.type.match('image.*')) {
        alert("Please select an image file.");
        return;
      }
      if (file.size > 5 * 1024 * 1024) {
        alert("File size must be less than 5MB.");
        return;
      }
      selectedFile = file;
      openModal();
    });

    submitMemeBtn.onclick = async function() {
      let price = memePriceInput.value.trim();
      let name = memeNameInput.value.trim();

      if (!selectedFile) {
        modalError.innerText = "No file selected.";
        return;
      }
      if (!name) {
        modalError.innerText = "Please enter a name for your meme.";
        memeNameInput.focus();
        return;
      }
      if (!price || isNaN(price) || Number(price) <= 0) {
        modalError.innerText = "Enter a valid price (MATIC).";
        memePriceInput.focus();
        return;
      }
      modalError.innerText = "";
      submitMemeBtn.disabled = true;
      submitMemeBtn.innerText = "Uploading...";
      try {
        showLoading("Uploading image...");
        const formData = new FormData();
        formData.append('file', selectedFile);
        formData.append('upload_preset', CLOUDINARY_UPLOAD_PRESET);
        const res = await fetch(CLOUDINARY_UPLOAD_URL, { method: 'POST', body: formData });
        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`Upload failed: ${res.status} ${errorText}`);
        }
        const data = await res.json();
        if (data.secure_url) {
          await mintAndListNFT({ url: data.secure_url, price, name });
          closeModal();
        } else {
          throw new Error("No secure URL received from image upload");
        }
      } catch (err) {
        hideLoading();
        modalError.innerText = "Upload failed: " + (err.message || "Unknown error");
        console.error("Upload error:", err);
      }
      submitMemeBtn.disabled = false;
      submitMemeBtn.innerText = "Submit Meme";
    };

    async function mintAndListNFT({ url, price, name }) {
      showLoading("Minting your NFT...");
      try {
        const mintFeeWei = ethers.utils.parseEther(MINT_FEE);
        const tx = await contract.mint(currentAccount, url, { value: mintFeeWei });
        const receipt = await tx.wait();
        // Find the Minted event and extract tokenId
        let tokenId = null;
        for (const log of receipt.logs) {
          try {
            const parsed = contract.interface.parseLog(log);
            if (parsed.name === "Minted") {
              tokenId = parsed.args.tokenId.toString();
              break;
            }
          } catch (e) { /* not the event */ }
        }
        if (!tokenId) throw new Error("Unable to fetch minted tokenId");
        showLoading("Listing your meme for sale...");
        const priceWei = ethers.utils.parseEther(price.toString());
        await contract.listMeme(tokenId, 1, priceWei);
        await saveMemeToFirebase({
          url,
          price: `${Number(price)} MATIC`,
          name,
          owner: currentAccount,
          tokenId: tokenId
        });
        hideLoading();
        alert("Success! Your meme has been minted and listed for sale.");
      } catch (error) {
        hideLoading();
        console.error("Mint and list error:", error);
        alert("Failed to mint and list your NFT: " + (error.message || error));
        throw error;
      }
    }

    // ---- CAROUSEL & UI ----
    function shakeMeme(circleId) {
      const el = document.getElementById(circleId);
      if (!el) return;
      el.classList.remove("shake");
      void el.offsetWidth;
      el.classList.add("shake");
    }

    function updateMemeCircle(shake=true) {
      const meme = memes[memeIdx];
      const memeCircle = document.getElementById("memeCircle");
      const memePrice = document.getElementById("memePrice");
      const memeName = document.getElementById("memeName");
      if (!meme) {
        memeCircle.innerHTML = `<div style="color:#888;text-align:center;">No memes yet.<br>Upload one!</div>`;
        memePrice.innerText = "";
        memeName.innerText = "";
        return;
      }
      memeCircle.innerHTML = `<img src="${meme.url}" alt="Meme">`;
      memePrice.innerText = meme.price;
      memeName.innerText = meme.name || "";
      if (shake) shakeMeme("memeCircle");
    }

    function updateMyMemeCircle(shake=true) {
      const meme = myMemes[myMemeIdx];
      const memeCircle = document.getElementById("myMemeCircle");
      const memeName = document.getElementById("myMemeName");
      if (!meme) {
        memeCircle.innerHTML = `<div style="color:#888;text-align:center;">No memes yet.<br>Upload or Buy one!</div>`;
        memeName.innerText = "";
        return;
      }
      memeCircle.innerHTML = `<img src="${meme.url}" alt="My Meme">`;
      memeName.innerText = meme.name || "";
      if (shake) shakeMeme("myMemeCircle");
      let priceText = meme.price || "0.02 MATIC";
      let priceNum = parseFloat(priceText);
      if (isNaN(priceNum)) priceNum = 0.02;
      sellPriceInput.value = priceNum;
    }

    document.getElementById("memeLeftBtn").onclick = function() {
      if (memes.length === 0) return;
      memeIdx = (memeIdx - 1 + memes.length) % memes.length;
      updateMemeCircle();
    };
    document.getElementById("memeRightBtn").onclick = function() {
      if (memes.length === 0) return;
      memeIdx = (memeIdx + 1) % memes.length;
      updateMemeCircle();
    };
    document.getElementById("myMemeLeftBtn").onclick = function() {
      if (myMemes.length === 0) return;
      myMemeIdx = (myMemeIdx - 1 + myMemes.length) % myMemes.length;
      updateMyMemeCircle();
    };
    document.getElementById("myMemeRightBtn").onclick = function() {
      if (myMemes.length === 0) return;
      myMemeIdx = (myMemeIdx + 1) % myMemes.length;
      updateMyMemeCircle();
    };

    // ---- SELL LOGIC ----
    sellPriceInput.addEventListener('input', function(){
      if(Number(sellPriceInput.value) < 0){
        sellPriceInput.value = "0";
      }
    });

    mySellBtn.onclick = async function() {
      if (!currentAccount) {
        alert("Please connect your wallet first.");
        return;
      }
      const meme = myMemes[myMemeIdx];
      if (!meme || !meme.key || !meme.tokenId) {
        alert("No meme selected or meme data is incomplete.");
        return;
      }
      const newPrice = sellPriceInput.value;
      if (!newPrice || isNaN(newPrice) || Number(newPrice) <= 0) {
        alert("Please enter a valid price greater than 0.");
        return;
      }
      try {
        showLoading("Updating listing...");
        // Check if user owns the meme token
        const bal = await contract.balanceOf(currentAccount, meme.tokenId);
        if (bal.eq(0)) throw new Error("You don't own this meme anymore");
        // Check if approval is set
        const isApproved = await contract.isApprovedForAll(currentAccount, CONTRACT_ADDRESS);
        if (!isApproved) {
          showLoading("Approving marketplace...");
          const approveTx = await contract.setApprovalForAll(CONTRACT_ADDRESS, true);
          await approveTx.wait();
        }
        // List the meme for sale
        const priceWei = ethers.utils.parseEther(newPrice.toString());
        await contract.listMeme(meme.tokenId, 1, priceWei);
        await db.ref('memes/' + meme.key).update({ price: `${Number(newPrice)} MATIC` });
        myMemes[myMemeIdx].price = `${Number(newPrice)} MATIC`;
        updateMyMemeCircle(false);
        hideLoading();
        alert("Your meme has been listed for sale!");
      } catch (e) {
        hideLoading();
        console.error("Listing error:", e);
        alert("Failed to list meme: " + (e.message || "Unknown error"));
      }
    };

    // ---- BUY LOGIC ----
    document.getElementById('buyBtn').onclick = async function() {
      if (!currentAccount) {
        alert("Please connect your wallet first.");
        return;
      }
      const meme = memes[memeIdx];
      if (!meme || !meme.key || !meme.tokenId) {
        alert("No meme selected or meme data is incomplete.");
        return;
      }
      if (meme.owner === currentAccount) {
        alert("You already own this meme!");
        return;
      }
      try {
        showLoading("Buying meme...");
        // Get listing from contract
        const listing = await contract.getListing(meme.tokenId);
        if (listing.price.eq(0) || listing.amount.lt(1)) throw new Error("This meme is not available for sale");
        const buyTx = await contract.buyMeme(meme.tokenId, 1, {
          value: listing.price
        });
        await buyTx.wait();
        await db.ref('memes/' + meme.key).update({ owner: currentAccount });
        hideLoading();
        alert("Success! You now own this meme. Check it in MY MEMES section.");
        await listenAndDisplayMyMemes(currentAccount, updateMyMemesUI);
      } catch (e) {
        hideLoading();
        console.error("Buy error:", e);
        alert("Failed to buy meme: " + (e.message || "Unknown error"));
      }
    };

    // ---- UI STATE UPDATE ----
    function updateMemesUI(firebaseMemes) {
      memes = firebaseMemes;
      memeIdx = 0;
      updateMemeCircle(false);
    }
    function updateMyMemesUI(firebaseMyMemes) {
      myMemes = firebaseMyMemes;
      myMemeIdx = 0;
      updateMyMemeCircle(false);
    }

    // Prevent default touchmove behavior to avoid page scrolling issues
    document.addEventListener('touchmove', function(e) {
      if (e.target.closest('.meme-circle') || e.target.closest('.swipe-btn')) {
        e.preventDefault();
      }
    }, { passive: false });

    // ---- APP INITIALIZE ----
    listenAndDisplayMemes(updateMemesUI);
    updateMemeCircle(false);
    updateMyMemeCircle(false);

    // Auto-connect wallet if already connected
    if (window.ethereum && window.ethereum.isConnected()) {
      window.ethereum.request({ method: 'eth_accounts' })
        .then(accounts => {
          if (accounts.length > 0) {
            connectWallet();
          }
        })
        .catch(console.error);
    }
  </script>
</body>
</html>
