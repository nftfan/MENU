<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"
  />
  <title>Snake — NFTFAN & MATIC</title>
  <style>
    :root {
      --bg: #0b0f15;
      --panel: #121823;
      --panel-2: #0f1420;
      --accent: #6cf0ff;
      --accent-2: #8aff6c;
      --danger: #ff5c7a;
      --text: #e7f1ff;
      --muted: #8fa0b8;
      --btn: #1a2232;
      --btn-pressed: #101726;
      --grid: #182033;
      --snake: #4fd4ff;
      --snake-head: #9df0ff;
      --power-glow: rgba(140, 255, 108, 0.45);
    }

    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(1200px 700px at 50% -10%, #172035 0%, var(--bg) 65%);
      color: var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji", "Segoe UI Emoji";
      -webkit-tap-highlight-color: transparent;
    }

    .app {
      min-height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 16px;
      padding-bottom: calc(16px + env(safe-area-inset-bottom, 0px));
      gap: 14px;
    }

    .title {
      margin-top: 2px;
      font-weight: 700;
      letter-spacing: 0.5px;
      font-size: 20px;
      color: var(--text);
      text-shadow: 0 1px 0 rgba(0,0,0,0.25);
    }

    .hud {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      align-items: center;
      width: 100%;
      max-width: 560px;
      gap: 8px;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      border: 1px solid #1d2740;
      border-radius: 12px;
      padding: 8px 12px;
      min-height: 40px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.05);
      color: var(--text);
    }
    .badge img {
      width: 20px; height: 20px; object-fit: contain; image-rendering: pixelated;
    }
    .badge .label {
      font-weight: 600;
      font-size: 13px;
      color: var(--muted);
    }
    .badge .value {
      font-weight: 800;
      font-size: 16px;
      letter-spacing: 0.3px;
    }

    .controls-top {
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .btn {
      background: var(--btn);
      color: var(--text);
      border: 1px solid #1d2740;
      border-radius: 12px;
      height: 40px;
      padding: 0 12px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      letter-spacing: 0.3px;
      cursor: pointer;
      user-select: none;
      touch-action: manipulation;
      box-shadow: 0 6px 20px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.05);
    }
    .btn:active { background: var(--btn-pressed); transform: translateY(1px); }

    .game-wrap {
      width: 100%;
      max-width: 560px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .canvas-wrap {
      position: relative;
      width: 100%;
      /* Maintain a square via padding-top trick for perfect mobile scaling */
      padding-top: 100%;
      background: linear-gradient(180deg, #0f1524 0%, #0c1220 100%);
      border: 1px solid #1d2740;
      border-radius: 16px;
      box-shadow:
        0 16px 40px rgba(0,0,0,0.45),
        inset 0 0 0 1px rgba(255,255,255,0.03),
        inset 0 8px 30px rgba(108,240,255,0.04);
      overflow: hidden;
    }

    canvas#game {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(2px);
    }
    .overlay.visible { display: flex; }

    .card {
      background: linear-gradient(180deg, #121a2b 0%, #0e1626 100%);
      border: 1px solid #223052;
      border-radius: 14px;
      padding: 16px;
      min-width: 75%;
      max-width: 92%;
      text-align: center;
      color: var(--text);
      box-shadow: 0 10px 35px rgba(0,0,0,0.4);
    }
    .card h2 {
      margin: 4px 0 10px;
      font-size: 18px;
    }
    .card p {
      margin: 4px 0;
      color: var(--muted);
      font-size: 14px;
      line-height: 1.3;
    }
    .card .actions {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .dpad {
      width: 100%;
      max-width: 560px;
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: auto auto auto;
      gap: 10px;
      user-select: none;
      touch-action: manipulation;
    }
    .dpad .spacer { visibility: hidden; }
    .dpad .dir-btn {
      background: linear-gradient(180deg, var(--panel) 0%, var(--panel-2) 100%);
      border: 1px solid #1d2740;
      border-radius: 14px;
      height: 64px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 800;
      color: var(--text);
      box-shadow: 0 10px 35px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.05);
      cursor: pointer;
    }
    .dpad .dir-btn:active { transform: translateY(1px); background: #141c2c; }

    .arrow {
      width: 0;
      height: 0;
      border-style: solid;
    }
    .arrow.up   { border-width: 0 14px 18px 14px; border-color: transparent transparent var(--accent) transparent; }
    .arrow.down { border-width: 18px 14px 0 14px; border-color: var(--accent) transparent transparent transparent; }
    .arrow.left { border-width: 14px 18px 14px 0; border-color: transparent var(--accent) transparent transparent; }
    .arrow.right{ border-width: 14px 0 14px 18px; border-color: transparent transparent transparent var(--accent); }

    .legend {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
      margin-top: 4px;
    }

    .power-indicator {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: rgba(138, 255, 108, 0.08);
      border: 1px solid rgba(138,255,108,0.3);
      border-radius: 12px;
      box-shadow: 0 0 0 6px var(--power-glow);
      animation: pulse 1.4s infinite ease-in-out;
    }
    .power-indicator img { width: 18px; height: 18px; }
    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 0 6px var(--power-glow); }
      50% { box-shadow: 0 0 0 10px rgba(140,255,108,0.25); }
    }

    @media (min-width: 480px) {
      .dpad .dir-btn { height: 74px; }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="title">Snake — NFTFAN & MATIC</div>

    <div class="hud">
      <div class="badge" id="badge-nftfan" aria-live="polite">
        <img src="https://i.imgur.com/ODP45iQ.png" alt="Token" />
        <div>
          <div class="label">NFTFAN</div>
          <div class="value" id="nftfan">0</div>
        </div>
      </div>

      <div class="controls-top">
        <button class="btn" id="btn-pause" aria-pressed="false">Pause</button>
        <button class="btn" id="btn-restart">Restart</button>
      </div>

      <div class="badge" id="badge-matic" aria-live="polite" style="justify-self: end;">
        <img src="https://i.imgur.com/RwdMFUB.png" alt="Power" />
        <div>
          <div class="label">MATIC</div>
          <div class="value" id="matic">0</div>
        </div>
      </div>
    </div>

    <div class="game-wrap">
      <div class="canvas-wrap" id="canvas-wrap" aria-label="Snake game area">
        <canvas id="game"></canvas>

        <div class="overlay" id="overlay">
          <div class="card">
            <h2 id="overlay-title">Paused</h2>
            <p id="overlay-sub">Tap Resume to continue</p>
            <div class="actions">
              <button class="btn" id="btn-resume">Resume</button>
              <button class="btn" id="btn-restart-2">Restart</button>
            </div>
          </div>
        </div>
      </div>

      <div id="power-active" class="legend" aria-live="polite" style="min-height: 28px;"></div>

      <div class="dpad" aria-label="Directional controls">
        <div class="spacer"></div>
        <button class="dir-btn" id="btn-up" aria-label="Move Up"><div class="arrow up"></div></button>
        <div class="spacer"></div>

        <button class="dir-btn" id="btn-left" aria-label="Move Left"><div class="arrow left"></div></button>
        <div class="spacer"></div>
        <button class="dir-btn" id="btn-right" aria-label="Move Right"><div class="arrow right"></div></button>

        <div class="spacer"></div>
        <button class="dir-btn" id="btn-down" aria-label="Move Down"><div class="arrow down"></div></button>
        <div class="spacer"></div>
      </div>

      <div class="legend">Eat tokens to earn NFTFAN. Grab power to boost and earn MATIC.</div>
    </div>
  </div>

  <script>
    // Configuration
    const GRID_SIZE = 20;
    const START_LENGTH = 4;
    const BASE_STEP_MS = 140;
    const SPEEDUP_EVERY = 6; // foods
    const SPEEDUP_DELTA = 6; // ms faster each time
    const POWER_DURATION_MS = 10000; // 10 seconds
    const POWER_SPAWN_MIN_MS = 12000;
    const POWER_SPAWN_MAX_MS = 22000;
    const VIBRATE_OK = 'vibrate' in navigator;

    // Images
    const tokenImg = new Image();
    tokenImg.crossOrigin = 'anonymous';
    tokenImg.src = 'https://i.imgur.com/ODP45iQ.png';

    const powerImg = new Image();
    powerImg.crossOrigin = 'anonymous';
    powerImg.src = 'https://i.imgur.com/RwdMFUB.png';

    // Canvas and sizing
    const canvas = document.getElementById('game');
    const wrap = document.getElementById('canvas-wrap');
    const ctx = canvas.getContext('2d');

    // UI
    const nftfanEl = document.getElementById('nftfan');
    const maticEl = document.getElementById('matic');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlay-title');
    const overlaySub = document.getElementById('overlay-sub');
    const btnPause = document.getElementById('btn-pause');
    const btnRestart = document.getElementById('btn-restart');
    const btnResume = document.getElementById('btn-resume');
    const btnRestart2 = document.getElementById('btn-restart-2');
    const powerActiveEl = document.getElementById('power-active');

    const dpad = {
      up: document.getElementById('btn-up'),
      down: document.getElementById('btn-down'),
      left: document.getElementById('btn-left'),
      right: document.getElementById('btn-right'),
    };

    // Game state
    let tileSize = 0;
    let pixelSize = 0;

    let snake = [];
    let dir = { x: 1, y: 0 };
    let nextDir = { x: 1, y: 0 };
    let food = null;
    let power = null;

    let nftfan = 0;
    let matic = 0;
    let foodsEaten = 0;

    let running = false;
    let gameOver = false;
    let lastStep = 0;
    let stepMs = BASE_STEP_MS;

    let powerActiveUntil = 0;
    let nextPowerAt = 0;

    // Helpers
    function randInt(n) { return Math.floor(Math.random() * n); }
    function now() { return performance.now(); }

    function scheduleNextPower(fromNowMs) {
      const jitter = POWER_SPAWN_MIN_MS + Math.random() * (POWER_SPAWN_MAX_MS - POWER_SPAWN_MIN_MS);
      nextPowerAt = now() + (fromNowMs ?? jitter);
    }

    function resizeCanvas() {
      // Keep canvas square based on wrapper size
      const rect = wrap.getBoundingClientRect();
      const size = Math.min(rect.width, rect.height); // height equals width due to padding-top:100%
      const dpr = window.devicePixelRatio || 1;
      canvas.width = Math.round(size * dpr);
      canvas.height = Math.round(size * dpr);
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      pixelSize = size;
      tileSize = size / GRID_SIZE;
      draw(); // redraw after resize
    }

    function initSnake() {
      snake = [];
      const mid = Math.floor(GRID_SIZE / 2);
      for (let i = START_LENGTH - 1; i >= 0; i--) {
        snake.push({ x: mid - i, y: mid });
      }
      dir = { x: 1, y: 0 };
      nextDir = { x: 1, y: 0 };
    }

    function placeItem(exclude) {
      // exclude: Set of "x,y" strings
      while (true) {
        const x = randInt(GRID_SIZE);
        const y = randInt(GRID_SIZE);
        const key = `${x},${y}`;
        if (!exclude.has(key)) return { x, y };
      }
    }

    function occupancySet() {
      const s = new Set();
      for (const p of snake) s.add(`${p.x},${p.y}`);
      return s;
    }

    function spawnFood() {
      const ex = occupancySet();
      if (power) ex.add(`${power.x},${power.y}`);
      food = placeItem(ex);
    }

    function spawnPower() {
      const ex = occupancySet();
      if (food) ex.add(`${food.x},${food.y}`);
      power = placeItem(ex);
    }

    function isOpposite(a, b) { return a.x === -b.x && a.y === -b.y; }

    function setDirection(nx, ny) {
      const proposed = { x: nx, y: ny };
      if (isOpposite(proposed, dir)) return; // ignore instant reverse
      nextDir = proposed;
    }

    function resetGame() {
      nftfan = 0;
      matic = 0;
      foodsEaten = 0;
      powerActiveUntil = 0;
      power = null;
      scheduleNextPower(); // schedule a future spawn
      stepMs = BASE_STEP_MS;
      initSnake();
      spawnFood();
      running = true;
      gameOver = false;
      hideOverlay();
      updateHUD();
      lastStep = now();
      requestAnimationFrame(loop);
    }

    function endGame() {
      running = false;
      gameOver = true;
      showOverlay('Game Over', 'Tap Restart to play again');
      if (VIBRATE_OK) navigator.vibrate(200);
    }

    function pauseGame() {
      if (!running || gameOver) return;
      running = false;
      showOverlay('Paused', 'Tap Resume to continue');
      btnPause.setAttribute('aria-pressed', 'true');
    }

    function resumeGame() {
      if (gameOver) return;
      if (running) return;
      running = true;
      hideOverlay();
      btnPause.setAttribute('aria-pressed', 'false');
      lastStep = now();
      requestAnimationFrame(loop);
    }

    function showOverlay(title, sub) {
      overlayTitle.textContent = title;
      overlaySub.textContent = sub;
      overlay.classList.add('visible');
    }

    function hideOverlay() {
      overlay.classList.remove('visible');
    }

    function updateHUD() {
      nftfanEl.textContent = nftfan;
      maticEl.textContent = matic;

      if (now() < powerActiveUntil) {
        const secs = Math.ceil((powerActiveUntil - now()) / 1000);
        powerActiveEl.innerHTML =
          '<span class="power-indicator">' +
          '<img src="https://i.imgur.com/RwdMFUB.png" alt="Power" />' +
          '<strong>POWER:</strong>&nbsp;Double NFTFAN · ' + secs + 's' +
          '</span>';
      } else {
        powerActiveEl.textContent = '';
      }
    }

    function drawGridBackground() {
      ctx.fillStyle = '#0c1321';
      ctx.fillRect(0, 0, pixelSize, pixelSize);

      // subtle grid
      ctx.strokeStyle = 'rgba(255,255,255,0.03)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      for (let i = 1; i < GRID_SIZE; i++) {
        const v = i * tileSize;
        ctx.moveTo(v, 0); ctx.lineTo(v, pixelSize);
        ctx.moveTo(0, v); ctx.lineTo(pixelSize, v);
      }
      ctx.stroke();

      // inner glow
      const grd = ctx.createRadialGradient(
        pixelSize/2, pixelSize/2, Math.min(pixelSize, 600)/4,
        pixelSize/2, pixelSize/2, Math.max(pixelSize, 600)
      );
      grd.addColorStop(0, 'rgba(108,240,255,0.05)');
      grd.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grd;
      ctx.fillRect(0,0,pixelSize,pixelSize);
    }

    function drawRoundedRect(x, y, w, h, r) {
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      ctx.closePath();
      ctx.fill();
    }

    function draw() {
      drawGridBackground();

      // food
      if (food) {
        const fx = food.x * tileSize;
        const fy = food.y * tileSize;
        const pad = tileSize * 0.12;
        ctx.save();
        ctx.globalAlpha = 0.95;
        ctx.drawImage(tokenImg, fx + pad, fy + pad, tileSize - 2*pad, tileSize - 2*pad);
        ctx.restore();
      }

      // power
      if (power) {
        const px = power.x * tileSize;
        const py = power.y * tileSize;
        const pad = tileSize * 0.12;
        ctx.save();
        // glow
        ctx.shadowColor = 'rgba(138,255,108,0.8)';
        ctx.shadowBlur = tileSize * 0.35;
        ctx.drawImage(powerImg, px + pad, py + pad, tileSize - 2*pad, tileSize - 2*pad);
        ctx.restore();
      }

      // snake
      const activePower = now() < powerActiveUntil;
      for (let i = 0; i < snake.length; i++) {
        const s = snake[i];
        const x = s.x * tileSize;
        const y = s.y * tileSize;

        if (i === snake.length - 1) {
          // head
          ctx.fillStyle = activePower ? '#b6ff99' : 'rgb(157, 240, 255)';
          if (activePower) {
            ctx.save();
            ctx.shadowColor = 'rgba(138,255,108,0.7)';
            ctx.shadowBlur = tileSize * 0.45;
          }
          drawRoundedRect(x + 1, y + 1, tileSize - 2, tileSize - 2, Math.max(6, tileSize * 0.28));
          if (activePower) ctx.restore();
        } else {
          // body
          ctx.fillStyle = activePower ? '#9cf58a' : 'rgb(79, 212, 255)';
          drawRoundedRect(x + 2, y + 2, tileSize - 4, tileSize - 4, Math.max(5, tileSize * 0.22));
        }
      }

      // border
      ctx.strokeStyle = 'rgba(108,240,255,0.25)';
      ctx.lineWidth = 2;
      ctx.strokeRect(1, 1, pixelSize - 2, pixelSize - 2);
    }

    function step() {
      dir = nextDir;

      const head = snake[snake.length - 1];
      const nx = head.x + dir.x;
      const ny = head.y + dir.y;

      // wall collision (no wrapping)
      if (nx < 0 || nx >= GRID_SIZE || ny < 0 || ny >= GRID_SIZE) {
        endGame();
        return;
      }

      // self collision
      for (let i = 0; i < snake.length; i++) {
        if (snake[i].x === nx && snake[i].y === ny) {
          endGame();
          return;
        }
      }

      // advance
      snake.push({ x: nx, y: ny });

      let grew = false;

      // power check
      if (power && power.x === nx && power.y === ny) {
        power = null;
        powerActiveUntil = now() + POWER_DURATION_MS;
        matic += 1;
        updateHUD();
        if (VIBRATE_OK) navigator.vibrate(40);
        // After picking a power, delay next spawn a bit
        scheduleNextPower(POWER_SPAWN_MIN_MS);
      }

      // food check
      if (food && food.x === nx && food.y === ny) {
        const activePower = now() < powerActiveUntil;
        nftfan += activePower ? 2 : 1;
        foodsEaten += 1;
        grew = true;
        spawnFood();
        if (VIBRATE_OK) navigator.vibrate(25);
        // speed up gently every N foods (cap it)
        if (foodsEaten % SPEEDUP_EVERY === 0) {
          stepMs = Math.max(70, stepMs - SPEEDUP_DELTA);
        }
        updateHUD();
      }

      if (!grew) {
        snake.shift(); // move forward without growing
      }

      // maybe spawn power
      if (!power && now() >= nextPowerAt && now() >= powerActiveUntil) {
        spawnPower();
        // if it isn't picked for a while, auto-despawn and reschedule
        // We'll implement a soft TTL via nextPowerAt reuse:
        // set a despawn time ~ 10s after spawn; if present after, clear and reschedule
        power.despawnAt = now() + 10000;
      }
      if (power && power.despawnAt && now() > power.despawnAt) {
        power = null;
        scheduleNextPower();
      }
    }

    function loop(ts) {
      if (!running) return;

      const elapsed = ts - lastStep;
      if (elapsed >= stepMs) {
        step();
        draw();
        lastStep = ts;
      }

      requestAnimationFrame(loop);
    }

    // Input handling
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') setDirection(0, -1);
      else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') setDirection(0, 1);
      else if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') setDirection(-1, 0);
      else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') setDirection(1, 0);
      else if (e.key === ' ' || e.key === 'Enter') {
        if (gameOver) resetGame();
        else if (running) pauseGame();
        else resumeGame();
      }
    }, { passive: true });

    function hookButton(btn, dx, dy) {
      const handler = (ev) => { ev.preventDefault(); setDirection(dx, dy); };
      btn.addEventListener('click', handler);
      btn.addEventListener('touchstart', handler, { passive: false });
    }
    hookButton(dpad.up, 0, -1);
    hookButton(dpad.down, 0, 1);
    hookButton(dpad.left, -1, 0);
    hookButton(dpad.right, 1, 0);

    btnPause.addEventListener('click', () => {
      if (gameOver) return;
      if (running) pauseGame(); else resumeGame();
    });
    btnRestart.addEventListener('click', resetGame);
    btnRestart2.addEventListener('click', resetGame);
    btnResume.addEventListener('click', resumeGame);

    // Swipe support on the game area
    (function addSwipe(el) {
      let sx = 0, sy = 0, tracking = false;
      const threshold = 18; // px
      el.addEventListener('touchstart', (e) => {
        if (!e.touches || e.touches.length !== 1) return;
        tracking = true;
        sx = e.touches[0].clientX;
        sy = e.touches[0].clientY;
      }, { passive: true });
      el.addEventListener('touchmove', (e) => {
        if (!tracking || !e.touches || e.touches.length !== 1) return;
        const dx = e.touches[0].clientX - sx;
        const dy = e.touches[0].clientY - sy;
        if (Math.abs(dx) < threshold && Math.abs(dy) < threshold) return;
        if (Math.abs(dx) > Math.abs(dy)) {
          setDirection(dx > 0 ? 1 : -1, 0);
        } else {
          setDirection(0, dy > 0 ? 1 : -1);
        }
        tracking = false;
      }, { passive: true });
      el.addEventListener('touchend', () => { tracking = false; }, { passive: true });
    })(wrap);

    // Resize handler
    const ro = new ResizeObserver(resizeCanvas);
    ro.observe(wrap);
    window.addEventListener('orientationchange', () => setTimeout(resizeCanvas, 200));

    // Start when images are ready
    Promise.all([
      new Promise((res) => tokenImg.complete ? res() : tokenImg.addEventListener('load', res)),
      new Promise((res) => powerImg.complete ? res() : powerImg.addEventListener('load', res)),
    ]).then(() => {
      resizeCanvas();
      resetGame();
    });

    // Prevent long-press context menu on mobile for controls/canvas
    ['contextmenu', 'gesturestart'].forEach(evt => {
      document.addEventListener(evt, (e) => {
        if (e.target.closest('.dir-btn') || e.target.closest('#canvas-wrap')) {
          e.preventDefault();
        }
      });
    });
  </script>
</body>
</html>
