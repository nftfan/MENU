<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NFT Countries â€” Mint Countries on the Map</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600;700&display=swap" rel="stylesheet" />
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --accent: #f59e0b;
      --success: #10b981;
      --error: #ef4444;
      --bg: #0f1020;
      --card: #14162b;
      --text: #f8fafc;
      --muted: #94a3b8;
      --border: #253357;
      --radius: 12px;
      --shadow: rgba(0,0,0,0.25);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 0% 0%, rgba(99,102,241,0.12), transparent 60%),
                  radial-gradient(1200px 600px at 100% 0%, rgba(245,158,11,0.1), transparent 60%),
                  linear-gradient(180deg, #0b0c1a, #0f1020);
      color: var(--text);
    }
    header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px; gap: 10px;
    }
    .brand { display: flex; align-items: center; gap: 10px; }
    .logo {
      width: 28px; height: 28px; border-radius: 50%;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      display: grid; place-items: center; box-shadow: 0 4px 12px var(--shadow);
    }
    .logo .material-icons { font-size: 16px; color: #fff; }
    .title h1 { margin: 0; font-size: 16px; font-weight: 700; }
    .title p { margin: 0; font-size: 11px; color: var(--muted); }

    .actions { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button {
      appearance: none; border: 1px solid transparent; border-radius: 10px;
      padding: 8px 10px; font-size: 12px; font-weight: 700; color: #fff; cursor: pointer;
      display: inline-flex; align-items: center; gap: 6px;
      background: #1a1d36; border-color: #2a3560; transition: transform .15s ease, opacity .2s ease;
    }
    button .material-icons { font-size: 16px; }
    button.primary { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); border-color: transparent; }
    button.accent { background: linear-gradient(135deg, var(--accent), #fb923c); border-color: transparent; color: #1a1305; }
    button.success { background: linear-gradient(135deg, var(--success), #34d399); border-color: transparent; color: #052318; }
    button:disabled { opacity: .6; cursor: not-allowed; transform: none !important; }
    button:not(:disabled):active { transform: translateY(1px); }
    .wallet { color: #a7f3d0; font-size: 12px; font-weight: 700; }

    main { display: grid; grid-template-columns: 1fr; gap: 10px; padding: 0 12px 12px; }
    @media (min-width: 980px) { main { grid-template-columns: 1.6fr 1fr; } }

    #map {
      height: 64vh; width: 100%;
      border-radius: var(--radius); border: 1px solid var(--border);
      overflow: hidden; background: #0e1023; box-shadow: 0 8px 20px var(--shadow);
    }

    .panel {
      background: var(--card); border: 1px solid var(--border); border-radius: var(--radius);
      padding: 12px; display: grid; gap: 10px;
    }
    .row { display: grid; gap: 8px; }
    .row.inline { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    .pill {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 11px; padding: 6px 8px; border-radius: 999px; border: 1px solid var(--border);
      background: #0f1329; color: #cbd5e1;
    }

    .status {
      min-height: 38px; display: grid; place-items: center; text-align: center;
      font-size: 12px; border-radius: 10px; padding: 8px;
      border: 1px solid #22345a; color: var(--muted);
    }
    .status.success { background: rgba(16,185,129,.12); color: var(--success); border-color: rgba(16,185,129,.35); }
    .status.error { background: rgba(239,68,68,.12); color: var(--error); border-color: rgba(239,68,68,.35); }
    .status.loading { display: inline-flex; align-items: center; gap: 8px; justify-content: center; }
    .spinner {
      width: 14px; height: 14px; border-radius: 50%;
      border: 2px solid rgba(255,255,255,.25); border-top-color: var(--primary);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    .legend {
      display: flex; gap: 10px; flex-wrap: wrap; align-items: center;
      font-size: 12px; color: #cbd5e1;
    }
    .legend .key { display: inline-flex; align-items: center; gap: 6px; }
    .legend .box { width: 14px; height: 14px; border-radius: 3px; border: 1px solid #334155; }

    .leaflet-container { background: #0e1023; }
    .leaflet-control-attribution, .leaflet-control-zoom a { background: #14162b; color: #cbd5e1; border-color: #2a3560; }
    .leaflet-popup-content-wrapper, .leaflet-popup-tip { background: #111327; color: #e5e7eb; border: 1px solid var(--border); }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo"><span class="material-icons">public</span></div>
      <div class="title">
        <h1>NFT Countries</h1>
        <p>Click a country to mint it as an NFT</p>
      </div>
    </div>
    <div class="actions">
      <span class="pill"><span class="material-icons" style="font-size:16px;">paid</span> Mint Price: <strong style="margin-left:4px;">1 $POL</strong></span>
      <button id="connectBtn" class="primary"><span class="material-icons">account_balance_wallet</span>Connect</button>
      <span id="wallet" class="wallet"></span>
    </div>
  </header>

  <main>
    <div id="map" aria-label="Map"></div>

    <div class="panel">
      <div class="row">
        <div class="legend">
          <div class="key"><span class="box" style="background:#28314f;"></span> Unminted</div>
          <div class="key"><span class="box" style="background:#d97706;"></span> Minted (anyone)</div>
          <div class="key"><span class="box" style="background:#059669;"></span> You own</div>
          <div class="key"><span class="box" style="background:#4f46e5;"></span> Selected</div>
        </div>
        <div class="row inline">
          <span id="selectionPill" class="pill" style="display:none;"></span>
          <span id="ownedCountPill" class="pill" style="display:none;"></span>
          <span id="mintedCountPill" class="pill" style="display:none;"></span>
        </div>
      </div>

      <div class="row inline">
        <button id="mintBtn" class="success" disabled><span class="material-icons">rocket_launch</span>Mint Country</button>
        <button id="clearBtn" class="accent"><span class="material-icons">delete_sweep</span>Clear Selection</button>
        <button id="refreshBtn"><span class="material-icons">refresh</span>Refresh Minted</button>
      </div>

      <div id="status" class="status"></div>
    </div>
  </main>

  <script>
    // Polygon Mainnet
    const POLYGON_PARAMS = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com/'],
      blockExplorerUrls: ['https://polygonscan.com/']
    };

    // Contract (must be ERC721-compatible)
    const CONTRACT_ADDRESS = "0xb7d9E197905A0Fe7A59d82029eEFCBfDa631E2CC";
    const CONTRACT_ABI = [
      "function mintWithURI(string tokenURI) external payable returns (uint256)",
      "function mintPrice() view returns (uint256)",
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"
    ];

    // Optional: If known, set deployment start block to speed up log queries. Otherwise it scans from 0.
    const START_BLOCK = 0; // set to contract deployment block for better performance

    // Map & data
    let map;
    let countriesLayer;
    let geojsonData;
    let selectedCode = null;
    let selectedName = null;

    // Minted sets
    let mintedCodes = new Set(); // All minted country codes
    let myOwnedCodes = new Set(); // Codes currently owned by connected wallet

    // Ethers
    let web3Provider, readProvider, signer, userAddress;

    // UI
    const connectBtn = document.getElementById('connectBtn');
    const walletEl = document.getElementById('wallet');
    const mintBtn = document.getElementById('mintBtn');
    const clearBtn = document.getElementById('clearBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const statusEl = document.getElementById('status');
    const selectionPill = document.getElementById('selectionPill');
    const ownedCountPill = document.getElementById('ownedCountPill');
    const mintedCountPill = document.getElementById('mintedCountPill');

    function setStatus(msg, type = '') {
      if (!msg) {
        statusEl.textContent = '';
        statusEl.className = 'status';
        return;
      }
      statusEl.className = 'status';
      if (type === 'success') statusEl.classList.add('success');
      if (type === 'error') statusEl.classList.add('error');
      if (type === 'loading') {
        statusEl.classList.add('loading');
        statusEl.innerHTML = `<span class="spinner"></span><span>${msg}</span>`;
      } else {
        statusEl.textContent = msg;
      }
    }

    function toFixed5(n) { return (Math.round(n * 100000) / 100000).toFixed(5); }

    function getCountryProps(props) {
      // Try multiple common field names across datasets
      const code =
        props.ISO_A3 || props.iso_a3 || props.ADM0_A3 || props.adm0_a3 ||
        props.cca3 || props.a3 || props.iso3 || props.iso3code || props.ISO3;
      const name =
        props.ADMIN || props.name || props.ADMIN_NAME || props.NAME_EN ||
        props.country || props.Country || props.sovereignt || props.sov_a3 || props.NAME;
      return { code: code || null, name: name || 'Unknown' };
    }

    function styleFeature(feature) {
      const { code } = getCountryProps(feature.properties || {});
      const isSelected = (selectedCode && code === selectedCode);
      const isMine = (code && myOwnedCodes.has(code));
      const isMinted = (code && mintedCodes.has(code));

      let fill = '#28314f'; // default unminted
      if (isMinted) fill = '#d97706'; // minted by anyone
      if (isMine) fill = '#059669'; // I own
      if (isSelected) fill = '#4f46e5'; // selected overrides

      return {
        weight: isSelected ? 1.5 : 0.6,
        opacity: 1,
        color: isSelected ? '#a5b4fc' : '#1f2937',
        fillOpacity: isSelected ? 0.75 : 0.55,
        fillColor: fill
      };
    }

    function onEachFeature(feature, layer) {
      const { code, name } = getCountryProps(feature.properties || {});
      layer.on('click', () => {
        if (!code) return;

        selectedCode = code;
        selectedName = name;
        updateSelectionPill();

        const alreadyMinted = mintedCodes.has(code);
        if (alreadyMinted) {
          setStatus(`"${name}" (${code}) is already minted.`, 'error');
          mintBtn.disabled = true;
        } else {
          setStatus(`Selected "${name}" (${code}). You can mint it.`, 'success');
          mintBtn.disabled = !userAddress;
        }

        // Update styles on selection
        countriesLayer.setStyle(styleFeature);
        try { layer.bringToFront(); } catch {}
        // Popup info
        const center = layer.getBounds().getCenter();
        const meta = `
          <div style="min-width:200px;">
            <div style="font-weight:800;margin-bottom:6px;">${escapeHTML(name)} (${escapeHTML(code)})</div>
            <div style="font-size:12px;color:#94a3b8;">Center: ${toFixed5(center.lat)}, ${toFixed5(center.lng)}</div>
            <div style="margin-top:8px;font-size:12px;color:#cbd5e1;">${mintedCodes.has(code) ? 'Already minted' : 'Not minted yet'}</div>
          </div>
        `;
        layer.bindPopup(meta).openPopup();
      });

      layer.on('mouseover', function() {
        this.setStyle({ weight: 1.5 });
      });
      layer.on('mouseout', function() {
        this.setStyle(styleFeature(feature));
      });
    }

    function updateSelectionPill() {
      if (!selectedCode) {
        selectionPill.style.display = 'none';
        return;
      }
      const minted = mintedCodes.has(selectedCode);
      const mine = myOwnedCodes.has(selectedCode);
      selectionPill.style.display = 'inline-flex';
      selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">flag</span> ${escapeHTML(selectedName)} (${escapeHTML(selectedCode)}) Â· ${mine ? 'You own' : minted ? 'Minted' : 'Unminted'}`;
    }

    function updateCountsPills() {
      const owned = myOwnedCodes.size;
      const minted = mintedCodes.size;
      if (owned > 0) {
        ownedCountPill.style.display = 'inline-flex';
        ownedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;">verified</span> You own: <strong style="margin-left:4px;">${owned}</strong>`;
      } else {
        ownedCountPill.style.display = 'none';
      }
      mintedCountPill.style.display = 'inline-flex';
      mintedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;">public</span> Minted total: <strong style="margin-left:4px;">${minted}</strong>`;
    }

    async function loadCountries() {
      setStatus('Loading countries...', 'loading');
      // World countries GeoJSON (lightweight)
      const url = 'https://cdn.jsdelivr.net/npm/geojson-world@4.0.0/countries.geo.json';
      const res = await fetch(url);
      if (!res.ok) throw new Error('Failed to load countries GeoJSON');
      geojsonData = await res.json();

      countriesLayer = L.geoJSON(geojsonData, {
        style: styleFeature,
        onEachFeature
      }).addTo(map);

      map.fitBounds(countriesLayer.getBounds(), { padding: [10, 10] });
      setStatus('Map ready. Click a country to select it.', 'success');
    }

    function initMap() {
      if (!window.L) {
        setStatus('Leaflet failed to load. Refresh and try again.', 'error'); return;
      }
      map = L.map('map', { center: [20, 0], zoom: 2, zoomControl: true, worldCopyJump: true });
      const tiles = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 8,
        attribution: '&copy; OpenStreetMap'
      })
      .on('load', () => { /* tiles ok */ })
      .on('tileerror', () => setStatus('Tile load error (network/rate limit).', 'error'));
      tiles.addTo(map);
    }

    // Wallet
    async function switchToPolygon() {
      if (!window.ethereum) return false;
      try {
        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: POLYGON_PARAMS.chainId }] });
        return true;
      } catch (e) {
        if (e.code === 4902) {
          try {
            await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [POLYGON_PARAMS] });
            return true;
          } catch {
            setStatus('Failed to add Polygon to wallet', 'error'); return false;
          }
        }
        setStatus('Failed to switch network', 'error'); return false;
      }
    }

    async function connectWallet() {
      if (!window.ethereum) { setStatus('Please install MetaMask to continue', 'error'); return; }
      try {
        setStatus('Connecting wallet...', 'loading');
        const switched = await switchToPolygon();
        if (!switched) return;

        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        await web3Provider.send('eth_requestAccounts', []);
        signer = web3Provider.getSigner();
        userAddress = await signer.getAddress();

        connectBtn.disabled = true;
        connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
        walletEl.textContent = `${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;

        setStatus('Wallet connected. Fetching minted countries...', 'loading');

        // Separate read provider for log queries
        readProvider = new ethers.providers.JsonRpcProvider(POLYGON_PARAMS.rpcUrls[0]);
        await refreshMinted(true);

        // Enable mint button if a valid selection exists
        if (selectedCode && !mintedCodes.has(selectedCode)) mintBtn.disabled = false;
        else mintBtn.disabled = true;

      } catch (e) {
        console.error(e);
        setStatus('Wallet connection failed', 'error');
      }
    }

    function escapeHTML(s) {
      return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');
    }

    // Build tokenURI JSON (data URL) with country code and name
    function buildCountryMetadata({ code, name }) {
      const image = buildCountrySVG(code, name);
      const metadata = {
        name: `Country: ${name} (${code})`,
        description: `Minted country NFT for ${name} (${code}).`,
        image,
        attributes: [
          { trait_type: "Country Name", value: name },
          { trait_type: "Country Code", value: code }
        ]
      };
      const json = JSON.stringify(metadata);
      return "data:application/json;base64," + btoa(unescape(encodeURIComponent(json)));
    }

    function buildCountrySVG(code, name) {
      const safeName = escapeHTML(name);
      const safeCode = escapeHTML(code);
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="800" height="420">
          <defs>
            <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stop-color="#4f46e5"/>
              <stop offset="100%" stop-color="#06b6d4"/>
            </linearGradient>
          </defs>
          <rect width="100%" height="100%" fill="#0b0c1a"/>
          <rect x="20" y="20" width="760" height="380" rx="20" fill="url(#g)" opacity="0.25"/>
          <g font-family="Inter, Arial, sans-serif" fill="#e5e7eb">
            <text x="40" y="160" font-size="44" font-weight="700">${safeName}</text>
            <text x="40" y="210" font-size="28" fill="#cbd5e1">Code: ${safeCode}</text>
            <g transform="translate(40,260)">
              <rect width="260" height="50" rx="10" fill="#10b981" />
              <text x="18" y="33" font-size="20" font-weight="700" fill="#00110d">NFT Country</text>
            </g>
          </g>
        </svg>
      `;
      return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
    }

    async function mintSelectedCountry() {
      try {
        if (!userAddress) { setStatus('Connect wallet first', 'error'); return; }
        if (!selectedCode || !selectedName) { setStatus('Select a country first', 'error'); return; }
        if (mintedCodes.has(selectedCode)) { setStatus('This country is already minted', 'error'); return; }

        const tokenURI = buildCountryMetadata({ code: selectedCode, name: selectedName });

        setStatus('Submitting mint transaction...', 'loading');
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

        let mintPrice;
        try {
          mintPrice = await contract.mintPrice();
        } catch {
          mintPrice = ethers.utils.parseUnits('1', 18);
        }

        const tx = await contract.mintWithURI(tokenURI, { value: mintPrice });
        await tx.wait();

        // Update local state
        mintedCodes.add(selectedCode);
        myOwnedCodes.add(selectedCode);
        updateSelectionPill();
        updateCountsPills();
        countriesLayer.setStyle(styleFeature);

        setStatus(`Success! You minted "${selectedName}" (${selectedCode}).`, 'success');
        mintBtn.disabled = true;
      } catch (e) {
        console.error(e);
        const msg = e?.data?.message || e?.message || 'Unknown error';
        setStatus('Minting failed: ' + msg, 'error');
      }
    }

    async function refreshMinted(showToast = false) {
      try {
        setStatus('Fetching minted countries from chain...', 'loading');
        if (!readProvider) readProvider = new ethers.providers.JsonRpcProvider(POLYGON_PARAMS.rpcUrls[0]);
        const contractRead = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, readProvider);

        // Query mint events: Transfer(from=0x0, to=any)
        const zero = '0x0000000000000000000000000000000000000000';
        const filter = contractRead.filters.Transfer(zero, null);
        const logs = await contractRead.queryFilter(filter, START_BLOCK, 'latest');

        // Unique token IDs
        const tokenIds = Array.from(new Set(logs.map(l => l.args?.tokenId?.toString()).filter(Boolean)));

        // Helper to batch process requests to avoid RPC overload
        async function batch(items, size, cb) {
          const results = [];
          for (let i = 0; i < items.length; i += size) {
            const slice = items.slice(i, i + size);
            const res = await Promise.all(slice.map(cb));
            results.push(...res);
            // slight delay to be gentle
            await new Promise(r => setTimeout(r, 150));
          }
          return results;
        }

        const codeByToken = new Map();

        // Fetch tokenURI for each tokenId, parse country code
        await batch(tokenIds, 20, async (tid) => {
          try {
            const uri = await contractRead.tokenURI(tid);
            const meta = await resolveTokenMetadata(uri);
            const code = extractCountryCode(meta);
            if (code) codeByToken.set(tid, code);
          } catch (e) {
            // ignore parse issues
          }
        });

        // Build mintedCodes set
        mintedCodes = new Set(Array.from(codeByToken.values()));

        // If wallet connected, find which of those you currently own
        myOwnedCodes = new Set();
        if (userAddress) {
          await batch(Array.from(codeByToken.keys()), 15, async (tid) => {
            try {
              const owner = await contractRead.ownerOf(tid);
              if (owner && owner.toLowerCase() === userAddress.toLowerCase()) {
                const code = codeByToken.get(tid);
                if (code) myOwnedCodes.add(code);
              }
            } catch {}
          });
        }

        // Update UI
        updateCountsPills();
        if (countriesLayer) countriesLayer.setStyle(styleFeature);

        if (showToast) setStatus('Minted countries updated.', 'success');
        else setStatus('', '');
      } catch (e) {
        console.error(e);
        setStatus('Failed to fetch minted data. Try Refresh again.', 'error');
      }
    }

    async function resolveTokenMetadata(uri) {
      // data:application/json;base64,...
      if (uri.startsWith('data:application/json')) {
        const base64 = uri.split(',')[1] || '';
        const json = atob(base64);
        return JSON.parse(json);
      }
      // IPFS or HTTP(S)
      let url = uri;
      if (uri.startsWith('ipfs://')) {
        url = 'https://ipfs.io/ipfs/' + uri.replace('ipfs://', '');
      }
      const res = await fetch(url);
      return await res.json();
    }

    function extractCountryCode(meta) {
      if (!meta) return null;
      // Prefer attributes array entries
      if (Array.isArray(meta.attributes)) {
        for (const a of meta.attributes) {
          const key = (a.trait_type || a.trait || '').toLowerCase();
          if (key.includes('country code') || key === 'code') {
            return String(a.value || '').toUpperCase();
          }
        }
      }
      // Fallback keys
      const direct = meta.country_code || meta.code || meta.countryCode || meta.iso_a3 || meta.ISO_A3;
      return direct ? String(direct).toUpperCase() : null;
    }

    function clearSelection() {
      selectedCode = null;
      selectedName = null;
      mintBtn.disabled = true;
      selectionPill.style.display = 'none';
      if (countriesLayer) countriesLayer.setStyle(styleFeature);
      setStatus('Selection cleared. Click a country to select it.');
    }

    connectBtn.addEventListener('click', connectWallet);
    mintBtn.addEventListener('click', mintSelectedCountry);
    clearBtn.addEventListener('click', clearSelection);
    refreshBtn.addEventListener('click', () => refreshMinted(true));

    // Init
    document.addEventListener('DOMContentLoaded', async () => {
      initMap();
      try {
        await loadCountries();
      } catch (e) {
        console.error(e);
        setStatus('Failed to load countries. Check network and refresh.', 'error');
      }

      // Attempt to auto-connect if already authorized
      if (window.ethereum?.selectedAddress) {
        connectWallet().catch(() => {});
      }
    });
  </script>
</body>
</html>
