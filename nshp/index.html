<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>NFTFANS ERC1155 Shop (Debug)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    html, body { background: #fff; font-family: 'Inter', Arial, sans-serif; margin: 0; padding: 0; font-size: 10px; color: #222; min-height: 100vh;}
    .wrapper { max-width: 480px; margin: 0 auto; padding: 10px 0 30px 0; position: relative;}
    .top-bar { width: 100%; min-height: 38px; display: flex; justify-content: space-between; align-items: center; gap: 8px; padding: 10px 12px 0 0; box-sizing: border-box;}
    .nftfan-balance-bar { background: #f8f7ff; border-radius: 13px; border: 1px solid #ececec; padding: 4px 11px 4px 7px; margin-left: 10px; margin-right: 0; display: flex; align-items: center; font-size: 11px; font-weight: bold; color: #7a3cff; gap: 5px; min-width: 0; max-width: 160px; white-space: nowrap;}
    .nftfan-token-icon { width: 20px; height: 20px; margin-right: 3px; border-radius: 50%; background: #fff; border: 1px solid #ececec; object-fit: contain; display: inline-block; vertical-align: middle;}
    .connect-btn { font-size: 10px; padding: 7px 18px; border-radius: 15px; border: 1px solid #ececec; background: #f4f0ff; color: #7a3cff; font-weight: bold; cursor: pointer; outline: none; transition: background 0.18s, box-shadow 0.18s; box-shadow: none; display: inline-block; margin: 0;}
    .connect-btn:active { background: #ede4ff; }
    .connect-btn:disabled { color: #ccc; background: #f8f8f8; cursor: not-allowed;}
    .tab-bar { display: flex; border-radius: 10px; overflow: hidden; margin: 14px 10px 18px 10px; border: 1px solid #ececec; background: #f8f7ff; box-shadow: none;}
    .tab-btn { flex: 1; padding: 12px; background: transparent; border: none; font-size: 12px; font-weight: bold; color: #7a3cff; letter-spacing: 0.2px; cursor: pointer; outline: none; transition: background 0.18s, color 0.18s;}
    .tab-btn.active { background: #e5e0fa; color: #764ba2;}
    .tab-content { margin: 0 10px; padding: 10px 0 0 0; min-height: 160px; animation: fadein 0.2s;}
    @keyframes fadein { from { opacity: 0; } to { opacity: 1; } }
    .nft-grid, .shop-grid { display: flex; flex-wrap: wrap; gap: 10px; margin: 0; padding: 0; list-style: none; justify-content: flex-start;}
    .nft-card, .shop-item { width: calc((100% - 20px) / 3); background: none; border: none; box-shadow: none; padding: 0; margin: 0; display: flex; flex-direction: column; align-items: center;}
    .nft-img, .shop-img { width: 92px; height: 92px; object-fit: cover; background: #ececec; border-radius: 8px; margin-bottom: 5px; border: 1px solid #ececec;}
    .nft-title, .shop-title { font-size: 10px; font-weight: bold; color: #333; text-align: center; margin-bottom: 0; letter-spacing: 0.07px; line-height: 1.2;}
    .shop-price { font-size: 10px; color: #7a3cff; margin-bottom: 6px; font-weight: bold;}
    .buy-btn, .sell-btn { font-size: 10px; padding: 5px 13px; border-radius: 12px; border: 1px solid #e0dbfa; background: #e5e0fa; color: #764ba2; font-weight: 600; cursor: pointer; margin-bottom: 3px;}
    .buy-btn:active, .sell-btn:active { background: #ede4ff; }
    .buy-btn[disabled], .sell-btn[disabled] { color: #ccc; background: #f8f8f8; cursor: not-allowed;}
    .nft-id { font-size: 9px; color: #888; margin-bottom: 2px; text-align: center;}
    .sold-out { font-size: 10px; color: #E53E3E; font-weight: bold; margin-bottom: 6px; margin-top: 2px; text-align: center;}
    .inventory { font-size: 9px; color: #888; margin-bottom: 1px;}
    .loading { font-size: 12px; color: #aaa; text-align: center; margin: 30px 0; width: 100%;}
    .error { font-size: 11px; color: #E53E3E; text-align: center; margin: 20px 0; width: 100%; background: #ffeaea; padding: 10px; border-radius: 8px; border: 1px solid #ffcccc;}
    .debug-info { font-size: 9px; color: #666; background: #f5f5f5; padding: 8px; border-radius: 6px; margin: 10px 0; border: 1px solid #ddd;}
    .status-bar { background: #f0f9ff; border: 1px solid #bfdbfe; padding: 8px; margin: 10px; border-radius: 6px; font-size: 10px; color: #1e40af;}
    @media (max-width: 575px) {
      .wrapper { max-width: 100vw; padding: 2vw 0 12vw 0;}
      .tab-bar, .tab-content { margin-left: 2vw; margin-right: 2vw;}
      .top-bar { padding-right: 2vw; padding-left: 2vw;}
      .nft-card, .shop-item { width: calc((100% - 10vw) / 3); min-width: 78px;}
      .nft-img, .shop-img { width: 22vw; min-width: 68px; height: 22vw; min-height: 68px;}
      .nftfan-balance-bar { max-width: 32vw; font-size: 10px; padding: 4px 6px 4px 4px;}
    }

    async function sellNFT(tokenId, maxAmount) {
      if (!userAccount) {
        alert("Connect your wallet first!");
        return;
      }
      
      let amount = 1;
      if (maxAmount > 1) {
        let input = prompt(`How many would you like to sell? (max ${maxAmount})`, "1");
        if (!input) return;
        amount = parseInt(input);
        if (isNaN(amount) || amount < 1 || amount > maxAmount) {
          alert("Invalid amount");
          return;
        }
      }
      
      let price = prompt("Set price in MATIC to sell this NFT:");
      if (!price) return;
      
      let priceWei;
      try {
        priceWei = web3.utils.toWei(price, "ether");
      } catch (e) {
        alert("Invalid price.");
        return;
      }
      
      try {
        updateStatus('Processing sale...');
        const button = document.querySelector(`button[onclick^="sellNFT(${tokenId},"]`);
        if (button) button.disabled = true;
        
        if (!nftfanShop) await setupContracts();
        
        await nftfanShop.methods.sellNFT(tokenId, amount, priceWei).send({ from: userAccount });
        
        alert("NFT listed in shop successfully!");
        updateStatus('Sale listing successful');
        loadShopNFTs();
        loadUserNFTs();
        
      } catch (error) {
        logError(error, 'NFT Sale');
        updateStatus('Sale listing failed');
        alert("Sale failed: " + error.message);
      } finally {
        // Re-enable button and reload
        setTimeout(() => {
          loadShopNFTs();
          loadUserNFTs();
        }, 1000);
      }
    }

    // --- TABS ---
    function showTab(tab) {
      // Hide all tab contents
      document.getElementById('tab-content-shop').style.display = 'none';
      document.getElementById('tab-content-mynfts').style.display = 'none';
      document.getElementById('tab-content-debug').style.display = 'none';
      
      // Show selected tab content
      document.getElementById(`tab-content-${tab}`).style.display = 'block';
      
      // Update tab button states
      document.getElementById('tab-shop').classList.remove('active');
      document.getElementById('tab-mynfts').classList.remove('active');
      document.getElementById('tab-debug').classList.remove('active');
      document.getElementById(`tab-${tab}`).classList.add('active');
      
      // Load data when switching tabs
      if (tab === 'shop') {
        loadShopNFTs();
      } else if (tab === 'mynfts') {
        loadUserNFTs();
      }
    }

    // --- EVENT LISTENERS ---
    if (window.ethereum) {
      window.ethereum.on('accountsChanged', function (accounts) {
        userAccount = accounts[0] || null;
        const connectBtn = document.getElementById("connect-btn");
        connectBtn.textContent = userAccount ? "âœ” Connected" : "ðŸ”— Connect Wallet";
        
        if (userAccount) {
          setupContracts().then(() => {
            showNftfanBalance();
            loadShopNFTs();
            loadUserNFTs();
            updateStatus('Account changed - reloaded');
          }).catch(e => {
            logError(e, 'Account Change');
            updateStatus('Account change failed');
          });
        } else {
          updateStatus('Wallet disconnected');
        }
      });
      
      window.ethereum.on('chainChanged', function (chainId) {
        updateStatus('Network changed - reconnecting...');
        setupContracts().then(() => {
          showNftfanBalance();
          loadShopNFTs();
          loadUserNFTs();
          updateStatus('Network changed - reloaded');
        }).catch(e => {
          logError(e, 'Chain Change');
          updateStatus('Network change failed');
        });
      });
    }

    // --- INITIALIZATION ---
    window.addEventListener("DOMContentLoaded", async () => {
      try {
        updateStatus('Initializing application...');
        await setupContracts();
        await loadShopNFTs();
        updateStatus('Application ready');
      } catch (error) {
        logError(error, 'Initialization');
        updateStatus('Initialization failed');
        
        // Show user-friendly error message
        const shopError = document.getElementById('shop-error');
        showError('shop-error', 'Failed to initialize the application. Please check your internet connection and try refreshing the page.');
      }
    });

    // --- ADDITIONAL UTILITY FUNCTIONS ---
    
    // Function to retry failed operations
    async function retryOperation(operation, maxRetries = 3, delay = 1000) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          return await operation();
        } catch (error) {
          if (i === maxRetries - 1) throw error;
          console.warn(`Operation failed, retrying in ${delay}ms...`, error);
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Exponential backoff
        }
      }
    }

    // Function to check if user is on correct network
    async function ensureCorrectNetwork() {
      if (!window.ethereum) return false;
      
      try {
        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
        return chainId === POLYGON_PARAMS.chainId;
      } catch (error) {
        logError(error, 'Network Check');
        return false;
      }
    }

    // Function to format large numbers
    function formatNumber(num) {
      if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
      return num.toString();
    }

    // Function to truncate addresses
    function truncateAddress(address) {
      if (!address) return '';
      return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }

    // Export functions for debugging (available in console)
    window.debugFunctions = {
      testContractConnection,
      loadShopNFTs,
      loadUserNFTs,
      connectWallet,
      setupContracts,
      retryOperation,
      ensureCorrectNetwork
    };

    console.log('NFTFANS Shop Debug Version Loaded');
    console.log('Available debug functions:', Object.keys(window.debugFunctions));
  </script>
</body>
</html>
  </style>
</head>
<body>
  <div class="wrapper">
    <div class="top-bar">
      <div class="nftfan-balance-bar" id="nftfanBalanceBar" style="display:none;">
        <img class="nftfan-token-icon" src="https://i.imgur.com/ODP45iQ.png" alt="NFTFAN Token">
        <span id="nftfanBalance">--</span>
        <span style="font-size:10px;font-weight:400;color:#888;margin-left:2px;">NFTFAN</span>
      </div>
      <button class="connect-btn" id="connect-btn" onclick="connectWallet()">ðŸ”— Connect Wallet</button>
    </div>
    
    <div class="status-bar" id="statusBar">
      Status: Initializing...
    </div>
    
    <div class="tab-bar">
      <button class="tab-btn active" id="tab-shop" onclick="showTab('shop')">NFTFANS Shop</button>
      <button class="tab-btn" id="tab-mynfts" onclick="showTab('mynfts')">My NFTs</button>
      <button class="tab-btn" id="tab-debug" onclick="showTab('debug')">Debug</button>
    </div>
    
    <div class="tab-content" id="tab-content-shop">
      <div id="shop-loading" class="loading">Loading NFTs...</div>
      <div id="shop-error" class="error" style="display: none;"></div>
      <ul class="shop-grid" id="shopGrid" style="display: none;"></ul>
    </div>
    
    <div class="tab-content" id="tab-content-mynfts" style="display:none;">
      <div id="my-loading" class="loading">Loading Your NFTs...</div>
      <div id="my-error" class="error" style="display: none;"></div>
      <ul class="nft-grid" id="myGrid" style="display: none;"></ul>
    </div>
    
    <div class="tab-content" id="tab-content-debug" style="display:none;">
      <div class="debug-info">
        <h3 style="margin-top:0;">Debug Information</h3>
        <div id="debugInfo">
          <p><strong>Network:</strong> <span id="networkInfo">Not connected</span></p>
          <p><strong>Wallet:</strong> <span id="walletInfo">Not connected</span></p>
          <p><strong>Contract Status:</strong> <span id="contractInfo">Not initialized</span></p>
          <p><strong>Last Error:</strong> <span id="lastError">None</span></p>
        </div>
        <button onclick="testContractConnection()" style="margin-top:10px; padding:5px 10px; background:#f0f9ff; border:1px solid #bfdbfe; border-radius:4px; cursor:pointer;">Test Contract Connection</button>
      </div>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
  <script>
    // --- CONFIG ---
    const POLYGON_PARAMS = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com/', 'https://rpc.polygon.technology/', 'https://rpc-mainnet.matic.network/'],
      blockExplorerUrls: ['https://polygonscan.com/'],
    };
    const NFTFAN_TOKEN_CA = "0x2017Fcaea540d2925430586DC92818035Bfc2F50";
    const NFTFAN_SHOP_CA = "0x9ce8C0dDFc6600eC82ecc37B719e62e3248BE3AF";

    // --- ABIs ---
    const ERC20_ABI = [
      {"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"type":"function"},
      {"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"type":"function"}
    ];
    const NFTFAN_SHOP_ABI = [
      { "constant": true, "inputs": [{ "name": "account", "type": "address" }, { "name": "id", "type": "uint256" }], "name": "balanceOf", "outputs": [{ "name": "", "type": "uint256" }], "type": "function" },
      { "constant": true, "inputs": [{ "name": "user", "type": "address" }], "name": "tokensOfOwner", "outputs": [
        { "name": "tokenIds", "type": "uint256[]" }, { "name": "amounts", "type": "uint256[]" }
      ], "type": "function" },
      { "constant": true, "inputs": [{ "name": "tokenId", "type": "uint256" }], "name": "uri", "outputs": [{ "name": "uri", "type": "string" }], "type": "function" },
      { "constant": true, "inputs": [], "name": "getShopNFTs", "outputs": [
        { "name": "ids", "type": "uint256[]" },
        { "name": "uris", "type": "string[]" },
        { "name": "prices", "type": "uint256[]" },
        { "name": "isForSale", "type": "bool[]" },
        { "name": "shopAmounts", "type": "uint256[]" },
        { "name": "maxSupplies", "type": "uint256[]" },
        { "name": "currentSupplies", "type": "uint256[]" }
      ], "type": "function" },
      { "constant": true, "inputs": [{ "name": "tokenId", "type": "uint256" }], "name": "nftInfo", "outputs": [
        { "name": "tokenURI", "type": "string" },
        { "name": "price", "type": "uint256" },
        { "name": "forSale", "type": "bool" },
        { "name": "originalCreator", "type": "address" },
        { "name": "maxSupply", "type": "uint256" },
        { "name": "currentSupply", "type": "uint256" }
      ], "type": "function" },
      { "constant": true, "inputs": [{ "name": "tokenId", "type": "uint256" }], "name": "shopInventory", "outputs": [ { "name":"amount","type":"uint256" } ], "type": "function" },
      { "inputs": [{ "name": "tokenId", "type": "uint256" }, { "name": "amount", "type": "uint256" }], "name": "buyNFT", "outputs": [], "stateMutability": "payable", "type": "function" },
      { "inputs": [{ "name": "tokenId", "type": "uint256" }, { "name": "amount", "type": "uint256" }, { "name": "_price", "type": "uint256" }], "name": "sellNFT", "outputs": [], "stateMutability": "nonpayable", "type": "function" }
    ];

    // --- APP STATE ---
    let userAccount = null;
    let web3;
    let nftfanContract = null;
    let nftfanShop = null;
    let lastError = null;

    // --- UTILITY FUNCTIONS ---
    function updateStatus(message) {
      document.getElementById('statusBar').textContent = `Status: ${message}`;
      updateDebugInfo();
    }

    function logError(error, context = '') {
      lastError = `${context}: ${error.message || error}`;
      console.error('Error:', error);
      updateDebugInfo();
    }

    function updateDebugInfo() {
      document.getElementById('networkInfo').textContent = web3 ? 'Connected' : 'Not connected';
      document.getElementById('walletInfo').textContent = userAccount || 'Not connected';
      document.getElementById('contractInfo').textContent = (nftfanContract && nftfanShop) ? 'Initialized' : 'Not initialized';
      document.getElementById('lastError').textContent = lastError || 'None';
    }

    function showError(elementId, message) {
      const errorEl = document.getElementById(elementId);
      errorEl.textContent = message;
      errorEl.style.display = 'block';
    }

    function hideError(elementId) {
      document.getElementById(elementId).style.display = 'none';
    }

    // --- WALLET CONNECTION ---
    async function connectWallet() {
      try {
        updateStatus('Connecting wallet...');
        
        if (!window.ethereum) {
          throw new Error("Please install MetaMask or a compatible wallet!");
        }

        // Check/switch to Polygon
        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
        if (chainId !== POLYGON_PARAMS.chainId) {
          updateStatus('Switching to Polygon network...');
          try {
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: POLYGON_PARAMS.chainId }],
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [POLYGON_PARAMS],
              });
            } else {
              throw switchError;
            }
          }
        }

        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        userAccount = accounts[0];
        document.getElementById("connect-btn").textContent = "âœ” Connected";
        
        await setupContracts();
        await showNftfanBalance();
        updateStatus('Connected successfully');
        
        // Load data
        loadShopNFTs();
        loadUserNFTs();
        
      } catch (error) {
        logError(error, 'Wallet Connection');
        updateStatus('Connection failed');
        alert("Connection failed: " + error.message);
      }
    }

    async function setupContracts() {
      try {
        updateStatus('Setting up contracts...');
        
        // Try multiple RPC endpoints
        const rpcUrls = POLYGON_PARAMS.rpcUrls;
        let provider = null;
        
        if (window.ethereum) {
          provider = window.ethereum;
        } else {
          // Try public RPC endpoints
          for (const rpcUrl of rpcUrls) {
            try {
              const testWeb3 = new Web3(rpcUrl);
              await testWeb3.eth.getBlockNumber(); // Test connection
              provider = rpcUrl;
              break;
            } catch (e) {
              console.warn(`RPC ${rpcUrl} failed:`, e);
            }
          }
        }
        
        if (!provider) {
          throw new Error('No working RPC provider found');
        }
        
        web3 = new Web3(provider);
        nftfanContract = new web3.eth.Contract(ERC20_ABI, NFTFAN_TOKEN_CA);
        nftfanShop = new web3.eth.Contract(NFTFAN_SHOP_ABI, NFTFAN_SHOP_CA);
        
        updateStatus('Contracts initialized');
        
      } catch (error) {
        logError(error, 'Contract Setup');
        throw error;
      }
    }

    async function testContractConnection() {
      try {
        updateStatus('Testing contract connection...');
        
        if (!nftfanShop) {
          await setupContracts();
        }
        
        // Test contract call
        const result = await nftfanShop.methods.getShopNFTs().call();
        const [ids] = result;
        
        updateStatus(`Contract test successful - Found ${ids.length} NFTs`);
        alert(`Contract connection successful! Found ${ids.length} NFTs in shop.`);
        
      } catch (error) {
        logError(error, 'Contract Test');
        updateStatus('Contract test failed');
        alert('Contract test failed: ' + error.message);
      }
    }

    async function showNftfanBalance() {
      if (!nftfanContract || !userAccount) {
        document.getElementById('nftfanBalanceBar').style.display = 'none';
        return;
      }
      try {
        let [balance, decimals] = await Promise.all([
          nftfanContract.methods.balanceOf(userAccount).call(),
          nftfanContract.methods.decimals().call()
        ]);
        const divisor = BigInt(10) ** BigInt(decimals);
        let intBalance = (BigInt(balance) / divisor).toString();
        intBalance = Number(intBalance).toLocaleString('en');
        document.getElementById('nftfanBalance').textContent = intBalance;
        document.getElementById('nftfanBalanceBar').style.display = '';
      } catch (e) {
        logError(e, 'Balance Loading');
        document.getElementById('nftfanBalanceBar').style.display = 'none';
      }
    }

    // OpenSea Metadata Fetcher
    async function fetchOpenSeaMeta(uri) {
      if (!uri) return null;
      
      try {
        // Convert IPFS and Arweave URIs
        if (uri.startsWith("ipfs://")) {
          uri = "https://ipfs.io/ipfs/" + uri.replace("ipfs://", "");
        }
        if (uri.startsWith("ar://")) {
          uri = "https://arweave.net/" + uri.replace("ar://", "");
        }
        
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000); // 10s timeout
        
        const res = await fetch(uri, {
          mode: 'cors',
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);
        
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        return await res.json();
      } catch (e) {
        console.warn('Failed to fetch metadata:', uri, e);
        return null;
      }
    }

    // --- NFT SHOP LOGIC ---
    async function loadShopNFTs() {
      const shopGrid = document.getElementById("shopGrid");
      const loading = document.getElementById("shop-loading");
      const errorEl = document.getElementById("shop-error");
      
      shopGrid.innerHTML = "";
      loading.style.display = "block";
      shopGrid.style.display = "none";
      hideError("shop-error");
      
      try {
        updateStatus('Loading shop NFTs...');
        
        if (!nftfanShop) {
          await setupContracts();
        }
        
        const result = await nftfanShop.methods.getShopNFTs().call();
        const [ids, uris, prices, isForSale, shopAmounts, maxSupplies, currentSupplies] = result;
        
        if (!ids.length) {
          loading.textContent = "No NFTs in Shop";
          updateStatus('Shop loaded - no NFTs available');
          return;
        }
        
        updateStatus(`Loading metadata for ${ids.length} NFTs...`);
        
        // Load metadata with timeout
        const metaPromises = uris.map(async (uri, index) => {
          try {
            const meta = await fetchOpenSeaMeta(uri);
            return meta;
          } catch (e) {
            console.warn(`Failed to load metadata for NFT ${ids[index]}:`, e);
            return null;
          }
        });
        
        const metaArr = await Promise.all(metaPromises);
        
        let html = "";
        for (let i = 0; i < ids.length; i++) {
          const id = ids[i];
          const meta = metaArr[i];
          const openseaName = meta?.name || `NFTFAN #${id}`;
          const openseaImg = meta?.image || uris[i] || "https://via.placeholder.com/92x92?text=NFT";
          const openseaDesc = meta?.description || "";
          const price = web3.utils.fromWei(prices[i], "ether");
          
          let status = "";
          let btn = "";
          let inv = "";
          
          if (!isForSale[i] || shopAmounts[i] == "0") {
            status = `<div class="sold-out">Sold Out</div>`;
            btn = `<button class="buy-btn" disabled>Sold Out</button>`;
          } else {
            inv = `<div class="inventory">Available: ${shopAmounts[i]}</div>`;
            btn = `<button class="buy-btn" onclick="buyNFT(${id}, '${prices[i]}', ${shopAmounts[i]})" ${!userAccount ? 'disabled' : ''}>Buy</button>`;
          }
          
          html += `<li class="shop-item">
              <img class="shop-img" src="${openseaImg}" alt="NFT ${openseaName}" onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
              <div class="shop-title">${openseaName}</div>
              <div class="shop-price">${price} MATIC</div>
              ${openseaDesc ? `<div class="inventory" style="font-size:9px;color:#222;margin-bottom:2px;">${openseaDesc.substring(0, 50)}${openseaDesc.length > 50 ? '...' : ''}</div>` : ""}
              ${inv}
              ${status}
              ${btn}
          </li>`;
        }
        
        shopGrid.innerHTML = html;
        loading.style.display = "none";
        shopGrid.style.display = "flex";
        updateStatus(`Shop loaded - ${ids.length} NFTs available`);
        
      } catch (error) {
        logError(error, 'Shop Loading');
        shopGrid.innerHTML = "";
        loading.style.display = "none";
        showError("shop-error", "Failed to load NFTs: " + error.message);
        updateStatus('Shop loading failed');
      }
    }

    async function buyNFT(tokenId, priceWei, availableAmount) {
      if (!userAccount) {
        alert("Connect your wallet first!");
        return;
      }
      
      let amount = 1;
      if (availableAmount > 1) {
        let input = prompt(`How many would you like to buy? (max ${availableAmount})`, "1");
        if (!input) return;
        amount = parseInt(input);
        if (isNaN(amount) || amount < 1 || amount > availableAmount) {
          alert("Invalid amount");
          return;
        }
      }
      
      try {
        updateStatus('Processing purchase...');
        const button = document.querySelector(`button[onclick^="buyNFT(${tokenId},"]`);
        if (button) button.disabled = true;
        
        if (!nftfanShop) await setupContracts();
        
        await nftfanShop.methods.buyNFT(tokenId, amount).send({ 
          from: userAccount, 
          value: (BigInt(priceWei) * BigInt(amount)).toString() 
        });
        
        alert("NFT bought successfully! It will appear in 'My NFTs'");
        updateStatus('Purchase successful');
        loadShopNFTs();
        loadUserNFTs();
        
      } catch (error) {
        logError(error, 'NFT Purchase');
        updateStatus('Purchase failed');
        alert("Purchase failed: " + error.message);
      } finally {
        // Re-enable button and reload
        setTimeout(() => {
          loadShopNFTs();
          loadUserNFTs();
        }, 1000);
      }
    }

    // --- MY NFTS LOGIC ---
    async function loadUserNFTs() {
      const myGrid = document.getElementById("myGrid");
      const loading = document.getElementById("my-loading");
      const errorEl = document.getElementById("my-error");
      
      myGrid.innerHTML = "";
      loading.style.display = "block";
      myGrid.style.display = "none";
      hideError("my-error");
      
      if (!userAccount) {
        loading.textContent = "Connect wallet to view your NFTs.";
        return;
      }
      
      try {
        updateStatus('Loading your NFTs...');
        
        if (!nftfanShop) await setupContracts();
        
        const tokens = await nftfanShop.methods.tokensOfOwner(userAccount).call();
        const [tokenIds, amounts] = tokens;
        
        if (!tokenIds.length) {
          loading.textContent = "You own no NFTs yet.";
          updateStatus('Your NFTs loaded - none found');
          return;
        }
        
        let metaArr = await Promise.all(tokenIds.map(async (id, index) => {
          try {
            let meta = await nftfanShop.methods.nftInfo(id).call();
            let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
            return {id, amount: amounts[index], meta, metaJson};
          } catch (e) {
            console.warn(`Failed to load NFT ${id}:`, e);
            return {id, amount: amounts[index], meta: null, metaJson: null};
          }
        }));
        
        let html = "";
        for (let item of metaArr) {
          const {id, amount, meta, metaJson} = item;
          const openseaName = metaJson?.name || `NFTFAN #${id}`;
          const openseaImg = metaJson?.image || (meta?.tokenURI || "https://via.placeholder.com/92x92?text=NFT");
          const openseaDesc = metaJson?.description || "";
          
          html += `<li class="nft-card">
              <img class="nft-img" src="${openseaImg}" alt="NFT ${openseaName}" onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
              <div class="nft-title">${openseaName}</div>
              <div class="nft-id">ID: ${id}</div>
              ${openseaDesc ? `<div class="inventory" style="font-size:9px;color:#222;margin-bottom:2px;">${openseaDesc.substring(0, 50)}${openseaDesc.length > 50 ? '...' : ''}</div>` : ""}
              <div class="inventory">You own: ${amount}</div>
              <div style="width:100%;display:flex;justify-content:center;">
                <button class="sell-btn" onclick="sellNFT(${id}, ${amount})">Sell</button>
              </div>
          </li>`;
        }
        
        myGrid.innerHTML = html;
        loading.style.display = "none";
        myGrid.style.display = "flex";
        updateStatus(`Your NFTs loaded - ${tokenIds.length} found`);
        
      } catch (error) {
        logError(error, 'User NFTs Loading');
        myGrid.innerHTML = "";
        loading.style.display = "none";
        showError("my-error", "Failed to load your NFTs: " + error.message);
        updateStatus('Your NFTs loading failed');
      }
    }
	
	async function sellNFT(tokenId, maxAmount) {
      if (!userAccount) {
        alert("Connect your wallet first!");
        return;
      }
      
      let amount = 1;
      if (maxAmount > 1) {
        let input = prompt(`How many would you like to sell? (max ${maxAmount})`, "1");
        if (!input) return;
        amount = parseInt(input);
        if (isNaN(amount) || amount < 1 || amount > maxAmount) {
          alert("Invalid amount");
          return;
        }
      }
      
      let price = prompt("Set price in MATIC to sell this NFT:");
      if (!price) return;
      
      let priceWei;
      try {
        priceWei = web3.utils.toWei(price, "ether");
      } catch (e) {
        alert("Invalid price.");
        return;
      }
      
      try {
        updateStatus('Processing sale...');
        const button = document.querySelector(`button[onclick^="sellNFT(${tokenId},"]`);
        if (button) button.disabled = true;
        
        if (!nftfanShop) await setupContracts();
        
        await nftfanShop.methods.sellNFT(tokenId, amount, priceWei).send({ from: userAccount });
        
        alert("NFT listed in shop successfully!");
        updateStatus('Sale listing successful');
        loadShopNFTs();
        loadUserNFTs();
        
      } catch (error) {
        logError(error, 'NFT Sale');
        updateStatus('Sale listing failed');
        alert("Sale failed: " + error.message);
      } finally {
        // Re-enable button and reload
        setTimeout(() => {
          loadShopNFTs();
          loadUserNFTs();
        }, 1000);
      }
    }

    // --- TABS ---
    function showTab(tab) {
      // Hide all tab contents
      document.getElementById('tab-content-shop').style.display = 'none';
      document.getElementById('tab-content-mynfts').style.display = 'none';
      document.getElementById('tab-content-debug').style.display = 'none';
      
      // Show selected tab content
      document.getElementById(`tab-content-${tab}`).style.display = 'block';
      
      // Update tab button states
      document.getElementById('tab-shop').classList.remove('active');
      document.getElementById('tab-mynfts').classList.remove('active');
      document.getElementById('tab-debug').classList.remove('active');
      document.getElementById(`tab-${tab}`).classList.add('active');
      
      // Load data when switching tabs
      if (tab === 'shop') {
        loadShopNFTs();
      } else if (tab === 'mynfts') {
        loadUserNFTs();
      }
    }

    // --- EVENT LISTENERS ---
    if (window.ethereum) {
      window.ethereum.on('accountsChanged', function (accounts) {
        userAccount = accounts[0] || null;
        const connectBtn = document.getElementById("connect-btn");
        connectBtn.textContent = userAccount ? "âœ” Connected" : "ðŸ”— Connect Wallet";
        
        if (userAccount) {
          setupContracts().then(() => {
            showNftfanBalance();
            loadShopNFTs();
            loadUserNFTs();
            updateStatus('Account changed - reloaded');
          }).catch(e => {
            logError(e, 'Account Change');
            updateStatus('Account change failed');
          });
        } else {
          updateStatus('Wallet disconnected');
        }
      });
      
      window.ethereum.on('chainChanged', function (chainId) {
        updateStatus('Network changed - reconnecting...');
        setupContracts().then(() => {
          showNftfanBalance();
          loadShopNFTs();
          loadUserNFTs();
          updateStatus('Network changed - reloaded');
        }).catch(e => {
          logError(e, 'Chain Change');
          updateStatus('Network change failed');
        });
      });
    }

    // --- INITIALIZATION ---
    window.addEventListener("DOMContentLoaded", async () => {
      try {
        updateStatus('Initializing application...');
        await setupContracts();
        await loadShopNFTs();
        updateStatus('Application ready');
      } catch (error) {
        logError(error, 'Initialization');
        updateStatus('Initialization failed');
        
        // Show user-friendly error message
        const shopError = document.getElementById('shop-error');
        showError('shop-error', 'Failed to initialize the application. Please check your internet connection and try refreshing the page.');
      }
    });

    // --- ADDITIONAL UTILITY FUNCTIONS ---
    
    // Function to retry failed operations
    async function retryOperation(operation, maxRetries = 3, delay = 1000) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          return await operation();
        } catch (error) {
          if (i === maxRetries - 1) throw error;
          console.warn(`Operation failed, retrying in ${delay}ms...`, error);
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Exponential backoff
        }
      }
    }

    // Function to check if user is on correct network
    async function ensureCorrectNetwork() {
      if (!window.ethereum) return false;
      
      try {
        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
        return chainId === POLYGON_PARAMS.chainId;
      } catch (error) {
        logError(error, 'Network Check');
        return false;
      }
    }

    // Function to format large numbers
    function formatNumber(num) {
      if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
      if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
      if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
      return num.toString();
    }

    // Function to truncate addresses
    function truncateAddress(address) {
      if (!address) return '';
      return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }

    // Export functions for debugging (available in console)
    window.debugFunctions = {
      testContractConnection,
      loadShopNFTs,
      loadUserNFTs,
      connectWallet,
      setupContracts,
      retryOperation,
      ensureCorrectNetwork
    };

    console.log('NFTFANS Shop Debug Version Loaded');
    console.log('Available debug functions:', Object.keys(window.debugFunctions));
  </script>
</body>
</html>
