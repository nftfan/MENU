<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>NFTFANS ERC1155 Shop</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
    :root {
      --primary: #2563eb;
      --primary-light: #60a5fa;
      --bg: #f6fbff;
      --card-bg: #fff;
      --radius: 11px;
      --shadow: 0 1.5px 6px rgba(30,58,138,0.07);
      --shadow-hover: 0 3px 12px rgba(30,58,138,0.11);
      --error: #e11d48;
      --desc: #495375;
      --border: #e6ecf5;
      --muted: #8ca3c6;
      --font-main: 'Inter', Arial, sans-serif;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--primary);
      font-family: var(--font-main);
      min-height: 100vh;
      font-size: 14px;
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none;
    }
    .banner-wrap {
      width: 100vw; position: relative; margin-bottom: 0px;
      min-height: 80px;
      display: flex; justify-content: center; align-items: flex-start;
      background: var(--bg);
      border-bottom: 1.5px solid var(--border);
      overflow: hidden;
    }
    .banner-img {
      width: 100vw; max-height: 110px; object-fit: cover;
      display: block;
      filter: brightness(0.95) saturate(1.15);
      min-height: 90px;
      max-width: 100vw;
    }
    .banner-connect-btn {
      position: absolute; right: 11px; top: 13px;
      background: rgba(255,255,255,0.93);
      border: none;
      border-radius: 20px;
      color: var(--primary);
      font-weight: 600;
      font-size: 10px;
      padding: 5.5px 16px 5.5px 10px;
      box-shadow: var(--shadow);
      cursor: pointer;
      outline: none;
      transition: background .16s;
      z-index: 10;
      display: flex;
      align-items: center;
      gap: 2px;
    }
    .banner-connect-btn .material-icons { font-size: 1.13em; }
    .banner-connect-btn:hover { background: #e4efff; }

    .wrapper {
      max-width: 480px;
      margin: -19px auto 0 auto;
      padding: 0 4px 10px 4px;
      position: relative;
    }
    .status-bar {
      padding: 4px 8px;
      background: #e7f2ff;
      border-radius: 7px;
      margin: 10px 0 8px 0;
      font-size: 10px;
      color: var(--primary);
      display: flex; align-items: center; gap: 4px;
      box-shadow: var(--shadow);
      min-height: 22px;
    }
    .material-icons.status-ic { font-size: 1.08em; color: var(--primary-light); vertical-align: middle; }
    .tab-bar {
      display: flex; gap: 4px; margin-bottom: 9px;
      background: var(--card-bg);
      border-radius: 11px;
      box-shadow: var(--shadow);
      overflow: auto;
      padding: 3.5px 2.5px;
      justify-content: flex-start;
    }
    .tab-btn {
      flex: 1 1 0px;
      padding: 7px 0;
      background: none;
      border: none;
      outline: none;
      border-radius: 8px;
      font-weight: 600;
      font-size: 10px;
      color: var(--primary);
      cursor: pointer;
      transition: background 0.13s, color 0.13s;
      display: flex; align-items: center; justify-content: center; gap: 3px;
      letter-spacing: 0.01em;
      min-width: 0;
    }
    .tab-btn.active {
      background: linear-gradient(90deg, var(--primary-light) 0%, var(--primary) 100%);
      color: #fff;
      box-shadow: var(--shadow);
    }
    .tab-btn:not(.active):hover {
      background: #e8f2ff;
      color: var(--primary);
    }
    /* ---- Grid 3 col mobile ---- */
    .shop-grid, .recent-listings-grid, .nft-grid {
      list-style: none; padding: 0; margin: 0;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 7px 3.5px;
      justify-content: flex-start;
      align-items: stretch;
      width: 100%;
    }
    /* Card for NFTs */
    .card {
      background: var(--card-bg);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 6px 4px 8px 6px;
      min-width: 0;
      text-align: left;
      transition: box-shadow .13s;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      position: relative;
      min-height: 145px;
      max-width: 100vw;
    }
    .card:hover { box-shadow: var(--shadow-hover); }
    .card-img {
      width: 100%;
      aspect-ratio: 1/1;
      min-height: 0; min-width: 0;
      object-fit: cover !important;
      border-radius: 7px;
      margin-bottom: 3px;
      background: #f1f7fc;
      box-shadow: 0 0.5px 3px rgba(0,0,0,0.07);
      border: 1.2px solid #f1f7fc;
    }
    .card-title {
      font-size: 8.5px;
      font-weight: 700;
      margin: 1.5px 0 0.5px 0;
      color: var(--primary);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      width: 100%;
      letter-spacing: 0.01em;
      text-align: left;
    }
    .card-id {
      font-size: 7.5px;
      color: var(--muted);
      margin-bottom: 0.5px;
      font-weight: 500;
      text-align: left;
    }
    .card-price {
      font-size: 8.5px;
      color: var(--primary-light);
      margin-bottom: 0.5px;
      font-weight: 600;
      display: flex; align-items: center; gap: 2px;
      text-align: left;
    }
    .sold-out, .recent-listing-amount, .inventory {
      font-size: 7.5px;
      font-weight: 600;
      color: var(--error);
      margin-bottom: 2.5px;
      text-align: left;
    }
    .sold-out { color: var(--error); }
    .inventory { color: #3a3e49; font-weight: 400; }
    .listing-seller {
      font-size: 6.7px;
      color: var(--muted);
      margin-bottom: 2px;
      font-weight: 400;
      text-align: left;
      display: flex; align-items: center; gap: 2.5px;
    }
    .card-actions {
      width: 100%; display: flex; gap: 2.5px;
      justify-content: flex-start;
      margin-top: 2.5px;
    }
    .btn, .buy-btn, .sell-btn, .recent-listing-buy-btn {
      flex: 1 1 0;
      padding: 3.5px 0;
      background: linear-gradient(90deg, var(--primary-light) 0%, var(--primary) 100%);
      border: none; border-radius: 5.5px;
      color: #fff;
      font-weight: 600;
      font-size: 8.5px;
      cursor: pointer;
      transition: background .15s, color .13s, box-shadow .13s;
      box-shadow: 0 0.5px 2.5px rgba(30,58,138,0.08);
      display: flex; align-items: center; justify-content: center; gap: 2.5px;
      min-width: 0;
      min-height: 20px;
    }
    .btn:disabled, .buy-btn:disabled, .sell-btn:disabled, .recent-listing-buy-btn:disabled {
      background: #d1d5db; color: #7c899f; cursor: not-allowed; box-shadow: none;
    }
    .btn:not(:disabled):hover, .buy-btn:not(:disabled):hover, .sell-btn:not(:disabled):hover, .recent-listing-buy-btn:not(:disabled):hover {
      background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
      color: #fff;
    }
    .desc {
      font-size: 6.8px;
      color: var(--desc);
      font-weight: 400;
      margin-bottom: 1px;
      min-height: 13px;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      text-align: left;
    }
    .loading {
      text-align: center;
      padding: 22px 0 12px 0;
      color: var(--primary);
      font-size: 9px;
      font-weight: 500;
      letter-spacing: 0.01em;
    }
    .error {
      background: #fee2e2;
      color: var(--error);
      padding: 7px 10px;
      border-radius: 7px;
      margin-bottom: 8px;
      font-size: 8.5px;
      box-shadow: 0 1px 2.5px rgba(30,58,138,0.04);
    }
    /* Sell Modal */
    #sellModal {
      display: none; position: fixed; z-index: 999; left: 0; top: 0; width: 100vw; height: 100vh;
      background: rgba(0,0,0,0.5); justify-content: center; align-items: center;
    }
    #sellModalContent {
      background: #fff; padding: 21px 13px 13px 13px; border-radius: 11px; box-shadow: var(--shadow);
      min-width: 210px; max-width: 92vw; display: flex; flex-direction: column; align-items: center;
      font-size: 10px; gap: 2.3px;
    }
    #sellModalContent input {
      margin: 3.5px 0 7px 0; padding: 6px; border: 1px solid #a8cfff; border-radius: 4.5px; width: 80%; font-size: 9px;
      background: #f4f9ff;
      transition: border .14s;
    }
    #sellModalContent input:focus { border: 1.5px solid var(--primary); }
    #sellModalContent button {
      padding: 5.5px 13px; border-radius: 7px; border: none;
      background: linear-gradient(90deg, var(--primary-light) 0%, var(--primary) 100%);
      color: #fff; font-weight: bold; cursor: pointer;
      margin-top: 4px;
      font-size: 9px;
    }
    #sellModalContent button:hover { background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%); }
    /* Custom scrollbar */
    ::-webkit-scrollbar { width: 4px; background: #e7f2ff; }
    ::-webkit-scrollbar-thumb { background: #b6d3fc; border-radius: 8px; }
    ::selection { background: #dbeafe; }
    @media (max-width: 700px) {
      html, body { font-size: 11.7px; }
      .wrapper { max-width: 99vw; }
      .shop-grid, .recent-listings-grid, .nft-grid { gap: 5.5px 2px; }
      .card { min-height: 135px; }
    }
    @media (max-width: 425px) {
      html, body { font-size: 10.2px; }
      .wrapper { max-width: 100vw; }
      .status-bar { font-size: 8.2px; min-height: 19px;}
      .shop-grid, .recent-listings-grid, .nft-grid { gap: 3.5px 1.5px; }
      .card { min-height: 112px; }
      .tab-bar { padding: 2px; }
      .tab-btn { font-size: 8.7px; padding: 4.5px 0; }
    }
    @media (max-width: 340px) {
      html, body { font-size: 8px; }
      .banner-connect-btn { font-size: 8px; }
      .tab-btn { font-size: 7.2px; }
    }
  </style>
</head>
<body>
  <div class="banner-wrap">
    <img class="banner-img" src="https://pbs.twimg.com/media/Gs758wIWEAEsq45?format=jpg&name=large" alt="Banner">
    <button class="banner-connect-btn" id="connect-btn" onclick="connectWallet()">
      <span class="material-icons">account_balance_wallet</span>
      <span id="connect-btn-label">Connect Wallet</span>
    </button>
  </div>

  <div class="wrapper">
    <div class="status-bar" id="statusBar">
      <span class="material-icons status-ic">info</span>
      <span id="statusMsg">Initializing...</span>
    </div>
    <div class="tab-bar">
      <button class="tab-btn active" id="tab-shop" onclick="showTab('shop')">
        <span class="material-icons">storefront</span> NFTFANS Shop
      </button>
      <button class="tab-btn" id="tab-recent" onclick="showTab('recent')">
        <span class="material-icons">bolt</span> Recently Listed
      </button>
      <button class="tab-btn" id="tab-mynfts" onclick="showTab('mynfts')">
        <span class="material-icons">collections</span> My NFTs
      </button>
    </div>
    <div class="tab-content" id="tab-content-shop">
      <div id="shop-loading" class="loading">Loading NFTs...</div>
      <div id="shop-error" class="error" style="display: none;"></div>
      <ul class="shop-grid" id="shopGrid" style="display: none;"></ul>
    </div>
    <div class="tab-content" id="tab-content-recent" style="display:none;">
      <div id="recent-loading" class="loading">Loading Recently Listed NFTs...</div>
      <div id="recent-error" class="error" style="display: none;"></div>
      <ul class="recent-listings-grid" id="recentListingsGrid" style="display: none;"></ul>
    </div>
    <div class="tab-content" id="tab-content-mynfts" style="display:none;">
      <div id="my-loading" class="loading">Loading Your NFTs...</div>
      <div id="my-error" class="error" style="display: none;"></div>
      <ul class="nft-grid" id="myGrid" style="display: none;"></ul>
    </div>
  </div>
  <!-- Sell Modal -->
  <div id="sellModal">
    <div id="sellModalContent">
      <h3 style="font-size:11px;margin:2px 0 7px 0;">Sell Your NFT</h3>
      <div style="font-size:9px;">Token ID: <span id="sellTokenId"></span></div>
      <div style="font-size:9px;">You own: <span id="sellMaxAmount"></span></div>
      <input type="number" id="sellAmountInput" min="1" placeholder="Amount to sell">
      <input type="number" id="sellPriceInput" step="0.000000000000000001" placeholder="Price per NFT (MATIC)">
      <div style="display:flex;gap:7px;width:100%;justify-content:center;">
        <button onclick="confirmSellNFT()"><span class='material-icons' style='font-size:1em;vertical-align:middle;'>sell</span> Sell</button>
        <button onclick="closeSellModal()" style="background:#d1d5db;color:#222;">Cancel</button>
      </div>
      <div id="sellModalError" style="color:#dc2626;margin-top:4px;font-size:8px;"></div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
  <script>
    const POLYGON_PARAMS = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com/', 'https://rpc.polygon.technology/', 'https://rpc-mainnet.matic.network/'],
      blockExplorerUrls: ['https://polygonscan.com/'],
    };
    const NFTFAN_SHOP_CA = "0x10FdffF7E02CDfB4E5d34FA5Dc93074f1F2619cc";
    const NFTFAN_SHOP_ABI = [
      { "inputs": [], "stateMutability": "nonpayable", "type": "constructor" },
      { "anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"creator","type":"address"},{"indexed":false,"internalType":"string","name":"tokenURI","type":"string"},{"indexed":false,"internalType":"uint256","name":"price","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"NFTMinted","type":"event" },
      { "anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"buyer","type":"address"},{"indexed":false,"internalType":"address","name":"seller","type":"address"},{"indexed":false,"internalType":"uint256","name":"price","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"NFTBought","type":"event" },
      { "anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"},{"indexed":false,"internalType":"address","name":"seller","type":"address"},{"indexed":false,"internalType":"uint256","name":"price","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"NFTListed","type":"event" },
      { "anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"NFTUnlisted","type":"event" },
      { "inputs": [], "name": "nextTokenId", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" },
      { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "nftInfo", "outputs": [
        { "internalType": "string", "name": "tokenURI", "type": "string" },
        { "internalType": "uint256", "name": "price", "type": "uint256" },
        { "internalType": "bool", "name": "forSale", "type": "bool" },
        { "internalType": "address", "name": "originalCreator", "type": "address" },
        { "internalType": "uint256", "name": "maxSupply", "type": "uint256" },
        { "internalType": "uint256", "name": "currentSupply", "type": "uint256" }
      ], "stateMutability": "view", "type": "function" },
      { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "shopInventory", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" },
      { "inputs": [], "name": "getShopNFTs", "outputs": [
        { "internalType": "uint256[]", "name": "ids", "type": "uint256[]" },
        { "internalType": "string[]", "name": "uris", "type": "string[]" },
        { "internalType": "uint256[]", "name": "prices", "type": "uint256[]" },
        { "internalType": "bool[]", "name": "isForSale", "type": "bool[]" },
        { "internalType": "uint256[]", "name": "shopAmounts", "type": "uint256[]" },
        { "internalType": "uint256[]", "name": "maxSupplies", "type": "uint256[]" },
        { "internalType": "uint256[]", "name": "currentSupplies", "type": "uint256[]" }
      ], "stateMutability": "view", "type": "function" },
      { "inputs": [ { "internalType": "address", "name": "user", "type": "address" } ], "name": "tokensOfOwner", "outputs": [
        { "internalType": "uint256[]", "name": "tokenIds", "type": "uint256[]" },
        { "internalType": "uint256[]", "name": "amounts", "type": "uint256[]" }
      ], "stateMutability": "view", "type": "function" },
      { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "getListings", "outputs": [
        { "components": [
          { "internalType": "address", "name": "seller", "type": "address" },
          { "internalType": "uint256", "name": "amount", "type": "uint256" },
          { "internalType": "uint256", "name": "price", "type": "uint256" }
        ], "internalType": "struct NFTFansShop.Listing[]", "name": "", "type": "tuple[]" }
      ], "stateMutability": "view", "type": "function" },
      { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "internalType": "uint256", "name": "amount", "type": "uint256" } ], "name": "buyNFT", "outputs": [], "stateMutability": "payable", "type": "function" },
      { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" }, { "internalType": "uint256", "name": "amount", "type": "uint256" }, { "internalType": "uint256", "name": "_price", "type": "uint256" } ], "name": "sellNFT", "outputs": [], "stateMutability": "nonpayable", "type": "function" },
      { "inputs": [ { "internalType": "address", "name": "account", "type": "address" }, { "internalType": "uint256", "name": "id", "type": "uint256" } ], "name": "balanceOf", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" },
      { "inputs": [ { "internalType": "uint256", "name": "tokenId", "type": "uint256" } ], "name": "uri", "outputs": [ { "internalType": "string", "name": "", "type": "string" } ], "stateMutability": "view", "type": "function" }
    ];
    let userAccount = null;
    let web3;
    let nftfanShop = null;
    function updateStatus(message, icon = "info") {
      document.getElementById('statusMsg').textContent = message;
      document.querySelector('.status-ic').textContent = icon;
    }
    function showError(elementId, message) {
      const errorEl = document.getElementById(elementId);
      errorEl.textContent = message;
      errorEl.style.display = 'block';
    }
    function hideError(elementId) { document.getElementById(elementId).style.display = 'none'; }
    async function connectWallet() {
      try {
        updateStatus('Connecting wallet...', "account_balance_wallet");
        if (!window.ethereum) throw new Error("Please install MetaMask or a compatible wallet!");
        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
        if (chainId !== POLYGON_PARAMS.chainId) {
          updateStatus('Switching to Polygon network...', "swap_horiz");
          try {
            await window.ethereum.request({
              method: 'wallet_switchEthereumChain',
              params: [{ chainId: POLYGON_PARAMS.chainId }],
            });
          } catch (switchError) {
            if (switchError.code === 4902) {
              await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [POLYGON_PARAMS],
              });
            } else { throw switchError; }
          }
        }
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        userAccount = accounts[0];
        document.getElementById("connect-btn-label").textContent = "Connected";
        document.getElementById("connect-btn").classList.add("connected");
        await setupContracts();
        updateStatus('Connected successfully', "check_circle");
        loadShopNFTs(); loadUserNFTs(); loadRecentListings();
      } catch (error) {
        updateStatus('Connection failed', "error");
        alert("Connection failed: " + error.message);
      }
    }
    async function setupContracts() {
      const rpcUrls = POLYGON_PARAMS.rpcUrls;
      let provider = null;
      if (window.ethereum) provider = window.ethereum;
      else {
        for (const rpcUrl of rpcUrls) {
          try {
            const testWeb3 = new Web3(rpcUrl);
            await testWeb3.eth.getBlockNumber();
            provider = rpcUrl;
            break;
          } catch (e) {}
        }
      }
      if (!provider) throw new Error('No working RPC provider found');
      web3 = new Web3(provider);
      nftfanShop = new web3.eth.Contract(NFTFAN_SHOP_ABI, NFTFAN_SHOP_CA);
    }
    async function fetchOpenSeaMeta(uri) {
      if (!uri) return null;
      try {
        if (uri.startsWith("ipfs://")) uri = "https://ipfs.io/ipfs/" + uri.replace("ipfs://", "");
        if (uri.startsWith("ar://")) uri = "https://arweave.net/" + uri.replace("ar://", "");
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 8000);
        const res = await fetch(uri, { mode: 'cors', signal: controller.signal });
        clearTimeout(timeoutId);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
        return await res.json();
      } catch (e) { return null; }
    }
    // --- SHOP TAB: Only show NFTs newly minted, available in shop (never sold yet, and not sold out!) ---
   async function loadShopNFTs() {
  const shopGrid = document.getElementById("shopGrid");
  const loading = document.getElementById("shop-loading");
  shopGrid.innerHTML = "";
  loading.style.display = "block";
  shopGrid.style.display = "none";
  hideError("shop-error");
  try {
    updateStatus('Loading shop NFTs...', "storefront");
    if (!nftfanShop) await setupContracts();
    const {ids, uris, prices, isForSale, shopAmounts, maxSupplies, currentSupplies} = await nftfanShop.methods.getShopNFTs().call();
    let html = "";
    let shown = 0;
    const metaArr = await Promise.all(uris.map(uri => fetchOpenSeaMeta(uri)));
    // Collect all user listings in parallel for efficiency
    const allListings = await Promise.all(ids.map(id => nftfanShop.methods.getListings(id).call()));
    for (let i = 0; i < ids.length; i++) {
      // Only show if: isForSale[i], shopAmounts[i]>0, currentSupply==maxSupply (never sold), shopAmounts==maxSupplies (never sold out), AND NO user listings!
      const userListings = (allListings[i] || []).filter(l => l.amount && l.amount !== "0");
      if (
        !isForSale[i] ||
        shopAmounts[i] == "0" ||
        currentSupplies[i] !== maxSupplies[i] ||
        shopAmounts[i] !== maxSupplies[i] ||
        userListings.length > 0 // Exclude any with user listings
      ) continue;
      shown++;
      const id = ids[i], meta = metaArr[i];
      const openseaName = meta?.name || `NFTFAN #${id}`;
      const openseaImg = meta?.image || uris[i] || "https://via.placeholder.com/110x110?text=NFT";
      const openseaDesc = meta?.description || "";
      const price = web3.utils.fromWei(prices[i], "ether");
      html += `<li class="card">
          <img class="card-img" src="${openseaImg}" alt="NFT ${openseaName}" onerror="this.src='https://via.placeholder.com/110x110?text=NFT'">
          <div class="card-title">${openseaName}</div>
          <div class="card-price"><span class="material-icons" style="font-size:1em;vertical-align:-1.5px;">paid</span> ${price} MATIC</div>
          <div class="card-id">ID: ${id}</div>
          ${openseaDesc ? `<div class="desc">${openseaDesc.substring(0, 34)}${openseaDesc.length > 34 ? '...' : ''}</div>` : ""}
          <div class="inventory">Available: ${shopAmounts[i]}</div>
          <div class="card-actions">
            <button class="buy-btn" onclick="buyNFT(${id}, '${prices[i]}', ${shopAmounts[i]})" ${!userAccount ? 'disabled' : ''}><span class='material-icons' style='font-size:1em;vertical-align:middle;'>shopping_cart</span> Buy</button>
          </div>
      </li>`;
    }
    if (shown === 0) {
      loading.textContent = "No new NFTs available in the shop.";
    } else {
      shopGrid.innerHTML = html;
      loading.style.display = "none";
      shopGrid.style.display = "grid";
    }
    updateStatus(shown ? `Shop loaded - ${shown} new NFTs` : "Shop loaded - no new NFTs", "storefront");
  } catch (error) {
    shopGrid.innerHTML = "";
    loading.style.display = "none";
    showError("shop-error", "Failed to load NFTs: " + error.message);
    updateStatus('Shop loading failed', "error");
  }
}
    // --- RECENTLY LISTED TAB ---
    async function loadRecentListings() {
      const grid = document.getElementById("recentListingsGrid");
      const loading = document.getElementById("recent-loading");
      grid.innerHTML = "";
      loading.style.display = "block";
      grid.style.display = "none";
      hideError("recent-error");
      try {
        updateStatus('Loading recently listed NFTs...', "bolt");
        if (!nftfanShop) await setupContracts();
        const shopData = await nftfanShop.methods.getShopNFTs().call();
        const { ids, uris } = shopData;
        let recentListings = [];
        for (let i = 0; i < ids.length; i++) {
          let tokenId = ids[i];
          let listings = await nftfanShop.methods.getListings(tokenId).call();
          listings.forEach(listing => {
            if (listing.amount && listing.amount !== "0" && (!userAccount || listing.seller.toLowerCase() !== userAccount.toLowerCase())) {
              recentListings.push({
                tokenId,
                uri: uris[i],
                seller: listing.seller,
                amount: listing.amount,
                price: listing.price
              });
            }
          });
        }
        recentListings.sort((a, b) => Number(b.price) - Number(a.price));
        recentListings = recentListings.slice(0, 20);
        if (!recentListings.length) {
          loading.textContent = "No recent user listings.";
          updateStatus("No recent user listings.", "bolt");
          return;
        }
        let metaArr = await Promise.all(recentListings.map(l => fetchOpenSeaMeta(l.uri)));
        let html = "";
        for (let i = 0; i < recentListings.length; i++) {
          const l = recentListings[i], meta = metaArr[i];
          const openseaName = meta?.name || `NFTFAN #${l.tokenId}`;
          const openseaImg = meta?.image || l.uri || "https://via.placeholder.com/110x110?text=NFT";
          const openseaDesc = meta?.description || "";
          html += `<li class="card recent-listing-card">
              <img class="card-img" src="${openseaImg}" alt="NFT ${openseaName}" onerror="this.src='https://via.placeholder.com/110x110?text=NFT'">
              <div class="card-title">${openseaName}</div>
              <div class="card-price"><span class="material-icons" style="font-size:1em;vertical-align:-1.5px;">paid</span> ${web3.utils.fromWei(l.price, "ether")} MATIC</div>
              <div class="card-id">ID: ${l.tokenId}</div>
              <div class="listing-seller"><span class="material-icons" style="font-size:1em;vertical-align:-1.5px;">person</span> ${formatAddress(l.seller)}</div>
              <div class="recent-listing-amount">Amount: ${l.amount}</div>
              ${openseaDesc ? `<div class="desc">${openseaDesc.substring(0,30)}${openseaDesc.length > 30 ? '...' : ''}</div>` : ""}
              <div class="card-actions">
                <button class="recent-listing-buy-btn" onclick="buyListedNFT(${l.tokenId}, '${l.price}', ${l.amount})" ${!userAccount ? 'disabled' : ''}><span class='material-icons' style='font-size:1em;vertical-align:middle;'>shopping_cart</span> Buy</button>
              </div>
          </li>`;
        }
        grid.innerHTML = html;
        loading.style.display = "none";
        grid.style.display = "grid";
        updateStatus(`Loaded ${recentListings.length} recent listings`, "bolt");
      } catch (error) {
        grid.innerHTML = "";
        loading.style.display = "none";
        showError("recent-error", "Failed to load recent listings: " + error.message);
        updateStatus('Recent listings loading failed', "error");
      }
    }
    async function buyListedNFT(tokenId, priceWei, amountMax) {
      if (!userAccount) { alert("Connect your wallet first!"); return; }
      let amount = 1;
      if (amountMax > 1) {
        let input = prompt(`How many from this listing would you like to buy? (max ${amountMax})`, "1");
        if (!input) return;
        amount = parseInt(input);
        if (isNaN(amount) || amount < 1 || amount > amountMax) {
          alert("Invalid amount"); return;
        }
      }
      try {
        updateStatus('Processing recent listing purchase...', "shopping_cart");
        await nftfanShop.methods.buyNFT(tokenId, amount).send({
          from: userAccount,
          value: (BigInt(priceWei) * BigInt(amount)).toString()
        });
        alert("NFT bought from user listing successfully!");
        updateStatus('User listing purchase successful', "check_circle");
        loadShopNFTs(); loadUserNFTs(); loadRecentListings();
      } catch (error) {
        updateStatus('Recent listing purchase failed', "error");
        alert("Purchase failed: " + error.message);
      }
    }
    async function loadUserNFTs() {
      const myGrid = document.getElementById("myGrid");
      const loading = document.getElementById("my-loading");
      myGrid.innerHTML = "";
      loading.style.display = "block";
      myGrid.style.display = "none";
      hideError("my-error");
      if (!userAccount) {
        loading.textContent = "Connect wallet to view your NFTs.";
        return;
      }
      try {
        updateStatus('Loading your NFTs...', "collections");
        if (!nftfanShop) await setupContracts();
        const tokens = await nftfanShop.methods.tokensOfOwner(userAccount).call();
        const { tokenIds, amounts } = tokens;
        if (!tokenIds.length) {
          loading.textContent = "You own no NFTs yet.";
          updateStatus('Your NFTs loaded - none found', "collections");
          return;
        }
        let metaArr = await Promise.all(tokenIds.map(async (id, index) => {
          try {
            let meta = await nftfanShop.methods.nftInfo(id).call();
            let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
            return {id, amount: amounts[index], meta, metaJson};
          } catch (e) {
            return {id, amount: amounts[index], meta: null, metaJson: null};
          }
        }));
        let html = "";
        for (let item of metaArr) {
          const {id, amount, meta, metaJson} = item;
          const openseaName = metaJson?.name || `NFTFAN #${id}`;
          const openseaImg = metaJson?.image || (meta?.tokenURI || "https://via.placeholder.com/110x110?text=NFT");
          const openseaDesc = metaJson?.description || "";
          html += `<li class="card nft-card">
              <img class="card-img" src="${openseaImg}" alt="NFT ${openseaName}" onerror="this.src='https://via.placeholder.com/110x110?text=NFT'">
              <div class="card-title">${openseaName}</div>
              <div class="card-id">ID: ${id}</div>
              ${openseaDesc ? `<div class="desc">${openseaDesc.substring(0,31)}${openseaDesc.length > 31 ? '...' : ''}</div>` : ""}
              <div class="inventory">You own: ${amount}</div>
              <div class="card-actions">
                <button class="sell-btn" onclick="openSellModal(${id}, ${amount})"><span class='material-icons' style='font-size:1em;vertical-align:middle;'>sell</span> Sell</button>
              </div>
          </li>`;
        }
        myGrid.innerHTML = html;
        loading.style.display = "none";
        myGrid.style.display = "grid";
        updateStatus(`Your NFTs loaded - ${tokenIds.length} found`, "collections");
      } catch (error) {
        myGrid.innerHTML = "";
        loading.style.display = "none";
        showError("my-error", "Failed to load your NFTs: " + error.message);
        updateStatus('Your NFTs loading failed', "error");
      }
    }
    let sellModalTokenId = null, sellModalMaxAmount = null;
    function openSellModal(tokenId, maxAmount) {
      sellModalTokenId = tokenId;
      sellModalMaxAmount = maxAmount;
      document.getElementById("sellModal").style.display = "flex";
      document.getElementById("sellTokenId").textContent = tokenId;
      document.getElementById("sellMaxAmount").textContent = maxAmount;
      document.getElementById("sellAmountInput").value = "";
      document.getElementById("sellAmountInput").max = maxAmount;
      document.getElementById("sellPriceInput").value = "";
      document.getElementById("sellModalError").textContent = "";
    }
    function closeSellModal() {
      document.getElementById("sellModal").style.display = "none";
      sellModalTokenId = null;
      sellModalMaxAmount = null;
    }
    async function confirmSellNFT() {
      const amount = parseInt(document.getElementById("sellAmountInput").value);
      const price = document.getElementById("sellPriceInput").value;
      document.getElementById("sellModalError").textContent = "";
      if (!userAccount) {
        document.getElementById("sellModalError").textContent = "Connect your wallet first!";
        return;
      }
      if (!amount || isNaN(amount) || amount < 1 || amount > sellModalMaxAmount) {
        document.getElementById("sellModalError").textContent = "Invalid amount!";
        return;
      }
      if (!price || isNaN(price) || Number(price) <= 0) {
        document.getElementById("sellModalError").textContent = "Invalid price!";
        return;
      }
      let priceWei = "0";
      try { priceWei = web3.utils.toWei(price, "ether"); }
      catch (e) {
        document.getElementById("sellModalError").textContent = "Invalid price."; return;
      }
      try {
        updateStatus('Processing sale...', "sell");
        await nftfanShop.methods.sellNFT(sellModalTokenId, amount, priceWei).send({ from: userAccount });
        alert("NFT listed in shop successfully!");
        updateStatus('Sale listing successful', "check_circle");
        closeSellModal();
        loadShopNFTs(); loadUserNFTs(); loadRecentListings();
      } catch (error) {
        updateStatus('Sale listing failed', "error");
        document.getElementById("sellModalError").textContent = "Sale failed: " + error.message;
      }
    }
    async function buyNFT(tokenId, priceWei, availableAmount) {
      if (!userAccount) { alert("Connect your wallet first!"); return; }
      let amount = 1;
      if (availableAmount > 1) {
        let input = prompt(`How many would you like to buy? (max ${availableAmount})`, "1");
        if (!input) return;
        amount = parseInt(input);
        if (isNaN(amount) || amount < 1 || amount > availableAmount) {
          alert("Invalid amount"); return;
        }
      }
      try {
        updateStatus('Processing purchase...', "shopping_cart");
        await nftfanShop.methods.buyNFT(tokenId, amount).send({
          from: userAccount,
          value: (BigInt(priceWei) * BigInt(amount)).toString()
        });
        alert("NFT bought successfully! It will appear in 'My NFTs'");
        updateStatus('Purchase successful', "check_circle");
        loadShopNFTs(); loadUserNFTs(); loadRecentListings();
      } catch (error) {
        updateStatus('Purchase failed', "error");
        alert("Purchase failed: " + error.message);
      }
    }
    function showTab(tab) {
      document.getElementById('tab-content-shop').style.display = 'none';
      document.getElementById('tab-content-mynfts').style.display = 'none';
      document.getElementById('tab-content-recent').style.display = 'none';
      document.getElementById(`tab-content-${tab}`).style.display = 'block';
      document.getElementById('tab-shop').classList.remove('active');
      document.getElementById('tab-mynfts').classList.remove('active');
      document.getElementById('tab-recent').classList.remove('active');
      document.getElementById(`tab-${tab}`).classList.add('active');
      if (tab === 'shop') loadShopNFTs();
      else if (tab === 'recent') loadRecentListings();
      else if (tab === 'mynfts') loadUserNFTs();
    }
    function formatAddress(address) {
      if (!address) return '';
      return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }
    if (window.ethereum) {
      window.ethereum.on('accountsChanged', function (accounts) {
        userAccount = accounts[0] || null;
        document.getElementById("connect-btn-label").textContent = userAccount ? "Connected" : "Connect Wallet";
        if (userAccount) {
          setupContracts().then(() => {
            loadShopNFTs(); loadUserNFTs(); loadRecentListings();
            updateStatus('Account changed - reloaded', "info");
          }).catch(e => { updateStatus('Account change failed', "error"); });
        } else {
          updateStatus('Wallet disconnected', "account_balance_wallet");
        }
      });
      window.ethereum.on('chainChanged', function (chainId) {
        updateStatus('Network changed - reconnecting...', "swap_horiz");
        setupContracts().then(() => {
          loadShopNFTs(); loadUserNFTs(); loadRecentListings();
          updateStatus('Network changed - reloaded', "info");
        }).catch(e => {
          updateStatus('Network change failed', "error");
        });
      });
    }
    window.addEventListener("DOMContentLoaded", async () => {
      try {
        updateStatus('Initializing application...', "info");
        await setupContracts();
        await loadShopNFTs();
        updateStatus('Application ready', "check_circle");
      } catch (error) {
        updateStatus('Initialization failed', "error");
        showError('shop-error', 'Failed to initialize the application. Please check your internet connection and try refreshing the page.');
      }
    });
    window.onclick = function(event) {
      const modal = document.getElementById("sellModal");
      if (event.target === modal) closeSellModal();
    };
  </script>
</body>
</html>
