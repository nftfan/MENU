<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NFTFAN Airdrop Tool</title>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Inter:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <style>
    :root {
      --primary: #00fff7;
      --accent: #fc00ff;
      --bg: #10101a;
      --card: #181825;
      --text: #e3e9fc;
      --muted: #6ce8ff;
      --button: linear-gradient(90deg,#fc00ff,#00dbde,#2017fc);
      --button-text: #fff;
      --border: #4d3be9;
      --radius: 14px;
      --font-size: 12px;
      --wallet-font: 9px;
      --glass: rgba(38,41,57,0.72);
      --glow: 0 0 8px #00fff7, 0 0 24px #2017fc;
      --bar-bg: #181a2c;
      --bar-fill: linear-gradient(90deg, #00fff7, #fc00ff, #5efcf5);
      --notif-bg: #1a0027cc;
      --notif-shadow: 0 0 16px #fc00ff99;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Share Tech Mono', 'Inter', Arial, sans-serif;
      font-size: var(--font-size);
      box-sizing: border-box;
      min-height: 100vh;
      letter-spacing: 0.02em;
      background: radial-gradient(ellipse at 60% 5%, #2e2a63 18%, #10101a 85%);
      overflow-x: hidden;
    }
    .container {
      max-width: 440px;
      margin: 0 auto;
      padding: 20px 10px 40px 10px;
      position: relative;
      z-index: 2;
    }
    .card {
      background: var(--glass);
      border-radius: var(--radius);
      box-shadow: var(--glow), 0 2px 14px #0002;
      padding: 20px 16px 20px 16px;
      margin-bottom: 18px;
      border: 2px solid var(--border);
      backdrop-filter: blur(6px);
      position: relative;
      overflow: hidden;
    }
    h1 {
      font-size: 1.08em;
      margin: 0 0 18px 0;
      font-weight: 700;
      letter-spacing: 0.05em;
      color: var(--primary);
      text-align: center;
      text-shadow: 0 0 6px #00fff7, 0 0 20px #fc00ff44;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 13px;
      flex-wrap: wrap;
      gap: 8px;
    }
    .wallet-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .score-display {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 120px;
    }
    .btn {
      background: var(--button);
      border: none;
      color: var(--button-text);
      border-radius: 10px;
      padding: 8px 17px;
      font-size: var(--font-size);
      font-weight: 700;
      cursor: pointer;
      margin-right: 4px;
      margin-bottom: 4px;
      box-shadow: 0 0 8px #00fff7, 0 0 14px #fc00ff55;
      outline: none;
      transition: background 0.2s, box-shadow 0.2s, transform 0.14s;
      text-shadow: 0 0 4px #fc00ffbb;
      letter-spacing: 0.07em;
      position: relative;
    }
    .btn:active, .btn:focus {
      box-shadow: 0 0 24px #00fff7;
      transform: scale(0.97);
      background: linear-gradient(90deg, #2017fc, #00fff7);
    }
    .btn[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
      filter: grayscale(0.6) brightness(0.8);
    }
    .btn-disconnect {
      background: #320040;
      color: #fff;
      margin-right: 0;
      box-shadow: 0 0 6px #fc00ff,0 0 10px #2017fc22;
      text-shadow: none;
      font-weight: 400;
    }
    .btn-refresh {
      background: linear-gradient(90deg, #00fff7 30%, #2017fc 90%);
      font-size: 8px;
      padding: 4px 10px;
      margin: 1px 0 0 0;
      border-radius: 8px;
      box-shadow: 0 0 7px #00fff799;
      color: #181825;
      font-weight: 700;
      letter-spacing: 0.04em;
    }
    textarea {
      width: 100%;
      min-height: 90px;
      font-size: var(--font-size);
      border-radius: 8px;
      border: 1.5px solid var(--border);
      background: #0a0a13b8;
      color: var(--text);
      padding: 10px 8px;
      margin-bottom: 8px;
      resize: vertical;
      font-family: 'Share Tech Mono', 'Inter', Arial, sans-serif;
      box-sizing: border-box;
      outline: none;
      transition: border 0.18s;
      box-shadow: 0 0 2px #00fff7cc;
    }
    textarea:focus {
      border: 2.2px solid var(--primary);
      background: #121229d9;
      box-shadow: 0 0 8px #00fff7cc;
    }
    .wallet-list {
      background: var(--bar-bg);
      border-radius: 8px;
      padding: 8px 6px;
      max-height: 120px;
      overflow-y: auto;
      font-size: var(--wallet-font);
      margin-bottom: 7px;
      color: var(--muted);
      word-break: break-all;
      border: 1px solid #2323e355;
      box-shadow: 0 0 6px #00fff733;
    }
    .filter-info {
      margin: 7px 0 7px 0;
      color: var(--muted);
      font-size: var(--font-size);
      text-shadow: 0 0 3px #fc00ff33;
      letter-spacing: 0.04em;
    }
    .progress-bar-bg {
      width: 100%;
      height: 12px;
      background: var(--bar-bg);
      border-radius: 8px;
      margin: 12px 0 10px 0;
      overflow: hidden;
      box-shadow: 0 0 7px #00fff799;
      border: 1px solid #2222e355;
    }
    .progress-bar-fill {
      height: 100%;
      background: var(--bar-fill);
      width: 0%;
      transition: width 0.7s cubic-bezier(.7,.2,.3,.9);
      box-shadow: 0 0 12px #00fff7, 0 0 14px #fc00ff;
    }
    .score-bar {
      background: #0d0e18c0;
      border-radius: 8px;
      padding: 9px 12px;
      text-align: center;
      color: var(--primary);
      font-weight: 700;
      font-size: 1em;
      letter-spacing: 0.01em;
      box-shadow: 0 0 12px #00fff777;
      border: 1px solid #00fff7cc;
      text-shadow: 0 0 6px #00fff7;
      margin-bottom: 4px;
    }
    .contract-info {
      font-size: var(--wallet-font);
      color: var(--muted);
      text-align: center;
      margin: 8px 0 0 0;
      word-break: break-all;
      border: 1.5px solid #2323e355;
      box-shadow: 0 0 8px #fc00ff44;
      background: #181829aa;
      letter-spacing: 0.03em;
    }
    .status-message, .error-message, .gas-info {
      border-radius: 10px;
      padding: 10px 14px;
      margin: 12px 0 8px 0;
      font-size: var(--font-size);
      text-align: center;
      box-shadow: var(--notif-shadow);
      border: 1.5px solid #00fff799;
      display: none;
      position: relative;
      z-index: 100;
      font-family: 'Share Tech Mono', 'Inter', Arial, sans-serif;
      animation: notifFadeIn 0.5s;
    }
    .status-message {
      background: var(--notif-bg);
      color: #5efcf5;
      border-color: #00fff7;
      text-shadow: 0 0 8px #00fff7bb;
    }
    .error-message {
      background: #27001aee;
      color: #ff6ce9;
      border-color: #fc00ff;
      text-shadow: 0 0 8px #fc00ffbb;
    }
    .gas-info {
      background: #01181a99;
      color: #5efcf5;
      border-color: #00fff7;
      text-shadow: 0 0 6px #00fff7cc;
      margin-bottom: 0;
      font-size: 10px;
    }
    .notif-anim {
      animation: notifBounce 0.3s;
    }
    @keyframes notifBounce {
      0% { transform: scale(0.8);}
      50% { transform: scale(1.04);}
      100% { transform: scale(1);}
    }
    @keyframes notifFadeIn {
      from { opacity: 0;}
      to { opacity: 1;}
    }
    .processing-overlay {
      background: #120824ea;
      position: fixed;
      inset: 0;
      z-index: 9000;
      display: none;
      place-items: center;
      transition: opacity 0.2s;
    }
    .processing-box {
      background: #23223aee;
      border-radius: 16px;
      border: 2.5px solid #00fff799;
      box-shadow: 0 0 40px #fc00ff44, 0 0 16px #00fff7;
      padding: 32px 40px 26px 40px;
      text-align: center;
      min-width: 220px;
      min-height: 80px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .processing-anim {
      margin: 0 auto 18px auto;
      width: 54px;
      height: 54px;
      border: 6px solid #00fff7;
      border-top: 6px solid #fc00ff;
      border-radius: 50%;
      animation: spinAnim 1.2s linear infinite;
      box-shadow: 0 0 24px #fc00ff99, 0 0 16px #00fff7;
    }
    @keyframes spinAnim {
      0% { transform: rotate(0);}
      100% { transform: rotate(360deg);}
    }
    .processing-text {
      color: #00fff7;
      font-size: 1.08em;
      font-weight: 700;
      margin-top: 5px;
      letter-spacing: 0.03em;
      text-shadow: 0 0 8px #00fff7aa;
      text-align: center;
    }
    .processing-sub {
      color: #fc00ff;
      font-size: 10px;
      margin-top: 8px;
      letter-spacing: 0.02em;
      text-shadow: 0 0 8px #fc00ffbb;
    }
    .card:before {
      content: "";
      z-index: 0;
      pointer-events: none;
      position: absolute;
      inset: -2px;
      border-radius: var(--radius);
      background: conic-gradient(from 0deg, #fc00ff, #00fff7, #2017fc, #fc00ff 60%, #00fff7 100%);
      filter: blur(4px);
      opacity: 0.25;
      transition: opacity 0.22s;
      animation: borderGlow 6s linear infinite;
    }
    @keyframes borderGlow {
      to { filter: blur(6px) hue-rotate(360deg);}
    }
    @media (max-width: 600px) {
      .container {
        padding: 6px 2px 22px 2px;
      }
      .card {
        padding: 10px;
      }
      h1 {
        font-size: 0.97em;
      }
      .btn {
        padding: 7px 8px;
      }
      .score-bar {
        font-size: 0.93em;
      }
      .top-bar {
        flex-direction: column;
        align-items: stretch;
      }
      .score-display {
        align-items: center;
        min-width: auto;
      }
      .processing-box {
        min-width: 130px;
        padding: 20px 8px 18px 8px;
      }
      .processing-anim {
        width: 33px; height: 33px; border-width: 4px;
      }
    }
    .bg-cyber {
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      overflow: hidden;
    }
    .cyber-glow1, .cyberciting-glow2, .cyber-glow3 {
      position: absolute; border-radius: 50%;
      filter: blur(60px);
      opacity: 0.22;
      z-index: 1;
    }
    .cyber-glow1 { width: 320px; height: 320px; background: #00fff7; left: -80px; top: -120px;}
    .cyber-glow2 { width: 180px; height: 180px; background: #fc00ff; right: -80px; top: 340px;}
    .cyber-glow3 { width: 150px; height: 150px; background: #2017fc; left: 45%; top: 87vh;}
  </style>
</head>
<body>
  <div class="bg-cyber">
    <div class="cyber-glow1"></div>
    <div class="cyber-glow2"></div>
    <div class="cyber-glow3"></div>
  </div>
  <div class="container">
    <div class="top-bar">
      <div class="wallet-controls">
        <button class="btn" id="connectWalletBtn"><i class="fa-solid fa-wallet"></i> Connect Wallet</button>
        <button class="btn btn-disconnect" id="disconnectWalletBtn" style="display:none;"><i class="fa-solid fa-power-off"></i></button>
      </div>
      <div class="score-display">
        <div class="score-bar">
          <i class="fa-solid fa-star"></i> My Score: <span id="myScore">0</span>
        </div>
        <button class="btn btn-refresh" id="refreshScoreBtn" style="display:none;"><i class="fa-solid fa-rotate"></i> Refresh</button>
      </div>
    </div>
    <div class="status-message" id="statusMessage"></div>
    <div class="error-message" id="errorMessage"></div>
    <div class="card">
      <h1><i class="fa-brands fa-ethereum"></i> NFTFAN Airdrop</h1>
      <div class="filter-info">Paste any text with wallet addresses below:</div>
      <textarea id="walletInput" placeholder="Paste addresses here (comma, space, newline, or mixed)"></textarea>
      <button class="btn" id="filterBtn"><i class="fa-solid fa-filter"></i> Filter Wallets</button>
      <div class="filter-info">
        <span id="walletCount">0</span> wallets filtered
      </div>
      <div class="wallet-list" id="walletList"></div>
      <div class="gas-info" id="gasInfo">
        <i class="fa-solid fa-gas-pump"></i> Estimated Gas: <span id="gasEstimate">Calculating...</span>
      </div>
      <div class="progress-bar-bg"><div class="progress-bar-fill" id="progressBar"></div></div>
      <button class="btn" id="airdropBtn" disabled><i class="fa-solid fa-paper-plane"></i> Send Airdrop</button>
    </div>
    <div class="card contract-info">
      <i class="fa-solid fa-coins"></i> NFTFAN Token: <span id="tokenCA">0x2017Fcaea540d2925430586DC92818035Bfc2F50</span><br>
      <i class="fa-solid fa-vault"></i> Distributor: <span id="airdropCA">0x664d25959EcCabc3e04A4Dc9D1f5ca5dDE82a5d5</span>
    </div>
  </div>
  <div class="processing-overlay" id="processingOverlay">
    <div class="processing-box">
      <div class="processing-anim"></div>
      <div class="processing-text" id="processingText">Processing...</div>
      <div class="processing-sub" id="processingSub"></div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script>
    // CONFIG
    const POLYGON_PARAMS = {
      chainId: "0x89",
      chainName: "Polygon Mainnet",
      nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
      rpcUrls: ["https://polygon-rpc.com", "https://rpc.ankr.com/polygon"],
      blockExplorerUrls: ["https://polygonscan.com/"]
    };
    const NFTFAN_TOKEN_CA = "0x2017Fcaea540d2925430586DC92818035Bfc2F50";
    const AIRDROP_CONTRACT_CA = "0x664d25959EcCabc3e04A4Dc9D1f5ca5dDE82a5d5";
    const AIRDROP_ABI = [
      "function distributeTokens(address[] calldata recipients) external",
      "function userScores(address) public view returns (uint256)"
    ];
    const BATCH_SIZE = 25;
    const MAX_GAS_LIMIT = 8000000;

    // DOM elements
    const connectWalletBtn = document.getElementById('connectWalletBtn');
    const disconnectWalletBtn = document.getElementById('disconnectWalletBtn');
    const filterBtn = document.getElementById('filterBtn');
    const airdropBtn = document.getElementById('airdropBtn');
    const refreshScoreBtn = document.getElementById('refreshScoreBtn');
    const walletInput = document.getElementById('walletInput');
    const walletList = document.getElementById('walletList');
    const walletCount = document.getElementById('walletCount');
    const progressBar = document.getElementById('progressBar');
    const myScore = document.getElementById('myScore');
    const statusMessage = document.getElementById('statusMessage');
    const errorMessage = document.getElementById('errorMessage');
    const gasInfo = document.getElementById('gasInfo');
    const gasEstimate = document.getElementById('gasEstimate');
    const processingOverlay = document.getElementById('processingOverlay');
    const processingText = document.getElementById('processingText');
    const processingSub = document.getElementById('processingSub');

    // App state
    let provider, signer, userAddress, contract;
    let filteredWallets = [];
    let airdropInProgress = false;
    let scoreRefreshInterval;

    // Notifications
    function showStatus(message, sub = "") {
      statusMessage.innerHTML = message + (sub ? `<br><small>${sub}</small>` : '');
      statusMessage.classList.add('notif-anim');
      statusMessage.style.display = 'block';
      errorMessage.style.display = 'none';
      setTimeout(() => {
        statusMessage.classList.remove('notif-anim');
        statusMessage.style.display = 'none';
      }, 4400);
    }
    function showError(message) {
      errorMessage.innerHTML = message;
      errorMessage.classList.add('notif-anim');
      errorMessage.style.display = 'block';
      statusMessage.style.display = 'none';
      setTimeout(() => {
        errorMessage.classList.remove('notif-anim');
        errorMessage.style.display = 'none';
      }, 7000);
    }
    function showProcessing(msg, sub = "") {
      processingText.textContent = msg;
      processingSub.textContent = sub;
      processingOverlay.style.display = "grid";
    }
    function hideProcessing() {
      processingOverlay.style.display = "none";
      processingText.textContent = "";
      processingSub.textContent = "";
    }

    // Wallet handling
    function isWallet(addr) {
      return /^0x[a-fA-F0-9]{40}$/.test(addr);
    }
    function extractWallets(text) {
      const matches = text.match(/0x[a-fA-F0-9]{40}/g) || [];
      return Array.from(new Set(matches.map(a => ethers.utils.getAddress(a.toLowerCase()))));
    }
    function showWallets(wallets) {
      walletList.innerHTML = wallets.slice(0, 200).map(w => 
        `<div style="font-size:9px;line-height:1.1;margin-bottom:2px">${w}</div>`
      ).join('') + (wallets.length > 200 ? `<div style="color:#fc00ff;">...and ${wallets.length-200} more</div>` : '');
      walletCount.textContent = wallets.length;
    }

    async function estimateGasForBatch(recipients) {
      if (!contract || recipients.length === 0) return ethers.BigNumber.from('0');
      try {
        return await contract.estimateGas.distributeTokens(recipients);
      } catch {
        return ethers.BigNumber.from(100000 + (recipients.length * 50000));
      }
    }
    async function updateGasEstimate() {
      if (!filteredWallets.length || !contract) {
        gasInfo.style.display = 'none';
        return;
      }
      gasInfo.style.display = 'block';
      gasEstimate.textContent = 'Calculating...';
      try {
        const sampleBatch = filteredWallets.slice(0, Math.min(BATCH_SIZE, filteredWallets.length));
        const gasForBatch = await estimateGasForBatch(sampleBatch);
        const totalBatches = Math.ceil(filteredWallets.length / BATCH_SIZE);
        const totalGasEstimate = gasForBatch.mul(totalBatches);
        const gasPrice = await provider.getGasPrice();
        const totalCost = totalGasEstimate.mul(gasPrice);
        gasEstimate.innerHTML = `<span style="color:#fc00ff">${ethers.utils.formatUnits(totalCost, 'ether').slice(0, 8)} MATIC</span>
          <span style="color:#00fff7;font-size:9px;"> (${totalBatches} batches)</span>`;
      } catch {
        gasEstimate.textContent = 'Unable to estimate';
      }
    }

    filterBtn.onclick = async () => {
      try {
        filteredWallets = extractWallets(walletInput.value).filter(addr => {
          try {
            ethers.utils.getAddress(addr);
            return true;
          } catch {
            return false;
          }
        });
        showWallets(filteredWallets);
        await updateGasEstimate();
        airdropBtn.disabled = !filteredWallets.length || !signer || airdropInProgress;
        if (filteredWallets.length) showStatus(`ðŸŽ¯ Filtered ${filteredWallets.length} valid wallet addresses`);
      } catch (error) {
        showError('Error filtering wallets: ' + error.message);
      }
    };

    async function checkNetwork() {
      if (!window.ethereum) return false;
      const chainId = await window.ethereum.request({ method: 'eth_chainId' });
      return chainId === POLYGON_PARAMS.chainId;
    }

    connectWalletBtn.onclick = async () => {
      if (!window.ethereum) {
        showError('Please install MetaMask or a compatible Web3 wallet!');
        return;
      }
      showProcessing('Checking network...', 'Ensuring Polygon Mainnet');
      if (!await checkNetwork()) {
        hideProcessing();
        showError('Please switch to Polygon network in your wallet.');
        return;
      }
      try {
        showProcessing('Connecting wallet...', 'Please approve in your wallet');
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
        connectWalletBtn.innerHTML = `<i class="fa-solid fa-wallet"></i> ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
        connectWalletBtn.disabled = true;
        disconnectWalletBtn.style.display = "";
        refreshScoreBtn.style.display = "";
        await updateScore();
        startScoreRefresh();
        if (filteredWallets.length) await updateGasEstimate();
        airdropBtn.disabled = !filteredWallets.length || airdropInProgress;
        hideProcessing();
        showStatus('âœ… Wallet connected successfully!');
      } catch (err) {
        hideProcessing();
        showError("âŒ Wallet connection failed: " + (err.message || 'Unknown error'));
      }
    };

    disconnectWalletBtn.onclick = () => {
      stopScoreRefresh();
      provider = signer = userAddress = contract = null;
      connectWalletBtn.innerHTML = '<i class="fa-solid fa-wallet"></i> Connect Wallet';
      connectWalletBtn.disabled = false;
      disconnectWalletBtn.style.display = "none";
      refreshScoreBtn.style.display = "none";
      myScore.textContent = "0";
      airdropBtn.disabled = true;
      gasInfo.style.display = 'none';
      showStatus('Disconnected wallet');
    };

    async function updateScore() {
      if (!contract || !userAddress) return myScore.textContent = "0";
      try {
        const score = await contract.userScores(userAddress);
        myScore.textContent = score.toString();
      } catch {
        myScore.textContent = "Error";
      }
    }
    function startScoreRefresh() {
      stopScoreRefresh();
      scoreRefreshInterval = setInterval(updateScore, 30000);
    }
    function stopScoreRefresh() {
      if (scoreRefreshInterval) clearInterval(scoreRefreshInterval);
    }
    refreshScoreBtn.onclick = async () => {
      refreshScoreBtn.disabled = true;
      refreshScoreBtn.innerHTML = '<i class="fa-solid fa-rotate"></i> ...';
      await updateScore();
      setTimeout(() => {
        refreshScoreBtn.disabled = false;
        refreshScoreBtn.innerHTML = '<i class="fa-solid fa-rotate"></i> Refresh';
      }, 1400);
    };

    async function performPreflightChecks(batch) {
      const checks = { balance: false, gasPrice: false, contract: false, network: false };
      try {
        const balance = await signer.getBalance();
        const gasPrice = await provider.getGasPrice();
        const estimatedGas = await estimateGasForBatch(batch);
        const requiredGas = estimatedGas.mul(gasPrice);
        checks.balance = balance.gte(requiredGas);
        checks.gasPrice = gasPrice.lt(ethers.utils.parseUnits('100', 'gwei'));
        checks.contract = (await provider.getCode(AIRDROP_CONTRACT_CA)) !== '0x';
        checks.network = (await provider.getNetwork()).chainId === 137;
        return {
          passed: Object.values(checks).every(Boolean),
          details: checks,
          balance,
          requiredGas,
          gasPrice
        };
      } catch (error) {
        return { passed: false, error: error.message, details: checks };
      }
    }
    function getDetailedError(error) {
      const code = error.code || '';
      const msg = error.message || error.reason || '';
      return {
        'INSUFFICIENT_FUNDS': 'Insufficient MATIC for gas fees',
        'UNPREDICTABLE_GAS_LIMIT': 'Cannot estimate gas - check contract or token balance',
        'CALL_EXCEPTION': 'Contract call failed - verify permissions/tokens',
        'NETWORK_ERROR': 'Network connection issue',
        'TIMEOUT': 'Transaction timed out - network may be busy'
      }[code] || (msg.includes('insufficient funds') ? 'Insufficient MATIC for gas fees' :
        msg.includes('gas required exceeds') ? 'Too much gas required - reduce batch size' :
        msg.includes('execution reverted') ? (msg.includes('Ownable') ? 'Access denied' :
        msg.includes('ERC20') ? 'Token transfer failed - insufficient tokens' :
        'Contract execution failed: ' + (msg.split('execution reverted: ')[1] || 'unknown reason')) :
        msg.includes('nonce') ? 'Nonce error - reset wallet and retry' :
        msg.includes('replacement transaction underpriced') ? 'Gas price too low - increase and retry' :
        msg || 'Unknown error');
    }

    airdropBtn.onclick = async () => {
      if (!signer || !contract || !filteredWallets.length || airdropInProgress) return;
      showProcessing('Running checks...', 'Verifying wallet and network');
      const testBatch = filteredWallets.slice(0, Math.min(5, filteredWallets.length));
      const preflight = await performPreflightChecks(testBatch);
      hideProcessing();
      if (!preflight.passed) {
        let errorMsg = 'Checks failed:<br>';
        if (preflight.error) errorMsg += preflight.error;
        else {
          if (!preflight.details.balance) errorMsg += 'â€¢ Insufficient MATIC<br>';
          if (!preflight.details.contract) errorMsg += 'â€¢ Invalid contract<br>';
          if (!preflight.details.network) errorMsg += 'â€¢ Switch to Polygon<br>';
          if (!preflight.details.gasPrice) errorMsg += 'â€¢ Gas price too high<br>';
        }
        showError(errorMsg);
        return;
      }
      const balance = ethers.utils.formatEther(preflight.balance).slice(0, 8);
      const required = ethers.utils.formatEther(preflight.requiredGas).slice(0, 8);
      if (!confirm(`Send airdrop to ${filteredWallets.length} wallets?\n\nBatches: ${Math.ceil(filteredWallets.length / BATCH_SIZE)}\nYour MATIC: ${balance}\nEst. Required: ${required}\n\nContinue?`)) return;
      airdropInProgress = true;
      airdropBtn.disabled = filterBtn.disabled = true;
      let total = filteredWallets.length, done = 0, failed = 0;
      progressBar.style.width = "0%";
      showProcessing('Starting airdrop...', 'Processing transactions');
      try {
        for (let i = 0; i < total; i += BATCH_SIZE) {
          const batch = filteredWallets.slice(i, i + BATCH_SIZE);
          const batchNum = Math.floor(i / BATCH_SIZE) + 1;
          const totalBatches = Math.ceil(total / BATCH_SIZE);
          showProcessing(`Batch ${batchNum}/${totalBatches}`, `Processing ${batch.length} addresses`);
          try {
            const gasEstimate = await estimateGasForBatch(batch);
            const gasLimit = gasEstimate.gt(MAX_GAS_LIMIT) ? null : gasEstimate.mul(130).div(100);
            if (!gasLimit) {
              showError(`Batch ${batchNum} exceeds gas limit (${gasEstimate.toString()}). Skipping...`);
              failed += batch.length;
              continue;
            }
            const gasPrice = (await provider.getGasPrice()).mul(110).div(100);
            showProcessing(`Sending batch ${batchNum}...`, `Awaiting signature`);
            const tx = await contract.distributeTokens(batch, { gasLimit, gasPrice });
            showProcessing(`Batch ${batchNum} sent`, `Confirming...`);
            const receipt = await Promise.race([
              tx.wait(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 300000))
            ]);
            if (receipt.status === 1) {
              done += batch.length;
              progressBar.style.width = (100 * (done + failed) / total).toFixed(1) + "%";
              await updateScore();
              showStatus(`âœ… Batch ${batchNum} done!`, `Processed ${done}/${total}`);
              if (batchNum < totalBatches) await new Promise(r => setTimeout(r, 1200));
            } else throw new Error('Transaction failed');
          } catch (batchError) {
            failed += batch.length;
            const errorDetail = getDetailedError(batchError);
            if (batchError.code === 'INSUFFICIENT_FUNDS' || batchError.message?.includes('nonce')) {
              showError(`Batch ${batchNum} failed: ${errorDetail}<br>Stopping...`);
              break;
            }
            showError(`Batch ${batchNum} failed: ${errorDetail}<br>Continuing...`);
            progressBar.style.width = (100 * (done + failed) / total).toFixed(1) + "%";
            await new Promise(r => setTimeout(r, 2200));
          }
        }
        progressBar.style.width = "100%";
        hideProcessing();
        showStatus(done > 0 && !failed ? `ðŸŽ‰ Airdrop completed! All ${done} processed.` :
          done > 0 ? `âš ï¸ Partial success: ${done} done, ${failed} failed` :
          `âŒ Airdrop failed. No addresses processed.`);
      } catch (error) {
        hideProcessing();
        showError(`Airdrop failed: ${getDetailedError(error)}`);
      }
      airdropInProgress = false;
      airdropBtn.disabled = !filteredWallets.length || !signer;
      filterBtn.disabled = false;
    };

    if (window.ethereum) {
      window.ethereum.on('accountsChanged', async accounts => {
        if (accounts.length) {
          try {
            provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            signer = provider.getSigner();
            userAddress = accounts[0];
            contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
            connectWalletBtn.innerHTML = `<i class="fa-solid fa-wallet"></i> ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
            connectWalletBtn.disabled = true;
            disconnectWalletBtn.style.display = "";
            refreshScoreBtn.style.display = "";
            await updateScore();
            startScoreRefresh();
            if (filteredWallets.length) await updateGasEstimate();
            airdropBtn.disabled = !filteredWallets.length || airdropInProgress;
            showStatus('âœ… Account switched');
          } catch (error) {
            showError('Account switch failed: ' + error.message);
          }
        } else disconnectWalletBtn.onclick();
      });
      window.ethereum.on('chainChanged', chainId => {
        if (chainId !== POLYGON_PARAMS.chainId) {
          showError("Wrong network detected. Please switch to Polygon.");
          disconnectWalletBtn.onclick();
        }
      });
    }

    showWallets([]);
    airdropBtn.disabled = true;
    filterBtn.disabled = false;

    window.addEventListener('DOMContentLoaded', async () => {
      if (window.ethereum && window.ethereum.selectedAddress && await checkNetwork()) {
        showProcessing('Auto-connecting...', 'Checking wallet');
        try {
          provider = new ethers.providers.Web3Provider(window.ethereum, "any");
          signer = provider.getSigner();
          userAddress = await signer.getAddress();
          contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
          connectWalletBtn.innerHTML = `<i class="fa-solid fa-wallet"></i> ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
          connectWalletBtn.disabled = true;
          disconnectWalletBtn.style.display = "";
          refreshScoreBtn.style.display = "";
          await updateScore();
          startScoreRefresh();
          airdropBtn.disabled = !filteredWallets.length || airdropInProgress;
          hideProcessing();
          showStatus('Wallet auto-connected');
        } catch {
          hideProcessing();
        }
      }
    });
  </script>
</body>
</html>
