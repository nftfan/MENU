<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NFTFAN Airdrop Tool</title>
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Inter:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <style>
    :root {
      --primary: #00fff7;
      --accent: #fc00ff;
      --bg: #10101a;
      --card: #181825;
      --text: #e3e9fc;
      --muted: #6ce8ff;
      --button: linear-gradient(90deg,#fc00ff,#00dbde,#2017fc);
      --button-text: #fff;
      --border: #4d3be9;
      --radius: 14px;
      --font-size: 12px;
      --wallet-font: 9px;
      --glass: rgba(38,41,57,0.72);
      --glow: 0 0 8px #00fff7, 0 0 24px #2017fc;
      --bar-bg: #181a2c;
      --bar-fill: linear-gradient(90deg, #00fff7, #fc00ff, #5efcf5);
      --notif-bg: #1a0027cc;
      --notif-shadow: 0 0 16px #fc00ff99;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Share Tech Mono', 'Inter', Arial, sans-serif;
      font-size: var(--font-size);
      box-sizing: border-box;
      min-height: 100vh;
      letter-spacing: 0.02em;
      background: radial-gradient(ellipse at 60% 5%, #2e2a63 18%, #10101a 85%);
      overflow-x: hidden;
    }
    .container {
      max-width: 440px;
      margin: 0 auto;
      padding: 20px 10px 40px 10px;
      position: relative;
      z-index: 2;
    }
    .card {
      background: var(--glass);
      border-radius: var(--radius);
      box-shadow: var(--glow), 0 2px 14px #0002;
      padding: 20px 16px 20px 16px;
      margin-bottom: 18px;
      border: 2px solid var(--border);
      backdrop-filter: blur(6px);
      position: relative;
      overflow: hidden;
    }
    h1 {
      font-size: 1.08em;
      margin: 0 0 18px 0;
      font-weight: 700;
      letter-spacing: 0.05em;
      color: var(--primary);
      text-align: center;
      text-shadow: 0 0 6px #00fff7, 0 0 20px #fc00ff44;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 13px;
      flex-wrap: wrap;
      gap: 8px;
    }
    .wallet-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }
    .score-display {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 120px;
    }
    .btn {
      background: var(--button);
      border: none;
      color: var(--button-text);
      border-radius: 10px;
      padding: 8px 17px;
      font-size: var(--font-size);
      font-weight: 700;
      cursor: pointer;
      margin-right: 4px;
      margin-bottom: 4px;
      box-shadow: 0 0 8px #00fff7, 0 0 14px #fc00ff55;
      outline: none;
      transition: background 0.2s, box-shadow 0.2s, transform 0.14s;
      text-shadow: 0 0 4px #fc00ffbb;
      letter-spacing: 0.07em;
      position: relative;
    }
    .btn:active, .btn:focus {
      box-shadow: 0 0 24px #00fff7;
      transform: scale(0.97);
      background: linear-gradient(90deg, #2017fc, #00fff7);
    }
    .btn[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
      filter: grayscale(0.6) brightness(0.8);
    }
    .btn-disconnect {
      background: #320040;
      color: #fff;
      margin-right: 0;
      box-shadow: 0 0 6px #fc00ff,0 0 10px #2017fc22;
      text-shadow: none;
      font-weight: 400;
    }
    .btn-refresh {
      background: linear-gradient(90deg, #00fff7 30%, #2017fc 90%);
      font-size: 8px;
      padding: 4px 10px;
      margin: 1px 0 0 0;
      border-radius: 8px;
      box-shadow: 0 0 7px #00fff799;
      color: #181825;
      font-weight: 700;
      letter-spacing: 0.04em;
    }
    textarea {
      width: 100%;
      min-height: 90px;
      font-size: var(--font-size);
      border-radius: 8px;
      border: 1.5px solid var(--border);
      background: #0a0a13b8;
      color: var(--text);
      padding: 10px 8px;
      margin-bottom: 8px;
      resize: vertical;
      font-family: 'Share Tech Mono', 'Inter', Arial, sans-serif;
      box-sizing: border-box;
      outline: none;
      transition: border 0.18s;
      box-shadow: 0 0 2px #00fff7cc;
    }
    textarea:focus {
      border: 2.2px solid var(--primary);
      background: #121229d9;
      box-shadow: 0 0 8px #00fff7cc;
    }
    .wallet-list {
      background: var(--bar-bg);
      border-radius: 8px;
      padding: 8px 6px;
      max-height: 120px;
      overflow-y: auto;
      font-size: var(--wallet-font);
      margin-bottom: 7px;
      color: var(--muted);
      word-break: break-all;
      border: 1px solid #2323e355;
      box-shadow: 0 0 6px #00fff733;
    }
    .filter-info {
      margin: 7px 0 7px 0;
      color: var(--muted);
      font-size: var(--font-size);
      text-shadow: 0 0 3px #fc00ff33;
      letter-spacing: 0.04em;
    }
    .progress-bar-bg {
      width: 100%;
      height: 12px;
      background: var(--bar-bg);
      border-radius: 8px;
      margin: 12px 0 10px 0;
      overflow: hidden;
      box-shadow: 0 0 7px #00fff799;
      border: 1px solid #2222e355;
    }
    .progress-bar-fill {
      height: 100%;
      background: var(--bar-fill);
      width: 0%;
      transition: width 0.7s cubic-bezier(.7,.2,.3,.9);
      box-shadow: 0 0 12px #00fff7, 0 0 14px #fc00ff;
    }
    .score-bar {
      background: #0d0e18c0;
      border-radius: 8px;
      padding: 9px 12px;
      text-align: center;
      color: var(--primary);
      font-weight: 700;
      font-size: 1em;
      letter-spacing: 0.01em;
      box-shadow: 0 0 12px #00fff777;
      border: 1px solid #00fff7cc;
      text-shadow: 0 0 6px #00fff7;
      margin-bottom: 4px;
    }
    .contract-info {
      font-size: var(--wallet-font);
      color: var(--muted);
      text-align: center;
      margin: 8px 0 0 0;
      word-break: break-all;
      border: 1.5px solid #2323e355;
      box-shadow: 0 0 8px #fc00ff44;
      background: #181829aa;
      letter-spacing: 0.03em;
    }
    .status-message, .error-message, .gas-info {
      border-radius: 10px;
      padding: 10px 14px;
      margin: 12px 0 8px 0;
      font-size: var(--font-size);
      text-align: center;
      box-shadow: var(--notif-shadow);
      border: 1.5px solid #00fff799;
      display: none;
      position: relative;
      z-index: 100;
      font-family: 'Share Tech Mono', 'Inter', Arial, sans-serif;
      animation: notifFadeIn 0.5s;
    }
    .status-message {
      background: var(--notif-bg);
      color: #5efcf5;
      border-color: #00fff7;
      text-shadow: 0 0 8px #00fff7bb;
    }
    .error-message {
      background: #27001aee;
      color: #ff6ce9;
      border-color: #fc00ff;
      text-shadow: 0 0 8px #fc00ffbb;
    }
    .gas-info {
      background: #01181a99;
      color: #5efcf5;
      border-color: #00fff7;
      text-shadow: 0 0 6px #00fff7cc;
      margin-bottom: 0;
      font-size: 10px;
    }
    .notif-anim {
      animation: notifBounce 0.3s;
    }
    @keyframes notifBounce {
      0% { transform: scale(0.8);}
      50% { transform: scale(1.04);}
      100% { transform: scale(1);}
    }
    @keyframes notifFadeIn {
      from { opacity: 0;}
      to { opacity: 1;}
    }
    .processing-overlay {
      background: #120824ea;
      position: fixed;
      inset: 0;
      z-index: 9000;
      display: none;
      place-items: center;
      transition: opacity 0.2s;
    }
    .processing-box {
      background: #23223aee;
      border-radius: 16px;
      border: 2.5px solid #00fff799;
      box-shadow: 0 0 40px #fc00ff44, 0 0 16px #00fff7;
      padding: 32px 40px 26px 40px;
      text-align: center;
      min-width: 220px;
      min-height: 80px;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .processing-anim {
      margin: 0 auto 18px auto;
      width: 54px;
      height: 54px;
      border: 6px solid #00fff7;
      border-top: 6px solid #fc00ff;
      border-radius: 50%;
      animation: spinAnim 1.2s linear infinite;
      box-shadow: 0 0 24px #fc00ff99, 0 0 16px #00fff7;
    }
    @keyframes spinAnim {
      0% { transform: rotate(0);}
      100% { transform: rotate(360deg);}
    }
    .processing-text {
      color: #00fff7;
      font-size: 1.08em;
      font-weight: 700;
      margin-top: 5px;
      letter-spacing: 0.03em;
      text-shadow: 0 0 8px #00fff7aa;
      text-align: center;
    }
    .processing-sub {
      color: #fc00ff;
      font-size: 10px;
      margin-top: 8px;
      letter-spacing: 0.02em;
      text-shadow: 0 0 8px #fc00ffbb;
    }
    /* Neon gradient border animation */
    .card:before {
      content: "";
      z-index: 0;
      pointer-events: none;
      position: absolute;
      inset: -2px;
      border-radius: var(--radius);
      background: conic-gradient(from 0deg, #fc00ff, #00fff7, #2017fc, #fc00ff 60%, #00fff7 100%);
      filter: blur(4px);
      opacity: 0.25;
      transition: opacity 0.22s;
      animation: borderGlow 6s linear infinite;
    }
    @keyframes borderGlow {
      to { filter: blur(6px) hue-rotate(360deg);}
    }
    @media (max-width: 600px) {
      .container {
        padding: 6px 2px 22px 2px;
      }
      .card {
        padding: 10px;
      }
      h1 {
        font-size: 0.97em;
      }
      .btn {
        padding: 7px 8px;
      }
      .score-bar {
        font-size: 0.93em;
      }
      .top-bar {
        flex-direction: column;
        align-items: stretch;
      }
      .score-display {
        align-items: center;
        min-width: auto;
      }
      .processing-box {
        min-width: 130px;
        padding: 20px 8px 18px 8px;
      }
      .processing-anim {
        width: 33px; height: 33px; border-width: 4px;
      }
    }
    /* Cyberpunk background elements */
    .bg-cyber {
      position: fixed;
      inset: 0;
      z-index: 1;
      pointer-events: none;
      overflow: hidden;
    }
    .cyber-glow1, .cyber-glow2, .cyber-glow3 {
      position: absolute; border-radius: 50%;
      filter: blur(60px);
      opacity: 0.22;
      z-index: 1;
    }
    .cyber-glow1 { width: 320px; height: 320px; background: #00fff7; left: -80px; top: -120px;}
    .cyber-glow2 { width: 180px; height: 180px; background: #fc00ff; right: -80px; top: 340px;}
    .cyber-glow3 { width: 150px; height: 150px; background: #2017fc; left: 45%; top: 87vh;}
  </style>
</head>
<body>
  <div class="bg-cyber">
    <div class="cyber-glow1"></div>
    <div class="cyber-glow2"></div>
    <div class="cyber-glow3"></div>
  </div>
  <div class="container">
    <div class="top-bar">
      <div class="wallet-controls">
        <button class="btn" id="connectWalletBtn"><i class="fa-solid fa-wallet"></i> Connect Wallet</button>
        <button class="btn btn-disconnect" id="disconnectWalletBtn" style="display:none;"><i class="fa-solid fa-power-off"></i></button>
      </div>
      <div class="score-display">
        <div class="score-bar">
          <i class="fa-solid fa-star"></i> My Score: <span id="myScore">0</span>
        </div>
        <button class="btn btn-refresh" id="refreshScoreBtn" style="display:none;"><i class="fa-solid fa-rotate"></i> Refresh</button>
      </div>
    </div>
    <div class="status-message" id="statusMessage"></div>
    <div class="error-message" id="errorMessage"></div>
    <div class="card">
      <h1><i class="fa-brands fa-ethereum"></i> NFTFAN Airdrop</h1>
      <div class="filter-info">Paste any text with wallet addresses below:</div>
      <textarea id="walletInput" placeholder="Paste addresses here (comma, space, newline, or mixed)"></textarea>
      <button class="btn" id="filterBtn"><i class="fa-solid fa-filter"></i> Filter Wallets</button>
      <div class="filter-info">
        <span id="walletCount">0</span> wallets filtered
      </div>
      <div class="wallet-list" id="walletList"></div>
      <div class="gas-info" id="gasInfo">
        <i class="fa-solid fa-gas-pump"></i> Estimated Gas: <span id="gasEstimate">Calculating...</span>
      </div>
      <div class="progress-bar-bg"><div class="progress-bar-fill" id="progressBar"></div></div>
      <button class="btn" id="airdropBtn" disabled><i class="fa-solid fa-paper-plane"></i> Send Airdrop</button>
    </div>
    <div class="card contract-info">
      <i class="fa-solid fa-coins"></i> NFTFAN Token: <span id="tokenCA">0x2017Fcaea540d2925430586DC92818035Bfc2F50</span><br>
      <i class="fa-solid fa-vault"></i> Distributor: <span id="airdropCA">0x664d25959EcCabc3e04A4Dc9D1f5ca5dDE82a5d5</span>
    </div>
  </div>
  <div class="processing-overlay" id="processingOverlay">
    <div class="processing-box">
      <div class="processing-anim"></div>
      <div class="processing-text" id="processingText">Processing...</div>
      <div class="processing-sub" id="processingSub"></div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script>
    // CONFIG
    const POLYGON_PARAMS = {
      chainId: "0x89",
      chainName: "Polygon Mainnet",
      nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18
      },
      rpcUrls: ["https://polygon-rpc.com", "https://rpc.ankr.com/polygon"],
      blockExplorerUrls: ["https://polygonscan.com/"]
    };

    const NFTFAN_TOKEN_CA = "0x2017Fcaea540d2925430586DC92818035Bfc2F50";
    const AIRDROP_CONTRACT_CA = "0x664d25959EcCabc3e04A4Dc9D1f5ca5dDE82a5d5";
    const AIRDROP_ABI = [
      "function distributeTokens(address[] calldata recipients) external",
      "function userScores(address) public view returns (uint256)"
    ];
    const BATCH_SIZE = 25;
    const MAX_GAS_LIMIT = 8000000;

    // DOM elements
    const connectWalletBtn = document.getElementById('connectWalletBtn');
    const disconnectWalletBtn = document.getElementById('disconnectWalletBtn');
    const filterBtn = document.getElementById('filterBtn');
    const airdropBtn = document.getElementById('airdropBtn');
    const refreshScoreBtn = document.getElementById('refreshScoreBtn');
    const walletInput = document.getElementById('walletInput');
    const walletList = document.getElementById('walletList');
    const walletCount = document.getElementById('walletCount');
    const progressBar = document.getElementById('progressBar');
    const myScore = document.getElementById('myScore');
    const statusMessage = document.getElementById('statusMessage');
    const errorMessage = document.getElementById('errorMessage');
    const gasInfo = document.getElementById('gasInfo');
    const gasEstimate = document.getElementById('gasEstimate');
    const processingOverlay = document.getElementById('processingOverlay');
    const processingText = document.getElementById('processingText');
    const processingSub = document.getElementById('processingSub');

    // App state
    let provider, signer, userAddress, contract;
    let filteredWallets = [];
    let airdropInProgress = false;
    let scoreRefreshInterval;

    // --- Neon notifications ---
    function showStatus(message, sub = "") {
      statusMessage.textContent = message;
      if (sub) statusMessage.innerHTML += `<br><small>${sub}</small>`;
      statusMessage.classList.add('notif-anim');
      statusMessage.style.display = 'block';
      errorMessage.style.display = 'none';
      setTimeout(() => {
        statusMessage.classList.remove('notif-anim');
        statusMessage.style.display = 'none';
      }, 4400);
    }
    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.classList.add('notif-anim');
      errorMessage.style.display = 'block';
      statusMessage.style.display = 'none';
      setTimeout(() => {
        errorMessage.classList.remove('notif-anim');
        errorMessage.style.display = 'none';
      }, 7000);
    }
    function showProcessing(msg, sub = "") {
      processingText.textContent = msg;
      processingSub.textContent = sub;
      processingOverlay.style.display = "grid";
    }
    function hideProcessing() {
      processingOverlay.style.display = "none";
      processingText.textContent = "";
      processingSub.textContent = "";
    }
    // --- END Notifications ---

    function isWallet(addr) {
      return /^0x[a-fA-F0-9]{40}$/.test(addr);
    }
    function extractWallets(text) {
      let matches = text.match(/0x[a-fA-F0-9]{40}/g) || [];
      let deduped = Array.from(new Set(matches.map(a => ethers.utils.getAddress(a.toLowerCase()))));
      return deduped;
    }
    function showWallets(wallets) {
      walletList.innerHTML = wallets.slice(0, 200).map(w =>
        `<div style="font-size:9px;line-height:1.1;margin-bottom:2px">${w}</div>`
      ).join('');
      if (wallets.length > 200) {
        walletList.innerHTML += `<div style="color:#fc00ff;">...and ${wallets.length-200} more</div>`;
      }
      walletCount.textContent = wallets.length;
    }

    async function estimateGasForBatch(recipients) {
      if (!contract || recipients.length === 0) return null;
      try {
        const gasEstimate = await contract.estimateGas.distributeTokens(recipients);
        return gasEstimate;
      } catch (error) {
        return ethers.BigNumber.from(100000 + (recipients.length * 50000));
      }
    }
    async function updateGasEstimate() {
      if (filteredWallets.length === 0 || !contract) {
        gasInfo.style.display = 'none';
        return;
      }
      try {
        gasInfo.style.display = 'block';
        gasEstimate.textContent = 'Calculating...';
        const sampleBatch = filteredWallets.slice(0, Math.min(BATCH_SIZE, filteredWallets.length));
        const gasForBatch = await estimateGasForBatch(sampleBatch);
        const totalBatches = Math.ceil(filteredWallets.length / BATCH_SIZE);
        const totalGasEstimate = gasForBatch.mul(totalBatches);
        const gasPrice = await provider.getGasPrice();
        const totalCost = totalGasEstimate.mul(gasPrice);
        gasEstimate.innerHTML = `<span style="color:#fc00ff">${ethers.utils.formatUnits(totalCost, 'ether').slice(0, 8)} MATIC</span>
          <span style="color:#00fff7;font-size:9px;"> (${totalBatches} batches)</span>`;
      } catch (error) {
        gasEstimate.textContent = 'Unable to estimate';
      }
    }

    filterBtn.onclick = async () => {
      try {
        const rawWallets = extractWallets(walletInput.value);
        filteredWallets = rawWallets.filter(addr => {
          try {
            ethers.utils.getAddress(addr);
            return true;
          } catch {
            return false;
          }
        });
        showWallets(filteredWallets);
        await updateGasEstimate();
        airdropBtn.disabled = filteredWallets.length === 0 || !signer || airdropInProgress;
        if (filteredWallets.length > 0) {
          showStatus(`ðŸŽ¯ Filtered ${filteredWallets.length} valid wallet addresses`);
        }
      } catch (error) {
        showError('Error filtering wallets: ' + error.message);
      }
    };

    // --- Automatic Polygon network switch before wallet connect ---
    async function ensurePolygonBeforeConnect() {
      if (!window.ethereum) return false;
      const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
      if (currentChainId !== POLYGON_PARAMS.chainId) {
        showProcessing("Switching network...", "Connecting to Polygon Mainnet");
        try {
          await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: POLYGON_PARAMS.chainId }] });
          hideProcessing();
          showStatus('âœ… Switched to Polygon network');
          return true;
        } catch (switchError) {
          if (switchError.code === 4902) {
            try {
              await window.ethereum.request({
                method: "wallet_addEthereumChain",
                params: [POLYGON_PARAMS]
              });
              hideProcessing();
              showStatus('âœ… Polygon network added successfully');
              return true;
            } catch (addError) {
              hideProcessing();
              showError("âŒ Failed to add Polygon network. Please add it manually.");
              return false;
            }
          } else if (switchError.code === 4001) {
            hideProcessing();
            showError("âŒ Please approve the network switch in your wallet.");
            return false;
          } else {
            hideProcessing();
            showError("âŒ Please switch to Polygon in your wallet.");
            return false;
          }
        }
      }
      return true;
    }

    connectWalletBtn.onclick = async () => {
      if (!window.ethereum) {
        showError('Please install MetaMask or a compatible Web3 wallet!');
        return;
      }
      showProcessing('Checking Polygon network...', 'Preparing wallet connection');
      const canProceed = await ensurePolygonBeforeConnect();
      if (!canProceed) { hideProcessing(); return; }
      try {
        showProcessing('Requesting wallet...', 'Please approve in your wallet');
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
        connectWalletBtn.innerHTML = `<i class="fa-solid fa-wallet"></i> ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
        connectWalletBtn.disabled = true;
        disconnectWalletBtn.style.display = "";
        refreshScoreBtn.style.display = "";
        await updateScore();
        startScoreRefresh();
        if (filteredWallets.length > 0) {
          await updateGasEstimate();
        }
        airdropBtn.disabled = filteredWallets.length === 0 || airdropInProgress;
        hideProcessing();
        showStatus('âœ… Wallet connected successfully!');
      } catch (err) {
        hideProcessing();
        showError("âŒ Wallet connection failed: " + (err.message || err));
      }
    };

    disconnectWalletBtn.onclick = () => {
      stopScoreRefresh();
      provider = null;
      signer = null;
      userAddress = null;
      contract = null;
      connectWalletBtn.innerHTML = '<i class="fa-solid fa-wallet"></i> Connect Wallet';
      connectWalletBtn.disabled = false;
      disconnectWalletBtn.style.display = "none";
      refreshScoreBtn.style.display = "none";
      myScore.textContent = "0";
      airdropBtn.disabled = true;
      gasInfo.style.display = 'none';
      showStatus('Disconnected wallet');
    };

    async function updateScore() {
      if (!contract || !userAddress) {
        myScore.textContent = "0";
        return;
      }
      try {
        const score = await contract.userScores(userAddress);
        myScore.textContent = score.toString();
      } catch (error) {
        myScore.textContent = "Error";
      }
    }
    function startScoreRefresh() {
      stopScoreRefresh();
      scoreRefreshInterval = setInterval(updateScore, 30000);
    }
    function stopScoreRefresh() {
      if (scoreRefreshInterval) {
        clearInterval(scoreRefreshInterval);
        scoreRefreshInterval = null;
      }
    }
    refreshScoreBtn.onclick = async () => {
      refreshScoreBtn.disabled = true;
      refreshScoreBtn.innerHTML = '<i class="fa-solid fa-rotate"></i> ...';
      await updateScore();
      setTimeout(() => {
        refreshScoreBtn.disabled = false;
        refreshScoreBtn.innerHTML = '<i class="fa-solid fa-rotate"></i> Refresh';
      }, 1400);
    };

    async function performPreflightChecks(batch) {
      const checks = { balance: false, gasPrice: false, contract: false, network: false };
      try {
        const balance = await signer.getBalance();
        const gasPrice = await provider.getGasPrice();
        const estimatedGas = await estimateGasForBatch(batch);
        const requiredGas = estimatedGas.mul(gasPrice);
        checks.balance = balance.gte(requiredGas);
        checks.gasPrice = gasPrice.lt(ethers.utils.parseUnits('100', 'gwei'));
        const code = await provider.getCode(AIRDROP_CONTRACT_CA);
        checks.contract = code !== '0x';
        const network = await provider.getNetwork();
        checks.network = network.chainId === 137;
        return {
          passed: Object.values(checks).every(Boolean),
          details: checks,
          balance: balance,
          requiredGas: requiredGas,
          gasPrice: gasPrice
        };
      } catch (error) {
        return { passed: false, error: error.message, details: checks };
      }
    }
    function getDetailedError(error) {
      if (error.code === 'INSUFFICIENT_FUNDS') return 'Insufficient MATIC for gas fees';
      if (error.code === 'UNPREDICTABLE_GAS_LIMIT') return 'Cannot estimate gas - contract may revert or insufficient tokens';
      if (error.code === 'CALL_EXCEPTION') return 'Contract call failed - check permission/token balance';
      if (error.code === 'NETWORK_ERROR') return 'Network connection error';
      if (error.code === 'TIMEOUT') return 'Transaction timeout - network may be congested';
      const message = error.message || error.reason || '';
      if (message.includes('insufficient funds')) return 'Insufficient MATIC for gas fees';
      if (message.includes('gas required exceeds')) return 'Transaction needs too much gas - try smaller batches';
      if (message.includes('execution reverted')) {
        if (message.includes('Ownable')) return 'Access denied - not permitted';
        if (message.includes('ERC20')) return 'Token transfer failed - insufficient tokens in contract';
        return 'Contract execution failed: ' + message.split('execution reverted: ')[1];
      }
      if (message.includes('nonce')) return 'Transaction nonce error - reset wallet/try again';
      if (message.includes('replacement transaction underpriced')) return 'Gas price too low - increase and retry';
      return error.reason || error.message || 'Unknown transaction error';
    }

    airdropBtn.onclick = async () => {
      if (!signer || !contract || filteredWallets.length === 0 || airdropInProgress) return;
      showProcessing('Running pre-flight checks...', 'Checking wallet, network, and contract');
      const testBatch = filteredWallets.slice(0, Math.min(5, filteredWallets.length));
      const preflightResult = await performPreflightChecks(testBatch);
      hideProcessing();
      if (!preflightResult.passed) {
        let errorMsg = 'Pre-flight checks failed:<br>';
        if (preflightResult.error) {
          errorMsg += preflightResult.error;
        } else {
          if (!preflightResult.details.balance) errorMsg += 'â€¢ Insufficient MATIC<br>';
          if (!preflightResult.details.contract) errorMsg += 'â€¢ Contract not found/invalid<br>';
          if (!preflightResult.details.network) errorMsg += 'â€¢ Wrong network (Polygon required)<br>';
          if (!preflightResult.details.gasPrice) errorMsg += 'â€¢ Gas price too high<br>';
        }
        showError(errorMsg);
        return;
      }
      const balanceFormatted = ethers.utils.formatEther(preflightResult.balance).slice(0, 8);
      const requiredFormatted = ethers.utils.formatEther(preflightResult.requiredGas).slice(0, 8);
      const confirmed = confirm(
        `Send airdrop to ${filteredWallets.length} wallets?\n\n` +
        `Batches: ${Math.ceil(filteredWallets.length / BATCH_SIZE)}\n` +
        `Your MATIC: ${balanceFormatted}\n` +
        `Est. Required: ${requiredFormatted}\n\n` +
        `Continue with airdrop?`
      );
      if (!confirmed) return;
      airdropInProgress = true;
      airdropBtn.disabled = true;
      filterBtn.disabled = true;
      let total = filteredWallets.length;
      let done = 0;
      let failed = 0;
      progressBar.style.width = "0%";
      showProcessing('Starting airdrop...', 'Sending transactions');
      try {
        for (let i = 0; i < total; i += BATCH_SIZE) {
          const batch = filteredWallets.slice(i, i + BATCH_SIZE);
          const batchNum = Math.floor(i/BATCH_SIZE) + 1;
          const totalBatches = Math.ceil(total/BATCH_SIZE);
          showProcessing(`Processing batch ${batchNum}/${totalBatches}`, `Batch: ${batch.length} addresses`);
          try {
            const gasEstimate = await estimateGasForBatch(batch);
            let gasLimit;
            if (gasEstimate.gt(MAX_GAS_LIMIT)) {
              showError(`Batch ${batchNum} needs too much gas (${gasEstimate.toString()}). Skipping...`);
              failed += batch.length;
              continue;
            } else {
              gasLimit = gasEstimate.mul(130).div(100); // 30% buffer
            }
            const gasPrice = await provider.getGasPrice();
            const adjustedGasPrice = gasPrice.mul(110).div(100); // 10% buffer
            showProcessing(`Sending batch ${batchNum}...`, `Awaiting wallet signature`);
            const tx = await contract.distributeTokens(batch, {
              gasLimit: gasLimit,
              gasPrice: adjustedGasPrice
            });
            showProcessing(`Batch ${batchNum} sent`, `Waiting for confirmation...`);
            const receipt = await Promise.race([
              tx.wait(),
              new Promise((_, reject) =>
                setTimeout(() => reject(new Error('Transaction timeout after 5 minutes')), 300000)
              )
            ]);
            if (receipt.status === 1) {
              done += batch.length;
              progressBar.style.width = (100 * (done + failed) / total).toFixed(1) + "%";
              await updateScore();
              showStatus(`âœ… Batch ${batchNum} done!`, `Processed ${done}/${total}`);
              if (batchNum < totalBatches) await new Promise(resolve => setTimeout(resolve, 1200));
            } else {
              throw new Error(`Transaction failed with status: ${receipt.status}`);
            }
          } catch (batchError) {
            failed += batch.length;
            const detailedError = getDetailedError(batchError);
            if (batchError.code === 'INSUFFICIENT_FUNDS') {
              showError(`Batch ${batchNum} failed: ${detailedError}<br>Stopping airdrop.`);
              break;
            } else if (batchError.message && batchError.message.includes('nonce')) {
              showError(`Batch ${batchNum} failed: ${detailedError}<br>Please reset wallet and try again.`);
              break;
            } else {
              showError(`Batch ${batchNum} failed: ${detailedError}<br>Continuing...`);
              progressBar.style.width = (100 * (done + failed) / total).toFixed(1) + "%";
              await new Promise(resolve => setTimeout(resolve, 2200));
            }
          }
        }
        progressBar.style.width = "100%";
        hideProcessing();
        if (done > 0 && failed === 0) {
          showStatus(`ðŸŽ‰ Airdrop completed! All ${done} addresses processed.`);
        } else if (done > 0 && failed > 0) {
          showStatus(`âš ï¸ Airdrop partial. Success: ${done}, Failed: ${failed}`);
        } else {
          showError(`âŒ Airdrop failed. No addresses processed.`);
        }
      } catch (error) {
        hideProcessing();
        const detailedError = getDetailedError(error);
        showError(`Airdrop failed: ${detailedError}`);
      }
      airdropInProgress = false;
      airdropBtn.disabled = filteredWallets.length === 0 || !signer;
      filterBtn.disabled = false;
    };

    if (window.ethereum) {
      window.ethereum.on('accountsChanged', async (accounts) => {
        if (accounts.length > 0) {
          try {
            provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            signer = provider.getSigner();
            userAddress = accounts[0];
            contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
            connectWalletBtn.innerHTML = `<i class="fa-solid fa-wallet"></i> ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
            connectWalletBtn.disabled = true;
            disconnectWalletBtn.style.display = "";
            refreshScoreBtn.style.display = "";
            await updateScore();
            startScoreRefresh();
            if (filteredWallets.length > 0) {
              await updateGasEstimate();
            }
            airdropBtn.disabled = filteredWallets.length === 0 || airdropInProgress;
            showStatus('âœ… Account switched');
          } catch (error) {
            showError('Error switching account: ' + error.message);
          }
        } else {
          disconnectWalletBtn.onclick();
        }
      });
      window.ethereum.on('chainChanged', async (chainId) => {
        if (chainId !== POLYGON_PARAMS.chainId) {
          showError("Wrong network detected. Please switch to Polygon.");
          disconnectWalletBtn.onclick();
        }
      });
    }

    showWallets([]);
    airdropBtn.disabled = true;
    filterBtn.disabled = false;

    window.addEventListener('DOMContentLoaded', async () => {
      if (window.ethereum && window.ethereum.selectedAddress) {
        try {
          const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
          if (currentChainId === POLYGON_PARAMS.chainId) {
            showProcessing('Auto-connecting...', 'Checking wallet');
            provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            signer = provider.getSigner();
            userAddress = await signer.getAddress();
            contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
            connectWalletBtn.innerHTML = `<i class="fa-solid fa-wallet"></i> ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}`;
            connectWalletBtn.disabled = true;
            disconnectWalletBtn.style.display = "";
            refreshScoreBtn.style.display = "";
            await updateScore();
            startScoreRefresh();
            airdropBtn.disabled = filteredWallets.length === 0 || airdropInProgress;
            hideProcessing();
            showStatus('Wallet auto-connected');
          }
        } catch (error) {
          hideProcessing();
        }
      }
    });
  </script>
</body>
</html>
</html>
