<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NFTFAN Airdrop Tool</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --primary: #2017fc;
      --accent: #5efcf5;
      --bg: #181a20;
      --card: #23262f;
      --text: #fff;
      --muted: #a3a9b9;
      --button: #2629ff;
      --button-text: #fff;
      --border: #262939;
      --radius: 12px;
      --font-size: 10px;
      --wallet-font: 8px;
    }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', Arial, sans-serif;
      font-size: var(--font-size);
      box-sizing: border-box;
      min-height: 100vh;
    }
    .container {
      max-width: 420px;
      margin: 0 auto;
      padding: 16px 8px 32px 8px;
    }
    .card {
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: 0 2px 8px #0002;
      padding: 16px;
      margin-bottom: 16px;
      border: 1px solid var(--border);
    }
    h1 {
      font-size: 1.2em;
      margin: 0 0 12px 0;
      font-weight: 700;
      letter-spacing: 0.02em;
      color: var(--primary);
      text-align: center;
    }
    .top-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 12px;
      flex-wrap: wrap;
      gap: 8px;
    }
    .wallet-controls {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    .score-display {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      min-width: 120px;
    }
    .btn {
      background: var(--button);
      border: none;
      color: var(--button-text);
      border-radius: 8px;
      padding: 8px 14px;
      font-size: var(--font-size);
      font-weight: 700;
      cursor: pointer;
      margin-right: 4px;
      margin-bottom: 4px;
      transition: background 0.2s;
      outline: none;
      box-shadow: none;
    }
    .btn:active, .btn:focus {
      background: #1b1fc7;
    }
    .btn[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .btn-disconnect {
      background: #444;
      color: #fff;
      margin-left: 0;
      margin-right: 0;
    }
    .btn-refresh {
      background: #28a745;
      font-size: 8px;
      padding: 4px 8px;
      margin: 2px 0 0 0;
    }
    textarea {
      width: 100%;
      min-height: 90px;
      font-size: var(--font-size);
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--bg);
      color: var(--text);
      padding: 8px;
      margin-bottom: 8px;
      resize: vertical;
      font-family: 'Inter', Arial, sans-serif;
      box-sizing: border-box;
    }
    .wallet-list {
      background: var(--card);
      border-radius: 8px;
      padding: 8px;
      max-height: 120px;
      overflow-y: auto;
      font-size: var(--wallet-font);
      margin-bottom: 8px;
      color: var(--muted);
      word-break: break-all;
    }
    .filter-info {
      margin: 6px 0 8px 0;
      color: var(--muted);
      font-size: var(--font-size);
    }
    .progress-bar-bg {
      width: 100%;
      height: 10px;
      background: #262939;
      border-radius: 5px;
      margin: 10px 0 8px 0;
      overflow: hidden;
    }
    .progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      width: 0%;
      transition: width 0.3s;
    }
    .score-bar {
      background: var(--card);
      border-radius: 8px;
      padding: 8px 12px;
      text-align: center;
      color: var(--primary);
      font-weight: 700;
      font-size: 1em;
      letter-spacing: 0.01em;
    }
    .contract-info {
      font-size: var(--wallet-font);
      color: var(--muted);
      text-align: center;
      margin: 8px 0 0 0;
      word-break: break-all;
    }
    .status-message {
      background: #1a4d1a;
      color: #4ade80;
      border-radius: 8px;
      padding: 8px 12px;
      margin: 8px 0;
      font-size: var(--font-size);
      text-align: center;
      display: none;
    }
    .error-message {
      background: #4d1a1a;
      color: #f87171;
      border-radius: 8px;
      padding: 8px 12px;
      margin: 8px 0;
      font-size: var(--font-size);
      text-align: center;
      display: none;
    }
    .gas-info {
      background: var(--card);
      border-radius: 8px;
      padding: 8px 12px;
      margin: 8px 0;
      font-size: var(--font-size);
      color: var(--muted);
      text-align: center;
      display: none;
    }
    @media (max-width: 600px) {
      .container {
        padding: 8px 2px 24px 2px;
      }
      .card {
        padding: 10px;
      }
      h1 {
        font-size: 1em;
      }
      .btn {
        padding: 7px 10px;
      }
      .score-bar {
        font-size: 0.95em;
      }
      .top-bar {
        flex-direction: column;
        align-items: stretch;
      }
      .score-display {
        align-items: center;
        min-width: auto;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <div class="wallet-controls">
        <button class="btn" id="connectWalletBtn">Connect Wallet</button>
        <button class="btn btn-disconnect" id="disconnectWalletBtn" style="display:none;">Disconnect</button>
      </div>
      <div class="score-display">
        <div class="score-bar">
          My Score: <span id="myScore">0</span>
        </div>
        <button class="btn btn-refresh" id="refreshScoreBtn" style="display:none;">Refresh Score</button>
      </div>
    </div>
    <div class="status-message" id="statusMessage"></div>
    <div class="error-message" id="errorMessage"></div>
    <div class="card">
      <h1>NFTFAN Airdrop</h1>
      <div class="filter-info">Paste any text containing wallet addresses below:</div>
      <textarea id="walletInput" placeholder="Paste addresses here (comma, space, newline, or mixed)"></textarea>
      <button class="btn" id="filterBtn">Filter Wallets</button>
      <div class="filter-info">
        <span id="walletCount">0</span> wallets filtered
      </div>
      <div class="wallet-list" id="walletList"></div>
      <div class="gas-info" id="gasInfo">
        Estimated Gas: <span id="gasEstimate">Calculating...</span>
      </div>
      <div class="progress-bar-bg"><div class="progress-bar-fill" id="progressBar"></div></div>
      <button class="btn" id="airdropBtn" disabled>Send Airdrop</button>
    </div>
    <div class="card contract-info">
      NFTFAN Token: <span id="tokenCA">0x2017Fcaea540d2925430586DC92818035Bfc2F50</span><br>
      Distributor: <span id="airdropCA">0x664d25959EcCabc3e04A4Dc9D1f5ca5dDE82a5d5</span>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script>
    // CONFIG
    const POLYGON_PARAMS = {
      chainId: "0x89",
      chainName: "Polygon Mainnet",
      nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18
      },
      rpcUrls: ["https://polygon-rpc.com", "https://rpc.ankr.com/polygon"],
      blockExplorerUrls: ["https://polygonscan.com/"]
    };

    const NFTFAN_TOKEN_CA = "0x2017Fcaea540d2925430586DC92818035Bfc2F50";
    const AIRDROP_CONTRACT_CA = "0x664d25959EcCabc3e04A4Dc9D1f5ca5dDE82a5d5";
    const AIRDROP_ABI = [
      "function distributeTokens(address[] calldata recipients) external",
      "function userScores(address) public view returns (uint256)"
    ];
    const BATCH_SIZE = 25;
    const MAX_GAS_LIMIT = 8000000;

    // DOM elements
    const connectWalletBtn = document.getElementById('connectWalletBtn');
    const disconnectWalletBtn = document.getElementById('disconnectWalletBtn');
    const filterBtn = document.getElementById('filterBtn');
    const airdropBtn = document.getElementById('airdropBtn');
    const refreshScoreBtn = document.getElementById('refreshScoreBtn');
    const walletInput = document.getElementById('walletInput');
    const walletList = document.getElementById('walletList');
    const walletCount = document.getElementById('walletCount');
    const progressBar = document.getElementById('progressBar');
    const myScore = document.getElementById('myScore');
    const statusMessage = document.getElementById('statusMessage');
    const errorMessage = document.getElementById('errorMessage');
    const gasInfo = document.getElementById('gasInfo');
    const gasEstimate = document.getElementById('gasEstimate');

    // App state
    let provider, signer, userAddress, contract;
    let filteredWallets = [];
    let airdropInProgress = false;
    let scoreRefreshInterval;

    function showStatus(message) {
      statusMessage.textContent = message;
      statusMessage.style.display = 'block';
      errorMessage.style.display = 'none';
      setTimeout(() => {
        statusMessage.style.display = 'none';
      }, 5000);
    }

    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.style.display = 'block';
      statusMessage.style.display = 'none';
      setTimeout(() => {
        errorMessage.style.display = 'none';
      }, 8000);
    }

    function isWallet(addr) {
      return /^0x[a-fA-F0-9]{40}$/.test(addr);
    }

    function extractWallets(text) {
      let matches = text.match(/0x[a-fA-F0-9]{40}/g) || [];
      let deduped = Array.from(new Set(matches.map(a => ethers.utils.getAddress(a.toLowerCase()))));
      return deduped;
    }

    function showWallets(wallets) {
      walletList.innerHTML = wallets.slice(0, 200).map(w => 
        `<div style="font-size:8px;line-height:1.1;margin-bottom:2px">${w}</div>`
      ).join('');
      if (wallets.length > 200) {
        walletList.innerHTML += `<div style="color:#5efcf5;">...and ${wallets.length-200} more</div>`;
      }
      walletCount.textContent = wallets.length;
    }

    async function estimateGasForBatch(recipients) {
      if (!contract || recipients.length === 0) return null;
      try {
        const gasEstimate = await contract.estimateGas.distributeTokens(recipients);
        return gasEstimate;
      } catch (error) {
        // Fallback calculation
        return ethers.BigNumber.from(100000 + (recipients.length * 50000));
      }
    }

    async function updateGasEstimate() {
      if (filteredWallets.length === 0 || !contract) {
        gasInfo.style.display = 'none';
        return;
      }
      try {
        gasInfo.style.display = 'block';
        gasEstimate.textContent = 'Calculating...';
        const sampleBatch = filteredWallets.slice(0, Math.min(BATCH_SIZE, filteredWallets.length));
        const gasForBatch = await estimateGasForBatch(sampleBatch);
        const totalBatches = Math.ceil(filteredWallets.length / BATCH_SIZE);
        const totalGasEstimate = gasForBatch.mul(totalBatches);
        const gasPrice = await provider.getGasPrice();
        const totalCost = totalGasEstimate.mul(gasPrice);
        gasEstimate.innerHTML = `
          ${ethers.utils.formatUnits(totalCost, 'ether').slice(0, 8)} MATIC 
          (${totalBatches} batches)
        `;
      } catch (error) {
        gasEstimate.textContent = 'Unable to estimate';
      }
    }

    filterBtn.onclick = async () => {
      try {
        const rawWallets = extractWallets(walletInput.value);
        filteredWallets = rawWallets.filter(addr => {
          try {
            ethers.utils.getAddress(addr);
            return true;
          } catch {
            return false;
          }
        });
        showWallets(filteredWallets);
        await updateGasEstimate();
        airdropBtn.disabled = filteredWallets.length === 0 || !signer || airdropInProgress;
        if (filteredWallets.length > 0) {
          showStatus(`Filtered ${filteredWallets.length} valid wallet addresses`);
        }
      } catch (error) {
        showError('Error filtering wallets: ' + error.message);
      }
    };

    // --- Automatic Polygon network switch ---
    async function switchToPolygon() {
      const polygonChainId = "0x89";
      try {
        await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: polygonChainId }] });
        showStatus('Successfully switched to Polygon network');
        return true;
      } catch (switchError) {
        if (switchError.code === 4902) {
          try {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [{
                chainId: polygonChainId,
                chainName: "Polygon Mainnet",
                nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
                rpcUrls: ["https://polygon-rpc.com/"],
                blockExplorerUrls: ["https://polygonscan.com/"]
              }]
            });
            showStatus('Polygon network added successfully');
            return true;
          } catch (addError) {
            showError("Failed to add Polygon network. Please add it manually.");
            return false;
          }
        } else if (switchError.code === 4001) {
          showError("Please approve the network switch in your wallet.");
          return false;
        } else {
          showError("Please switch to Polygon network manually in your wallet.");
          return false;
        }
      }
    }
    // --- END Automatic Polygon network switch ---

    connectWalletBtn.onclick = async () => {
      if (!window.ethereum) {
        showError('Please install MetaMask or a compatible Web3 wallet!');
        return;
      }
      try {
        showStatus('Connecting wallet...');
        const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
        if (currentChainId !== POLYGON_PARAMS.chainId) {
          const wantSwitch = confirm(
            "This dApp requires the Polygon network.\n\nWould you like us to switch your wallet automatically?"
          );
          if (wantSwitch) {
            const switched = await switchToPolygon();
            if (!switched) return;
          } else {
            showError("You must be on the Polygon network to use this airdrop tool.");
            return;
          }
        }
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
        connectWalletBtn.textContent = userAddress.slice(0, 6) + "..." + userAddress.slice(-4);
        connectWalletBtn.disabled = true;
        disconnectWalletBtn.style.display = "";
        refreshScoreBtn.style.display = "";
        await updateScore();
        startScoreRefresh();
        if (filteredWallets.length > 0) {
          await updateGasEstimate();
        }
        airdropBtn.disabled = filteredWallets.length === 0 || airdropInProgress;
        showStatus('Wallet connected successfully!');
      } catch (err) {
        showError("Wallet connection failed: " + err.message);
      }
    };

    disconnectWalletBtn.onclick = () => {
      stopScoreRefresh();
      provider = null;
      signer = null;
      userAddress = null;
      contract = null;
      connectWalletBtn.textContent = "Connect Wallet";
      connectWalletBtn.disabled = false;
      disconnectWalletBtn.style.display = "none";
      refreshScoreBtn.style.display = "none";
      myScore.textContent = "0";
      airdropBtn.disabled = true;
      gasInfo.style.display = 'none';
      showStatus('Wallet disconnected');
    };

    async function updateScore() {
      if (!contract || !userAddress) {
        myScore.textContent = "0";
        return;
      }
      try {
        const score = await contract.userScores(userAddress);
        const scoreValue = score.toString();
        myScore.textContent = scoreValue;
      } catch (error) {
        myScore.textContent = "Error";
      }
    }

    function startScoreRefresh() {
      stopScoreRefresh();
      scoreRefreshInterval = setInterval(updateScore, 30000);
    }
    function stopScoreRefresh() {
      if (scoreRefreshInterval) {
        clearInterval(scoreRefreshInterval);
        scoreRefreshInterval = null;
      }
    }

    refreshScoreBtn.onclick = async () => {
      refreshScoreBtn.disabled = true;
      refreshScoreBtn.textContent = 'Refreshing...';
      await updateScore();
      setTimeout(() => {
        refreshScoreBtn.disabled = false;
        refreshScoreBtn.textContent = 'Refresh Score';
      }, 2000);
    };

    async function performPreflightChecks(batch) {
      const checks = {
        balance: false,
        gasPrice: false,
        contract: false,
        network: false
      };
      try {
        const balance = await signer.getBalance();
        const gasPrice = await provider.getGasPrice();
        const estimatedGas = await estimateGasForBatch(batch);
        const requiredGas = estimatedGas.mul(gasPrice);
        checks.balance = balance.gte(requiredGas);
        checks.gasPrice = gasPrice.lt(ethers.utils.parseUnits('100', 'gwei'));
        const code = await provider.getCode(AIRDROP_CONTRACT_CA);
        checks.contract = code !== '0x';
        const network = await provider.getNetwork();
        checks.network = network.chainId === 137;
        return {
          passed: Object.values(checks).every(Boolean),
          details: checks,
          balance: balance,
          requiredGas: requiredGas,
          gasPrice: gasPrice
        };
      } catch (error) {
        return {
          passed: false,
          error: error.message,
          details: checks
        };
      }
    }

    function getDetailedError(error) {
      if (error.code === 'INSUFFICIENT_FUNDS') return 'Insufficient MATIC balance for gas fees';
      if (error.code === 'UNPREDICTABLE_GAS_LIMIT') return 'Cannot estimate gas - contract may revert or insufficient token balance';
      if (error.code === 'CALL_EXCEPTION') return 'Contract call failed - check if you have permission or sufficient tokens';
      if (error.code === 'NETWORK_ERROR') return 'Network connection error - please try again';
      if (error.code === 'TIMEOUT') return 'Transaction timeout - network may be congested';
      const message = error.message || error.reason || '';
      if (message.includes('insufficient funds')) return 'Insufficient MATIC balance for gas fees';
      if (message.includes('gas required exceeds')) return 'Transaction requires too much gas - try smaller batches';
      if (message.includes('execution reverted')) {
        if (message.includes('Ownable')) return 'Access denied - you may not have permission to perform airdrops';
        if (message.includes('ERC20')) return 'Token transfer failed - insufficient token balance in contract';
        return 'Contract execution failed: ' + message.split('execution reverted: ')[1];
      }
      if (message.includes('nonce too high') || message.includes('nonce too low')) return 'Transaction nonce error - please reset your wallet or try again';
      if (message.includes('replacement transaction underpriced')) return 'Gas price too low - please increase gas price and try again';
      return error.reason || error.message || 'Unknown transaction error';
    }

    airdropBtn.onclick = async () => {
      if (!signer || !contract || filteredWallets.length === 0 || airdropInProgress) return;
      showStatus('Running pre-flight checks...');
      const testBatch = filteredWallets.slice(0, Math.min(5, filteredWallets.length));
      const preflightResult = await performPreflightChecks(testBatch);
      if (!preflightResult.passed) {
        let errorMsg = 'Pre-flight checks failed:\n';
        if (preflightResult.error) {
          errorMsg += preflightResult.error;
        } else {
          if (!preflightResult.details.balance) errorMsg += '• Insufficient MATIC balance\n';
          if (!preflightResult.details.contract) errorMsg += '• Contract not found or invalid\n';
          if (!preflightResult.details.network) errorMsg += '• Wrong network (must be Polygon)\n';
          if (!preflightResult.details.gasPrice) errorMsg += '• Gas price too high\n';
        }
        showError(errorMsg);
        return;
      }
      const balanceFormatted = ethers.utils.formatEther(preflightResult.balance).slice(0, 6);
      const requiredFormatted = ethers.utils.formatEther(preflightResult.requiredGas).slice(0, 6);
      const confirmed = confirm(
        `Send airdrop to ${filteredWallets.length} wallets?\n\n` +
        `Batches: ${Math.ceil(filteredWallets.length / BATCH_SIZE)}\n` +
        `Your MATIC: ${balanceFormatted}\n` +
        `Est. Required: ${requiredFormatted}\n\n` +
        `Continue with airdrop?`
      );
      if (!confirmed) return;
      airdropInProgress = true;
      airdropBtn.disabled = true;
      filterBtn.disabled = true;
      let total = filteredWallets.length;
      let done = 0;
      let failed = 0;
      progressBar.style.width = "0%";
      showStatus('Starting airdrop...');
      try {
        for (let i = 0; i < total; i += BATCH_SIZE) {
          const batch = filteredWallets.slice(i, i + BATCH_SIZE);
          const batchNum = Math.floor(i/BATCH_SIZE) + 1;
          const totalBatches = Math.ceil(total/BATCH_SIZE);
          showStatus(`Processing batch ${batchNum}/${totalBatches} (${batch.length} addresses)...`);
          try {
            const gasEstimate = await estimateGasForBatch(batch);
            let gasLimit;
            if (gasEstimate.gt(MAX_GAS_LIMIT)) {
              showError(`Batch ${batchNum} requires too much gas (${gasEstimate.toString()}). Skipping...`);
              failed += batch.length;
              continue;
            } else {
              gasLimit = gasEstimate.mul(130).div(100); // 30% buffer
            }
            const gasPrice = await provider.getGasPrice();
            const adjustedGasPrice = gasPrice.mul(110).div(100); // 10% buffer
            showStatus(`Sending batch ${batchNum} transaction...`);
            const tx = await contract.distributeTokens(batch, {
              gasLimit: gasLimit,
              gasPrice: adjustedGasPrice
            });
            showStatus(`Batch ${batchNum} sent (${tx.hash.slice(0,10)}...), waiting for confirmation...`);
            const receipt = await Promise.race([
              tx.wait(),
              new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Transaction timeout after 5 minutes')), 300000)
              )
            ]);
            if (receipt.status === 1) {
              done += batch.length;
              progressBar.style.width = (100 * (done + failed) / total).toFixed(1) + "%";
              await updateScore();
              showStatus(`Batch ${batchNum}/${totalBatches} completed successfully! ✅`);
              if (batchNum < totalBatches) {
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
            } else {
              throw new Error(`Transaction failed with status: ${receipt.status}`);
            }
          } catch (batchError) {
            failed += batch.length;
            const detailedError = getDetailedError(batchError);
            if (batchError.code === 'INSUFFICIENT_FUNDS') {
              showError(`Batch ${batchNum} failed: ${detailedError}\nStopping airdrop.`);
              break;
            } else if (batchError.message && batchError.message.includes('nonce')) {
              showError(`Batch ${batchNum} failed: ${detailedError}\nPlease reset wallet and try again.`);
              break;
            } else {
              showError(`Batch ${batchNum} failed: ${detailedError}\nContinuing with next batch...`);
              progressBar.style.width = (100 * (done + failed) / total).toFixed(1) + "%";
              await new Promise(resolve => setTimeout(resolve, 5000));
            }
          }
        }
        progressBar.style.width = "100%";
        if (done > 0 && failed === 0) {
          showStatus(`🎉 Airdrop completed successfully! All ${done} addresses processed.`);
        } else if (done > 0 && failed > 0) {
          showStatus(`⚠️ Airdrop partially completed. Success: ${done}, Failed: ${failed}`);
        } else {
          showError(`❌ Airdrop failed completely. No addresses were processed.`);
        }
      } catch (error) {
        const detailedError = getDetailedError(error);
        showError(`Airdrop failed: ${detailedError}`);
      }
      airdropInProgress = false;
      airdropBtn.disabled = filteredWallets.length === 0 || !signer;
      filterBtn.disabled = false;
    };

    if (window.ethereum) {
      window.ethereum.on('accountsChanged', async (accounts) => {
        if (accounts.length > 0) {
          try {
            provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            signer = provider.getSigner();
            userAddress = accounts[0];
            contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
            connectWalletBtn.textContent = userAddress.slice(0, 6) + "..." + userAddress.slice(-4);
            connectWalletBtn.disabled = true;
            disconnectWalletBtn.style.display = "";
            refreshScoreBtn.style.display = "";
            await updateScore();
            startScoreRefresh();
            if (filteredWallets.length > 0) {
              await updateGasEstimate();
            }
            airdropBtn.disabled = filteredWallets.length === 0 || airdropInProgress;
            showStatus('Account switched successfully');
          } catch (error) {
            showError('Error switching account: ' + error.message);
          }
        } else {
          disconnectWalletBtn.onclick();
        }
      });
      window.ethereum.on('chainChanged', async (chainId) => {
        if (chainId !== POLYGON_PARAMS.chainId) {
          showError("Wrong network detected. Please switch to Polygon network.");
          disconnectWalletBtn.onclick();
        }
      });
    }

    showWallets([]);
    airdropBtn.disabled = true;
    filterBtn.disabled = false;

    window.addEventListener('DOMContentLoaded', async () => {
      if (window.ethereum && window.ethereum.selectedAddress) {
        try {
          const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
          if (currentChainId === POLYGON_PARAMS.chainId) {
            showStatus('Auto-connecting wallet...');
            provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            signer = provider.getSigner();
            userAddress = await signer.getAddress();
            contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
            connectWalletBtn.textContent = userAddress.slice(0, 6) + "..." + userAddress.slice(-4);
            connectWalletBtn.disabled = true;
            disconnectWalletBtn.style.display = "";
            refreshScoreBtn.style.display = "";
            await updateScore();
            startScoreRefresh();
            airdropBtn.disabled = filteredWallets.length === 0 || airdropInProgress;
            showStatus('Wallet auto-connected successfully');
          }
        } catch (error) {
          // Ignore auto-connect error
        }
      }
    });
  </script>
</body>
</html>
