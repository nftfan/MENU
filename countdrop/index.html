<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>NFTFAN Airdrop Tool</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --neon-cyan: #00ffff;
      --neon-purple: #ff00ff;
      --neon-green: #00ff41;
      --neon-orange: #ff6600;
      --dark-bg: #0a0a0f;
      --card-bg: #1a1a2e;
      --border-color: #16213e;
      --text-primary: #e0e0e0;
      --text-secondary: #8b8b9d;
      --glow-shadow: 0 0 20px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: linear-gradient(45deg, #0a0a0f 0%, #16213e 50%, #0a0a0f 100%);
      color: var(--text-primary);
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
    }

    /* Animated background */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 20% 20%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 60%, rgba(0, 255, 65, 0.05) 0%, transparent 50%);
      animation: pulse 8s ease-in-out infinite alternate;
      pointer-events: none;
      z-index: -1;
    }

    @keyframes pulse {
      0% { opacity: 0.3; }
      100% { opacity: 0.7; }
    }

    .container {
      max-width: 500px;
      margin: 0 auto;
      padding: 20px 12px;
      position: relative;
      z-index: 1;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      position: relative;
    }

    .logo {
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(45deg, var(--neon-cyan), var(--neon-purple));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: var(--glow-shadow) var(--neon-cyan);
      margin-bottom: 8px;
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from { filter: drop-shadow(0 0 5px var(--neon-cyan)); }
      to { filter: drop-shadow(0 0 15px var(--neon-purple)); }
    }

    .tagline {
      font-size: 10px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .card {
      background: rgba(26, 26, 46, 0.9);
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--neon-cyan), transparent);
      animation: scan 3s linear infinite;
    }

    @keyframes scan {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    .card:hover {
      border-color: var(--neon-cyan);
      box-shadow: var(--glow-shadow) rgba(0, 255, 255, 0.3);
      transform: translateY(-2px);
    }

    .wallet-section {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
      gap: 12px;
    }

    .btn {
      background: linear-gradient(45deg, var(--card-bg), #2a2a4e);
      border: 1px solid var(--neon-cyan);
      color: var(--text-primary);
      border-radius: 8px;
      padding: 10px 16px;
      font-size: 10px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      overflow: hidden;
      font-family: inherit;
    }

    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .btn:hover::before {
      left: 100%;
    }

    .btn:hover {
      border-color: var(--neon-green);
      box-shadow: var(--glow-shadow) rgba(0, 255, 65, 0.4);
      transform: translateY(-1px);
    }

    .btn:active {
      transform: translateY(0);
    }

    .btn[disabled] {
      opacity: 0.4;
      cursor: not-allowed;
      border-color: var(--text-secondary);
    }

    .btn[disabled]:hover {
      transform: none;
      box-shadow: none;
    }

    .btn-danger {
      border-color: var(--neon-orange);
    }

    .btn-danger:hover {
      border-color: var(--neon-orange);
      box-shadow: var(--glow-shadow) rgba(255, 102, 0, 0.4);
    }

    .btn-success {
      border-color: var(--neon-green);
    }

    .score-display {
      text-align: center;
      padding: 12px;
      background: linear-gradient(45deg, rgba(0, 255, 255, 0.1), rgba(255, 0, 255, 0.1));
      border: 1px solid var(--neon-purple);
      border-radius: 8px;
      min-width: 140px;
    }

    .score-value {
      font-size: 16px;
      font-weight: 700;
      color: var(--neon-cyan);
      text-shadow: var(--glow-shadow) var(--neon-cyan);
    }

    .score-label {
      font-size: 9px;
      color: var(--text-secondary);
      text-transform: uppercase;
      letter-spacing: 1px;
      margin-bottom: 4px;
    }

    .input-group {
      margin-bottom: 16px;
    }

    .input-label {
      display: block;
      font-size: 10px;
      color: var(--text-secondary);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .textarea {
      width: 100%;
      min-height: 100px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      color: var(--text-primary);
      font-family: inherit;
      font-size: 10px;
      resize: vertical;
      transition: all 0.3s ease;
    }

    .textarea:focus {
      outline: none;
      border-color: var(--neon-cyan);
      box-shadow: var(--glow-shadow) rgba(0, 255, 255, 0.2);
    }

    .wallet-preview {
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      max-height: 120px;
      overflow-y: auto;
      font-size: 9px;
      margin-bottom: 16px;
      font-family: 'JetBrains Mono', monospace;
    }

    .wallet-preview::-webkit-scrollbar {
      width: 4px;
    }

    .wallet-preview::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
    }

    .wallet-preview::-webkit-scrollbar-thumb {
      background: var(--neon-cyan);
      border-radius: 2px;
    }

    .wallet-item {
      color: var(--neon-green);
      line-height: 1.4;
      margin-bottom: 2px;
      word-break: break-all;
    }

    .stats-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      font-size: 10px;
    }

    .stat-item {
      color: var(--text-secondary);
    }

    .stat-value {
      color: var(--neon-cyan);
      font-weight: 600;
    }

    .progress-container {
      margin: 16px 0;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
      overflow: hidden;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--neon-cyan), var(--neon-purple));
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
      animation: shimmer 2s linear infinite;
    }

    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }

    .contract-info {
      background: rgba(0, 0, 0, 0.7);
      padding: 16px;
      border-radius: 8px;
      font-size: 9px;
      text-align: center;
      border: 1px solid var(--border-color);
    }

    .contract-label {
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .contract-address {
      color: var(--neon-green);
      font-family: 'JetBrains Mono', monospace;
      word-break: break-all;
      margin-bottom: 12px;
    }

    /* Notification System */
    .notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      max-width: 350px;
    }

    .notification {
      background: rgba(26, 26, 46, 0.95);
      border: 1px solid;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 12px;
      backdrop-filter: blur(10px);
      transform: translateX(100%);
      animation: slideIn 0.3s ease forwards;
      position: relative;
      overflow: hidden;
    }

    .notification::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background: currentColor;
    }

    .notification.success {
      border-color: var(--neon-green);
      color: var(--neon-green);
    }

    .notification.error {
      border-color: var(--neon-orange);
      color: var(--neon-orange);
    }

    .notification.info {
      border-color: var(--neon-cyan);
      color: var(--neon-cyan);
    }

    .notification.warning {
      border-color: var(--neon-purple);
      color: var(--neon-purple);
    }

    @keyframes slideIn {
      to { transform: translateX(0); }
    }

    @keyframes slideOut {
      to { transform: translateX(100%); }
    }

    .notification-title {
      font-weight: 600;
      font-size: 11px;
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .notification-message {
      font-size: 10px;
      line-height: 1.4;
      opacity: 0.9;
    }

    /* Loading Animation */
    .loading-spinner {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid rgba(0, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: var(--neon-cyan);
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Processing Animation */
    .processing {
      position: relative;
      overflow: hidden;
    }

    .processing::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 255, 0.2), transparent);
      animation: processing 2s linear infinite;
    }

    @keyframes processing {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    /* Gas Info */
    .gas-info {
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 12px;
      margin: 12px 0;
      text-align: center;
      font-size: 10px;
    }

    .gas-label {
      color: var(--text-secondary);
      margin-bottom: 4px;
    }

    .gas-value {
      color: var(--neon-orange);
      font-weight: 600;
    }

    /* Responsive Design */
    @media (max-width: 600px) {
      .container {
        padding: 12px 8px;
      }
      
      .card {
        padding: 16px;
      }
      
      .wallet-section {
        flex-direction: column;
        align-items: stretch;
      }
      
      .score-display {
        min-width: auto;
      }
      
      .notification-container {
        left: 10px;
        right: 10px;
        max-width: none;
      }
    }

    /* Pulse effect for important elements */
    .pulse {
      animation: pulse-glow 2s ease-in-out infinite alternate;
    }

    @keyframes pulse-glow {
      from { box-shadow: var(--glow-shadow) rgba(0, 255, 255, 0.2); }
      to { box-shadow: var(--glow-shadow) rgba(0, 255, 255, 0.6); }
    }

    /* Terminal-like effect for textarea */
    .textarea::placeholder {
      color: var(--text-secondary);
      opacity: 0.7;
    }

    /* Hover effects */
    .card:hover .wallet-preview {
      border-color: var(--neon-cyan);
    }

    /* Button variants */
    .btn-primary {
      background: linear-gradient(45deg, var(--neon-cyan), var(--neon-purple));
      border: none;
      color: var(--dark-bg);
      font-weight: 700;
    }

    .btn-primary:hover {
      box-shadow: var(--glow-shadow) rgba(0, 255, 255, 0.6);
      transform: translateY(-2px);
    }
  </style>
</head>
<body>
  <div class="notification-container" id="notificationContainer"></div>
  
  <div class="container">
    <div class="header">
      <div class="logo">NFTFAN AIRDROP</div>
      <div class="tagline">Terminal Interface v2.0</div>
    </div>

    <div class="card">
      <div class="wallet-section">
        <div>
          <button class="btn" id="connectWalletBtn">Connect Wallet</button>
          <button class="btn btn-danger" id="disconnectWalletBtn" style="display:none;">Disconnect</button>
        </div>
        <div class="score-display">
          <div class="score-label">User Score</div>
          <div class="score-value" id="myScore">0</div>
          <button class="btn btn-success" id="refreshScoreBtn" style="display:none; margin-top: 8px; font-size: 8px; padding: 4px 8px;">Refresh</button>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="input-group">
        <label class="input-label">Wallet Addresses Input</label>
        <textarea class="textarea" id="walletInput" placeholder="// Paste wallet addresses here&#10;// Supports: CSV, space-separated, line-separated&#10;// Example: 0x1234..., 0x5678..."></textarea>
      </div>
      
      <button class="btn btn-primary" id="filterBtn">
        <span class="loading-spinner" id="filterSpinner" style="display:none; margin-right: 8px;"></span>
        Process Addresses
      </button>
      
      <div class="stats-row">
        <div class="stat-item">
          Addresses Found: <span class="stat-value" id="walletCount">0</span>
        </div>
        <div class="stat-item">
          Status: <span class="stat-value" id="statusText">Ready</span>
        </div>
      </div>
      
      <div class="wallet-preview" id="walletPreview"></div>
      
      <div class="gas-info" id="gasInfo" style="display:none;">
        <div class="gas-label">Estimated Cost</div>
        <div class="gas-value" id="gasEstimate">Calculating...</div>
      </div>
      
      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress-fill" id="progressBar"></div>
        </div>
      </div>
      
      <button class="btn btn-primary pulse" id="airdropBtn" disabled>
        <span class="loading-spinner" id="airdropSpinner" style="display:none; margin-right: 8px;"></span>
        Execute Airdrop
      </button>
    </div>

    <div class="contract-info">
      <div class="contract-label">NFTFAN Token Contract</div>
      <div class="contract-address" id="tokenCA">0x2017Fcaea540d2925430586DC92818035Bfc2F50</div>
      <div class="contract-label">Airdrop Distributor Contract</div>
      <div class="contract-address" id="airdropCA">0x664d25959EcCabc3e04A4Dc9D1f5ca5dDE82a5d5</div>
    </div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script>
    // CONFIG
    const POLYGON_PARAMS = {
      chainId: "0x89",
      chainName: "Polygon Mainnet",
      nativeCurrency: {
        name: "MATIC",
        symbol: "MATIC",
        decimals: 18
      },
      rpcUrls: ["https://polygon-rpc.com", "https://rpc.ankr.com/polygon"],
      blockExplorerUrls: ["https://polygonscan.com/"]
    };

    const NFTFAN_TOKEN_CA = "0x2017Fcaea540d2925430586DC92818035Bfc2F50";
    const AIRDROP_CONTRACT_CA = "0x664d25959EcCabc3e04A4Dc9D1f5ca5dDE82a5d5";
    const AIRDROP_ABI = [
      "function distributeTokens(address[] calldata recipients) external",
      "function userScores(address) public view returns (uint256)"
    ];
    const BATCH_SIZE = 25;
    const MAX_GAS_LIMIT = 8000000;

    // DOM elements
    const connectWalletBtn = document.getElementById('connectWalletBtn');
    const disconnectWalletBtn = document.getElementById('disconnectWalletBtn');
    const filterBtn = document.getElementById('filterBtn');
    const airdropBtn = document.getElementById('airdropBtn');
    const refreshScoreBtn = document.getElementById('refreshScoreBtn');
    const walletInput = document.getElementById('walletInput');
    const walletList = document.getElementById('walletList');
    const walletCount = document.getElementById('walletCount');
    const progressBar = document.getElementById('progressBar');
    const myScore = document.getElementById('myScore');
    const statusMessage = document.getElementById('statusMessage');
    const errorMessage = document.getElementById('errorMessage');
    const gasInfo = document.getElementById('gasInfo');
    const gasEstimate = document.getElementById('gasEstimate');

    // App state
    let provider, signer, userAddress, contract;
    let filteredWallets = [];
    let airdropInProgress = false;
    let scoreRefreshInterval;

    function showStatus(message) {
      statusMessage.textContent = message;
      statusMessage.style.display = 'block';
      errorMessage.style.display = 'none';
      setTimeout(() => {
        statusMessage.style.display = 'none';
      }, 5000);
    }

    function showError(message) {
      errorMessage.textContent = message;
      errorMessage.style.display = 'block';
      statusMessage.style.display = 'none';
      setTimeout(() => {
        errorMessage.style.display = 'none';
      }, 8000);
    }

    function isWallet(addr) {
      return /^0x[a-fA-F0-9]{40}$/.test(addr);
    }

    function extractWallets(text) {
      let matches = text.match(/0x[a-fA-F0-9]{40}/g) || [];
      let deduped = Array.from(new Set(matches.map(a => ethers.utils.getAddress(a.toLowerCase()))));
      return deduped;
    }

    function showWallets(wallets) {
      walletList.innerHTML = wallets.slice(0, 200).map(w => 
        `<div style="font-size:8px;line-height:1.1;margin-bottom:2px">${w}</div>`
      ).join('');
      if (wallets.length > 200) {
        walletList.innerHTML += `<div style="color:#5efcf5;">...and ${wallets.length-200} more</div>`;
      }
      walletCount.textContent = wallets.length;
    }

    async function estimateGasForBatch(recipients) {
      if (!contract || recipients.length === 0) return null;
      try {
        const gasEstimate = await contract.estimateGas.distributeTokens(recipients);
        return gasEstimate;
      } catch (error) {
        // Fallback calculation
        return ethers.BigNumber.from(100000 + (recipients.length * 50000));
      }
    }

    async function updateGasEstimate() {
      if (filteredWallets.length === 0 || !contract) {
        gasInfo.style.display = 'none';
        return;
      }
      try {
        gasInfo.style.display = 'block';
        gasEstimate.textContent = 'Calculating...';
        const sampleBatch = filteredWallets.slice(0, Math.min(BATCH_SIZE, filteredWallets.length));
        const gasForBatch = await estimateGasForBatch(sampleBatch);
        const totalBatches = Math.ceil(filteredWallets.length / BATCH_SIZE);
        const totalGasEstimate = gasForBatch.mul(totalBatches);
        const gasPrice = await provider.getGasPrice();
        const totalCost = totalGasEstimate.mul(gasPrice);
        gasEstimate.innerHTML = `
          ${ethers.utils.formatUnits(totalCost, 'ether').slice(0, 8)} MATIC 
          (${totalBatches} batches)
        `;
      } catch (error) {
        gasEstimate.textContent = 'Unable to estimate';
      }
    }

    filterBtn.onclick = async () => {
      try {
        const rawWallets = extractWallets(walletInput.value);
        filteredWallets = rawWallets.filter(addr => {
          try {
            ethers.utils.getAddress(addr);
            return true;
          } catch {
            return false;
          }
        });
        showWallets(filteredWallets);
        await updateGasEstimate();
        airdropBtn.disabled = filteredWallets.length === 0 || !signer || airdropInProgress;
        if (filteredWallets.length > 0) {
          showStatus(`Filtered ${filteredWallets.length} valid wallet addresses`);
        }
      } catch (error) {
        showError('Error filtering wallets: ' + error.message);
      }
    };

    // --- Automatic Polygon network switch ---
    async function switchToPolygon() {
      const polygonChainId = "0x89";
      try {
        await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: polygonChainId }] });
        showStatus('Successfully switched to Polygon network');
        return true;
      } catch (switchError) {
        if (switchError.code === 4902) {
          try {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [{
                chainId: polygonChainId,
                chainName: "Polygon Mainnet",
                nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
                rpcUrls: ["https://polygon-rpc.com/"],
                blockExplorerUrls: ["https://polygonscan.com/"]
              }]
            });
            showStatus('Polygon network added successfully');
            return true;
          } catch (addError) {
            showError("Failed to add Polygon network. Please add it manually.");
            return false;
          }
        } else if (switchError.code === 4001) {
          showError("Please approve the network switch in your wallet.");
          return false;
        } else {
          showError("Please switch to Polygon network manually in your wallet.");
          return false;
        }
      }
    }
    // --- END Automatic Polygon network switch ---

    connectWalletBtn.onclick = async () => {
      if (!window.ethereum) {
        showError('Please install MetaMask or a compatible Web3 wallet!');
        return;
      }
      try {
        showStatus('Connecting wallet...');
        const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
        if (currentChainId !== POLYGON_PARAMS.chainId) {
          const wantSwitch = confirm(
            "This dApp requires the Polygon network.\n\nWould you like us to switch your wallet automatically?"
          );
          if (wantSwitch) {
            const switched = await switchToPolygon();
            if (!switched) return;
          } else {
            showError("You must be on the Polygon network to use this airdrop tool.");
            return;
          }
        }
        provider = new ethers.providers.Web3Provider(window.ethereum, "any");
        await provider.send("eth_requestAccounts", []);
        signer = provider.getSigner();
        userAddress = await signer.getAddress();
        contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
        connectWalletBtn.textContent = userAddress.slice(0, 6) + "..." + userAddress.slice(-4);
        connectWalletBtn.disabled = true;
        disconnectWalletBtn.style.display = "";
        refreshScoreBtn.style.display = "";
        await updateScore();
        startScoreRefresh();
        if (filteredWallets.length > 0) {
          await updateGasEstimate();
        }
        airdropBtn.disabled = filteredWallets.length === 0 || airdropInProgress;
        showStatus('Wallet connected successfully!');
      } catch (err) {
        showError("Wallet connection failed: " + err.message);
      }
    };

    disconnectWalletBtn.onclick = () => {
      stopScoreRefresh();
      provider = null;
      signer = null;
      userAddress = null;
      contract = null;
      connectWalletBtn.textContent = "Connect Wallet";
      connectWalletBtn.disabled = false;
      disconnectWalletBtn.style.display = "none";
      refreshScoreBtn.style.display = "none";
      myScore.textContent = "0";
      airdropBtn.disabled = true;
      gasInfo.style.display = 'none';
      showStatus('Wallet disconnected');
    };

    async function updateScore() {
      if (!contract || !userAddress) {
        myScore.textContent = "0";
        return;
      }
      try {
        const score = await contract.userScores(userAddress);
        const scoreValue = score.toString();
        myScore.textContent = scoreValue;
      } catch (error) {
        myScore.textContent = "Error";
      }
    }

    function startScoreRefresh() {
      stopScoreRefresh();
      scoreRefreshInterval = setInterval(updateScore, 30000);
    }
    function stopScoreRefresh() {
      if (scoreRefreshInterval) {
        clearInterval(scoreRefreshInterval);
        scoreRefreshInterval = null;
      }
    }

    refreshScoreBtn.onclick = async () => {
      refreshScoreBtn.disabled = true;
      refreshScoreBtn.textContent = 'Refreshing...';
      await updateScore();
      setTimeout(() => {
        refreshScoreBtn.disabled = false;
        refreshScoreBtn.textContent = 'Refresh Score';
      }, 2000);
    };

    async function performPreflightChecks(batch) {
      const checks = {
        balance: false,
        gasPrice: false,
        contract: false,
        network: false
      };
      try {
        const balance = await signer.getBalance();
        const gasPrice = await provider.getGasPrice();
        const estimatedGas = await estimateGasForBatch(batch);
        const requiredGas = estimatedGas.mul(gasPrice);
        checks.balance = balance.gte(requiredGas);
        checks.gasPrice = gasPrice.lt(ethers.utils.parseUnits('100', 'gwei'));
        const code = await provider.getCode(AIRDROP_CONTRACT_CA);
        checks.contract = code !== '0x';
        const network = await provider.getNetwork();
        checks.network = network.chainId === 137;
        return {
          passed: Object.values(checks).every(Boolean),
          details: checks,
          balance: balance,
          requiredGas: requiredGas,
          gasPrice: gasPrice
        };
      } catch (error) {
        return {
          passed: false,
          error: error.message,
          details: checks
        };
      }
    }

    function getDetailedError(error) {
      if (error.code === 'INSUFFICIENT_FUNDS') return 'Insufficient MATIC balance for gas fees';
      if (error.code === 'UNPREDICTABLE_GAS_LIMIT') return 'Cannot estimate gas - contract may revert or insufficient token balance';
      if (error.code === 'CALL_EXCEPTION') return 'Contract call failed - check if you have permission or sufficient tokens';
      if (error.code === 'NETWORK_ERROR') return 'Network connection error - please try again';
      if (error.code === 'TIMEOUT') return 'Transaction timeout - network may be congested';
      const message = error.message || error.reason || '';
      if (message.includes('insufficient funds')) return 'Insufficient MATIC balance for gas fees';
      if (message.includes('gas required exceeds')) return 'Transaction requires too much gas - try smaller batches';
      if (message.includes('execution reverted')) {
        if (message.includes('Ownable')) return 'Access denied - you may not have permission to perform airdrops';
        if (message.includes('ERC20')) return 'Token transfer failed - insufficient token balance in contract';
        return 'Contract execution failed: ' + message.split('execution reverted: ')[1];
      }
      if (message.includes('nonce too high') || message.includes('nonce too low')) return 'Transaction nonce error - please reset your wallet or try again';
      if (message.includes('replacement transaction underpriced')) return 'Gas price too low - please increase gas price and try again';
      return error.reason || error.message || 'Unknown transaction error';
    }

    airdropBtn.onclick = async () => {
      if (!signer || !contract || filteredWallets.length === 0 || airdropInProgress) return;
      showStatus('Running pre-flight checks...');
      const testBatch = filteredWallets.slice(0, Math.min(5, filteredWallets.length));
      const preflightResult = await performPreflightChecks(testBatch);
      if (!preflightResult.passed) {
        let errorMsg = 'Pre-flight checks failed:\n';
        if (preflightResult.error) {
          errorMsg += preflightResult.error;
        } else {
          if (!preflightResult.details.balance) errorMsg += '• Insufficient MATIC balance\n';
          if (!preflightResult.details.contract) errorMsg += '• Contract not found or invalid\n';
          if (!preflightResult.details.network) errorMsg += '• Wrong network (must be Polygon)\n';
          if (!preflightResult.details.gasPrice) errorMsg += '• Gas price too high\n';
        }
        showError(errorMsg);
        return;
      }
      const balanceFormatted = ethers.utils.formatEther(preflightResult.balance).slice(0, 6);
      const requiredFormatted = ethers.utils.formatEther(preflightResult.requiredGas).slice(0, 6);
      const confirmed = confirm(
        `Send airdrop to ${filteredWallets.length} wallets?\n\n` +
        `Batches: ${Math.ceil(filteredWallets.length / BATCH_SIZE)}\n` +
        `Your MATIC: ${balanceFormatted}\n` +
        `Est. Required: ${requiredFormatted}\n\n` +
        `Continue with airdrop?`
      );
      if (!confirmed) return;
      airdropInProgress = true;
      airdropBtn.disabled = true;
      filterBtn.disabled = true;
      let total = filteredWallets.length;
      let done = 0;
      let failed = 0;
      progressBar.style.width = "0%";
      showStatus('Starting airdrop...');
      try {
        for (let i = 0; i < total; i += BATCH_SIZE) {
          const batch = filteredWallets.slice(i, i + BATCH_SIZE);
          const batchNum = Math.floor(i/BATCH_SIZE) + 1;
          const totalBatches = Math.ceil(total/BATCH_SIZE);
          showStatus(`Processing batch ${batchNum}/${totalBatches} (${batch.length} addresses)...`);
          try {
            const gasEstimate = await estimateGasForBatch(batch);
            let gasLimit;
            if (gasEstimate.gt(MAX_GAS_LIMIT)) {
              showError(`Batch ${batchNum} requires too much gas (${gasEstimate.toString()}). Skipping...`);
              failed += batch.length;
              continue;
            } else {
              gasLimit = gasEstimate.mul(130).div(100); // 30% buffer
            }
            const gasPrice = await provider.getGasPrice();
            const adjustedGasPrice = gasPrice.mul(110).div(100); // 10% buffer
            showStatus(`Sending batch ${batchNum} transaction...`);
            const tx = await contract.distributeTokens(batch, {
              gasLimit: gasLimit,
              gasPrice: adjustedGasPrice
            });
            showStatus(`Batch ${batchNum} sent (${tx.hash.slice(0,10)}...), waiting for confirmation...`);
            const receipt = await Promise.race([
              tx.wait(),
              new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Transaction timeout after 5 minutes')), 300000)
              )
            ]);
            if (receipt.status === 1) {
              done += batch.length;
              progressBar.style.width = (100 * (done + failed) / total).toFixed(1) + "%";
              await updateScore();
              showStatus(`Batch ${batchNum}/${totalBatches} completed successfully! ✅`);
              if (batchNum < totalBatches) {
                await new Promise(resolve => setTimeout(resolve, 2000));
              }
            } else {
              throw new Error(`Transaction failed with status: ${receipt.status}`);
            }
          } catch (batchError) {
            failed += batch.length;
            const detailedError = getDetailedError(batchError);
            if (batchError.code === 'INSUFFICIENT_FUNDS') {
              showError(`Batch ${batchNum} failed: ${detailedError}\nStopping airdrop.`);
              break;
            } else if (batchError.message && batchError.message.includes('nonce')) {
              showError(`Batch ${batchNum} failed: ${detailedError}\nPlease reset wallet and try again.`);
              break;
            } else {
              showError(`Batch ${batchNum} failed: ${detailedError}\nContinuing with next batch...`);
              progressBar.style.width = (100 * (done + failed) / total).toFixed(1) + "%";
              await new Promise(resolve => setTimeout(resolve, 5000));
            }
          }
        }
        progressBar.style.width = "100%";
        if (done > 0 && failed === 0) {
          showStatus(`🎉 Airdrop completed successfully! All ${done} addresses processed.`);
        } else if (done > 0 && failed > 0) {
          showStatus(`⚠️ Airdrop partially completed. Success: ${done}, Failed: ${failed}`);
        } else {
          showError(`❌ Airdrop failed completely. No addresses were processed.`);
        }
      } catch (error) {
        const detailedError = getDetailedError(error);
        showError(`Airdrop failed: ${detailedError}`);
      }
      airdropInProgress = false;
      airdropBtn.disabled = filteredWallets.length === 0 || !signer;
      filterBtn.disabled = false;
    };

    if (window.ethereum) {
      window.ethereum.on('accountsChanged', async (accounts) => {
        if (accounts.length > 0) {
          try {
            provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            signer = provider.getSigner();
            userAddress = accounts[0];
            contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
            connectWalletBtn.textContent = userAddress.slice(0, 6) + "..." + userAddress.slice(-4);
            connectWalletBtn.disabled = true;
            disconnectWalletBtn.style.display = "";
            refreshScoreBtn.style.display = "";
            await updateScore();
            startScoreRefresh();
            if (filteredWallets.length > 0) {
              await updateGasEstimate();
            }
            airdropBtn.disabled = filteredWallets.length === 0 || airdropInProgress;
            showStatus('Account switched successfully');
          } catch (error) {
            showError('Error switching account: ' + error.message);
          }
        } else {
          disconnectWalletBtn.onclick();
        }
      });
      window.ethereum.on('chainChanged', async (chainId) => {
        if (chainId !== POLYGON_PARAMS.chainId) {
          showError("Wrong network detected. Please switch to Polygon network.");
          disconnectWalletBtn.onclick();
        }
      });
    }

    showWallets([]);
    airdropBtn.disabled = true;
    filterBtn.disabled = false;

    window.addEventListener('DOMContentLoaded', async () => {
      if (window.ethereum && window.ethereum.selectedAddress) {
        try {
          const currentChainId = await window.ethereum.request({ method: 'eth_chainId' });
          if (currentChainId === POLYGON_PARAMS.chainId) {
            showStatus('Auto-connecting wallet...');
            provider = new ethers.providers.Web3Provider(window.ethereum, "any");
            signer = provider.getSigner();
            userAddress = await signer.getAddress();
            contract = new ethers.Contract(AIRDROP_CONTRACT_CA, AIRDROP_ABI, signer);
            connectWalletBtn.textContent = userAddress.slice(0, 6) + "..." + userAddress.slice(-4);
            connectWalletBtn.disabled = true;
            disconnectWalletBtn.style.display = "";
            refreshScoreBtn.style.display = "";
            await updateScore();
            startScoreRefresh();
            airdropBtn.disabled = filteredWallets.length === 0 || airdropInProgress;
            showStatus('Wallet auto-connected successfully');
          }
        } catch (error) {
          // Ignore auto-connect error
        }
      }
    });
  </script>
</body>
</html>
