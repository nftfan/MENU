<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NFT FANS WORLD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0a0b0f" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <style>
    :root{
      --bg:#0a0b0f;
      --fg:#cfeaff;
      --sub:#8eaccb;
      --accent:#00e5ff;
      --accent2:#ff00d4;
      --border:rgba(160,210,255,0.25);
      --panel:#0f1218;
      --label:#0e1018;
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
    }

    /* Top half map */
    #map{
      height:45dvh; /* Slightly reduced to give space for chat */
      min-height:220px;
      width:100%;
      background:#06070a;
    }

    /* Bottom panel */
    .panel{
      box-sizing:border-box;
      width:100%;
      padding:12px 14px 40px 14px; /* Extra bottom padding for scroll */
      background:var(--panel);
      border-top:1px solid var(--border);
      display:flex;
      flex-direction:column;
      min-height:55dvh;
    }
    .bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:6px 8px;
      border:1px solid var(--border);
      border-radius:10px;
      background:linear-gradient(135deg, rgba(0,229,255,0.08), rgba(255,0,212,0.08));
      flex-shrink: 0;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .logo{
      width:18px;height:18px;border-radius:5px;
      background:linear-gradient(135deg, rgba(0,229,255,0.3), rgba(255,0,212,0.3));
      border:1px solid var(--border);
      color:white;
      display:flex;align-items:center;justify-content:center;
      font-weight:900;font-size:9px;letter-spacing:-0.2px;
      flex:0 0 auto;
    }
    .title{
      font-weight:900;font-size:10px;
      letter-spacing:0.3px;color:var(--fg);
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .hint{
      font-size:10px;
      color:var(--sub);
      white-space:nowrap;
    }

    /* Color picker row */
    .colorRow{
      margin-top:10px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-shrink: 0;
    }
    .colorPickerWrap{
      display:flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 8px;
      background:#0c0f16;
      flex:1 1 auto;
    }
    .colorLabel{
      font-size:11px;
      color:#9fb9d4;
    }
    #colorPicker{
      width:36px;
      height:24px;
      padding:0;
      border:1px solid var(--border);
      border-radius:6px;
      background:#0c0f16;
      cursor:pointer;
    }
    .btnMini{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      gap:6px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#11131a;
      color:#e8f6ff;
      font-size:12px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
    }
    .btnMini.primary {
       background:linear-gradient(135deg, var(--accent), var(--accent2));
       color:#001015;
       border-color:transparent;
    }
    .btnMini.full-width {
      width: 100%;
      margin-top: 8px;
      color: var(--sub);
      background: rgba(255,255,255,0.03);
    }

    /* Controls ABOVE the table */
    .controls{
      margin-top:10px;
      display:flex;
      gap:10px;
      flex-shrink: 0;
    }
    .btn{
      flex:1 1 0%;
      display:inline-flex;align-items:center;justify-content:center;gap:6px;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#11131a;
      color:#e8f6ff;
      font-size:12px;font-weight:800;
      cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;
    }
    .btn.primary{
      background:linear-gradient(135deg, var(--accent), var(--accent2));
      color:#001015;
      border:1px solid transparent;
    }
    .btn .material-icons{font-size:18px;line-height:1;}

    /* Tabbed Data Container */
    .data-container {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0c0f16;
      display: flex;
      flex-direction: column;
      flex-shrink: 0; 
      max-height: 200px; /* Limit height so chat is visible */
      overflow: hidden;
    }

    .tabs-nav {
      display: flex;
      border-bottom: 1px solid var(--border);
      background: #0f1218;
    }

    .tab-btn {
      flex: 1;
      padding: 10px;
      background: transparent;
      border: none;
      color: var(--sub);
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      border-bottom: 2px solid transparent;
      transition: all 0.2s;
    }

    .tab-btn.active {
      color: var(--fg);
      border-bottom-color: var(--accent);
      background: rgba(0, 229, 255, 0.03);
    }

    .tab-content {
      display: none;
      flex: 1;
      overflow-y: auto;
    }
    .tab-content.active {
      display: block;
    }

    /* CHAT SECTION */
    .chat-section {
      margin-top: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    
    .chat-controls {
      display: flex;
      gap: 8px;
    }
    #msgInput {
      flex: 1;
      background: #0c0f16;
      border: 1px solid var(--border);
      color: #fff;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      font-family: inherit;
    }
    #msgInput:focus {
      outline: none;
      border-color: var(--accent);
    }

    .chat-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .chat-bubble {
      background: linear-gradient(145deg, #13161c, #0f1116);
      border: 1px solid rgba(160,210,255,0.15);
      border-radius: 12px;
      border-top-left-radius: 2px;
      padding: 10px 12px;
      position: relative;
    }
    .chat-bubble::before {
      content: '';
      position: absolute;
      top: 0; left: -4px;
      width: 8px; height: 8px;
      background: var(--border);
      clip-path: polygon(100% 0, 0 0, 100% 100%);
      opacity: 0.5;
    }

    .bubble-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
      font-size: 10px;
      color: var(--sub);
    }
    .bubble-flag { font-size: 12px; }
    .bubble-agent { 
      font-weight: 800; 
      color: var(--accent);
      letter-spacing: 0.3px;
    }
    .bubble-country { 
      font-weight: 600;
      color: #6d88a1;
    }
    .bubble-msg {
      font-size: 12px;
      line-height: 1.4;
      color: #e5f3ff;
      word-break: break-word;
    }

    /* Tables */
    table{
      width:100%;
      border-collapse:collapse;
    }
    thead th{
      text-align:left;
      font-size:10px;
      color:#9fb9d4;
      padding:8px 12px;
      border-bottom:1px solid var(--border);
      font-weight:700;
      background: #0f1218;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    tbody td{
      font-size:11px;
      color:#d6ecff;
      padding:8px 12px;
      border-bottom:1px solid rgba(160,210,255,0.15);
      vertical-align:middle;
    }
    tbody tr:last-child td{ border-bottom:none; }
    
    .agent-cell{
      display:flex;align-items:center;gap:8px;min-width:0;
    }
    .dot{
      width:6px;height:6px;border-radius:50%;
      flex:0 0 auto;
      border:1px solid transparent;
    }
    .nameText{
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .countryText{
      display:flex;align-items:center;gap:6px;
      color:#b8d1ea;
      font-size:11px;
    }

    .grand-total-row {
      padding: 10px 12px;
      background: linear-gradient(90deg, rgba(0,229,255,0.05), transparent);
      border-bottom: 1px solid var(--border);
      font-size: 11px;
      font-weight: 800;
      color: var(--accent);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .toast{
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 300px;
      background:var(--label);
      color:#e6f7ff;
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px 10px;
      font-size:12px;
      z-index: 9999;
      display:none;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }
    .toast.show{display:block;}

    /* Leaflet overrides */
    .leaflet-container{background:#06070a;}
    .leaflet-control-attribution{ display:none !important; }
    .leaflet-control-zoom{ display:none !important; }

    .agent-label{
      background:var(--label);
      color:#cfeaff;
      border:1px solid var(--border);
      border-radius:8px;
      padding:4px 6px;
      font-size:8px;
      line-height:1.15;
      letter-spacing:0.2px;
      box-shadow:none;
    }
    .agent-label .name{font-weight:900;color:#e5f3ff;}
    .agent-label .country{color:#8eaccb;font-size:8px;}
    .agent-label .flag{margin-right:4px;}
    .labels-hidden .leaflet-tooltip{display:none !important;}
  </style>
</head>
<body>

  <!-- Top: Map -->
  <div id="map" role="application" aria-label="World map of NFT FANS agents"></div>

  <!-- Bottom: Panel -->
  <section class="panel">
    <div class="bar">
      <div class="brand">
        <div class="logo">NF</div>
        <div class="title">NFT FANS WORLD</div>
      </div>
      <div class="hint">Join the map â€” be an Agent</div>
    </div>

    <div class="colorRow">
      <div class="colorPickerWrap">
        <span class="colorLabel">Dot & Agent area color</span>
        <input type="color" id="colorPicker" value="#23ffd5" aria-label="Choose dot color" />
      </div>
      <button id="btnApplyColor" class="btnMini" title="Apply color to my agent">
        <span class="material-icons" aria-hidden="true" style="font-size:18px;">palette</span>
        Apply
      </button>
    </div>

    <div class="controls" aria-label="Actions">
      <button id="btnJoin" class="btn primary">
        <span class="material-icons" aria-hidden="true">group_add</span>
        Join
      </button>
      <button id="btnLocate" class="btn" title="Go to my location" aria-label="Go to my location">
        <span class="material-icons" aria-hidden="true">my_location</span>
        My Location
      </button>
    </div>

    <!-- Tabbed Data Container -->
    <div class="data-container">
      <div class="tabs-nav">
        <button class="tab-btn active" data-tab="latest">Latest Agents</button>
        <button class="tab-btn" data-tab="countries">By Country</button>
      </div>

      <!-- Tab 1: Latest -->
      <div id="tab-latest" class="tab-content active">
        <table aria-describedby="Latest agents joining">
          <thead>
            <tr>
              <th style="width:58%">Agent</th>
              <th style="width:42%">Country</th>
            </tr>
          </thead>
          <tbody id="latestBody">
            <!-- rows injected -->
          </tbody>
        </table>
      </div>

      <!-- Tab 2: Countries -->
      <div id="tab-countries" class="tab-content">
        <div class="grand-total-row">
          <span>GRAND TOTAL</span>
          <span id="grandTotalCount">0</span>
        </div>
        <table aria-describedby="Agents grouped by country">
          <thead>
            <tr>
              <th style="width:70%">Country</th>
              <th style="width:30%; text-align:right;">Users</th>
            </tr>
          </thead>
          <tbody id="countriesBody">
            <!-- rows injected -->
          </tbody>
        </table>
      </div>
    </div>

    <!-- Chat Section -->
    <div class="chat-section">
      <div class="chat-controls">
        <input type="text" id="msgInput" placeholder="Post a message (Agents only)..." maxlength="100" />
        <button id="btnSend" class="btnMini primary">
            <span class="material-icons" style="font-size:16px;">send</span>
        </button>
      </div>
      <div id="chatList" class="chat-list">
          <!-- Bubbles injected here -->
      </div>
      <button id="btnLoadMore" class="btnMini full-width">Show Next 10 Messages</button>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>
  </section>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Firebase (Modular SDK) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getDatabase, ref, push, set, onChildAdded, onChildChanged, onChildRemoved, onValue,
      runTransaction, serverTimestamp, update, child, get,
      query, orderByChild, startAt, endAt, limitToLast
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";

    // Firebase config
    const firebaseConfig = {
      apiKey: "AIzaSyBuBB-Cha7eLG1O7SxOTfFt8e6hVAWjkxI",
      authDomain: "tokentransfer-4a9b3.firebaseapp.com",
      databaseURL: "https://tokentransfer-4a9b3-default-rtdb.firebaseio.com",
      projectId: "tokentransfer-4a9b3",
      storageBucket: "tokentransfer-4a9b3.firebasestorage.app",
      messagingSenderId: "205455490321",
      appId: "1:205455490321:web:9919f5dde059316c9320b0",
      measurementId: "G-Y6CVEDL9XH"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const agentsRef = ref(db, "agents");
    const counterRef = ref(db, "counters/agents");
    const messagesRef = ref(db, "messages");

    const DEFAULT_COLOR = "#23ffd5";

    // Map setup
    const worldBounds = L.latLngBounds(L.latLng(-85, -180), L.latLng(85, 180));
    const map = L.map('map', {
      zoomControl: false,
      attributionControl: false,
      minZoom: 2,
      maxZoom: 19,
      maxBounds: worldBounds,
      maxBoundsViscosity: 1.0,
      worldCopyJump: false
    });
    const tiles = L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
      { maxZoom: 19, noWrap: true, bounds: worldBounds }
    ).addTo(map);
    map.setView([20, 0], 2);
    window.addEventListener('resize', () => map.invalidateSize(), { passive: true });

    map.createPane('linesPane');
    map.getPane('linesPane').style.zIndex = 399;
    const linesGroup = L.layerGroup().addTo(map);

    // UI helpers
    const toastEl = document.getElementById('toast');
    function toast(msg, ms = 2800) {
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(() => toastEl.classList.remove('show'), ms);
    }
    function pad4(n){ return String(n).padStart(4,'0'); }
    function countryCodeToEmoji(countryCode){
      if(!countryCode || countryCode.length !== 2) return "ðŸ³ï¸";
      const cps = [...countryCode.toUpperCase()].map(c => 127397 + c.charCodeAt());
      return String.fromCodePoint(...cps);
    }
    function buildLabel(agent){
      const flag = countryCodeToEmoji(agent.countryCode);
      return `
        <div class="label">
          <span class="flag">${flag}</span>
          <span class="name">${agent.displayName}</span><br/>
          <span class="country">${agent.countryName || "Unknown"}</span>
        </div>
      `;
    }

    // Short country name helper
    function getShortCountryName(name) {
      if (!name) return "Unknown";
      const map = {
        "United States": "USA",
        "United States of America": "USA",
        "United Kingdom": "UK",
        "Great Britain": "UK",
        "United Arab Emirates": "UAE"
      };
      return map[name] || name;
    }

    const LABELS_MIN_ZOOM = 11;
    function refreshLabelVisibility(){
      const c = map.getContainer();
      if(map.getZoom() < LABELS_MIN_ZOOM) c.classList.add('labels-hidden');
      else c.classList.remove('labels-hidden');
    }
    map.on('zoomend', refreshLabelVisibility);
    refreshLabelVisibility();

    // Markers & Store
    const DOT_RADIUS = 3;
    const markers = new Map();
    const agentsStore = new Map(); // key -> data

    function upsertMarker(key, agent){
      const pos = [agent.lat, agent.lng];
      const html = buildLabel(agent);
      const color = agent.color || DEFAULT_COLOR;

      if(markers.has(key)){
        const rec = markers.get(key);
        rec.dot.setLatLng(pos);
        rec.dot.setStyle({ color, fillColor: color, opacity: 0.9, fillOpacity: 0.95 });
        if(rec.dot.getTooltip()) rec.dot.setTooltipContent(html);
        rec.circle.setLatLng(pos);
        rec.circle.setStyle({ color, fillColor: color, opacity: 0.6, fillOpacity: 0.08 });
      } else {
        const dot = L.circleMarker(pos, {
          radius: DOT_RADIUS,
          color: color,
          weight: 1,
          opacity: 0.9,
          fillColor: color,
          fillOpacity: 0.95
        }).addTo(map);

        dot.bindTooltip(html, {
          permanent: true,
          direction: 'top',
          className: 'agent-label',
          offset: [0, -6]
        });

        const circle = L.circle(pos, {
          radius: 50,
          color: color,
          weight: 1,
          opacity: 0.6,
          fillColor: color,
          fillOpacity: 0.08
        }).addTo(map);

        markers.set(key, { dot, circle });
      }
    }
    function removeMarker(key){
      const rec = markers.get(key);
      if(rec){
        map.removeLayer(rec.dot);
        map.removeLayer(rec.circle);
        markers.delete(key);
      }
    }

    function upsertStore(key, data){
      if(!data || typeof data.lat !== "number" || typeof data.lng !== "number") return;
      agentsStore.set(key, { ...data });
      recomputeLines();
      renderLatest(); // Re-render tables
    }
    function removeFromStore(key){
      agentsStore.delete(key);
      recomputeLines();
      renderLatest();
    }

    // MST Lines
    function recomputeLines(){
      linesGroup.clearLayers();
      const nodes = Array.from(agentsStore.entries()).map(([key, v]) => ({
        key, lat: v.lat, lng: v.lng, color: v.color
      }));
      const n = nodes.length;
      if(n < 2) return;
      const inMST = Array(n).fill(false);
      const minCost = Array(n).fill(Infinity);
      const parent = Array(n).fill(-1);
      minCost[0] = 0;
      function dist2(i, j){
        const dx = nodes[i].lat - nodes[j].lat;
        const dy = nodes[i].lng - nodes[j].lng;
        return dx*dx + dy*dy;
      }
      for(let k = 0; k < n; k++){
        let u = -1, best = Infinity;
        for(let i = 0; i < n; i++){
          if(!inMST[i] && minCost[i] < best){ best = minCost[i]; u = i; }
        }
        if(u === -1) break;
        inMST[u] = true;
        for(let v = 0; v < n; v++){
          if(!inMST[v]){
            const d2 = dist2(u, v);
            if(d2 < minCost[v]){ minCost[v] = d2; parent[v] = u; }
          }
        }
      }
      for(let v = 0; v < n; v++){
        const u = parent[v];
        if(u !== -1){
          const a = nodes[u];
          const b = nodes[v];
          const line = L.polyline([[a.lat, a.lng], [b.lat, b.lng]], {
            color: a.color || DEFAULT_COLOR,
            weight: 2,
            opacity: 0.7,
            pane: 'linesPane'
          });
          line.addTo(linesGroup);
        }
      }
    }

    // Live Sync
    onChildAdded(agentsRef, (snap) => {
      const data = snap.val();
      if(data) upsertStore(snap.key, data);
      if(data && typeof data.lat==="number" && typeof data.lng==="number") upsertMarker(snap.key, data);
    });
    onChildChanged(agentsRef, (snap) => {
      const data = snap.val();
      if(data) upsertStore(snap.key, data);
      if(data && typeof data.lat==="number" && typeof data.lng==="number") upsertMarker(snap.key, data);
    });
    onChildRemoved(agentsRef, (snap) => {
      removeFromStore(snap.key);
      removeMarker(snap.key);
    });

    // Geo & Logic
    function getCurrentPosition(options = { enableHighAccuracy:true, timeout:15000, maximumAge:0 }){
      return new Promise((resolve, reject) => {
        if(!navigator.geolocation){ reject(new Error("Geolocation not supported")); return; }
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });
    }
    function toRad(x){ return x * Math.PI / 180; }
    function haversineMeters(lat1, lon1, lat2, lon2){
      const R = 6371000;
      const dLat = toRad(lat2-lat1);
      const dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }
    async function nearAgentExists(lat, lng, radiusMeters = 50, excludeKey = null){
      const dLat = radiusMeters / 111320;
      const cosLat = Math.cos(toRad(lat)) || 1e-6;
      const dLng = radiusMeters / (111320 * cosLat);
      const minLat = lat - dLat, maxLat = lat + dLat;
      const minLng = lng - dLng, maxLng = lng + dLng;
      const q = query(agentsRef, orderByChild("lat"), startAt(minLat), endAt(maxLat));
      const snap = await get(q);
      let found = false;
      snap.forEach(childSnap => {
        if(found) return;
        const key = childSnap.key;
        const v = childSnap.val() || {};
        if(excludeKey && key === excludeKey) return;
        if(typeof v.lng !== "number" || typeof v.lat !== "number") return;
        if(v.lng < minLng || v.lng > maxLng) return;
        const d = haversineMeters(lat, lng, v.lat, v.lng);
        if(d <= radiusMeters) found = true;
      });
      return found;
    }
    async function reverseGeocodeCountry(lat, lng){
      const url = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lng)}&localityLanguage=en`;
      const res = await fetch(url, { cache: "no-store" });
      if(!res.ok) throw new Error("Reverse geocoding failed");
      const data = await res.json();
      return { countryName: data.countryName || "Unknown", countryCode: data.countryCode || "" };
    }

    // Inputs
    const btnJoin = document.getElementById('btnJoin');
    const btnLocate = document.getElementById('btnLocate');
    const colorPicker = document.getElementById('colorPicker');
    const btnApplyColor = document.getElementById('btnApplyColor');

    const savedColor = localStorage.getItem("nftFansColor");
    if(savedColor) colorPicker.value = savedColor;
    colorPicker.addEventListener('input', () => localStorage.setItem("nftFansColor", colorPicker.value));

    btnApplyColor.addEventListener('click', async () => {
      const key = localStorage.getItem("nftFansAgentKey");
      const color = colorPicker.value || DEFAULT_COLOR;
      localStorage.setItem("nftFansColor", color);
      if(!key){ toast("Color saved locally."); return; }
      try{
        await update(child(agentsRef, key), { color, updatedAt: serverTimestamp() });
        toast("Dot color updated.");
      }catch(e){ toast("Failed to update color."); }
    });

    btnLocate.addEventListener('click', async () => {
      try{
        toast("Locating...");
        const pos = await getCurrentPosition();
        map.flyTo([pos.coords.latitude, pos.coords.longitude], Math.max(map.getZoom(), 14), { duration: 0.8 });
        toast("Centered on your location");
      }catch(e){ toast("Unable to get your location."); }
    });

    btnJoin.addEventListener('click', async () => {
      btnJoin.disabled = true;
      try{
        toast("Requesting location...");
        const pos = await getCurrentPosition();
        const lat = pos.coords.latitude, lng = pos.coords.longitude;
        const existingKey = localStorage.getItem("nftFansAgentKey");

        if(!existingKey){
          const tooClose = await nearAgentExists(lat, lng, 50);
          if(tooClose){ toast("Area occupied (50m rule)."); return; }
        }
        let country = { countryName: "Unknown", countryCode: "" };
        try{ country = await reverseGeocodeCountry(lat, lng); }catch{}
        const color = colorPicker.value || DEFAULT_COLOR;

        let agentKey = existingKey;
        if(!existingKey){
          const tx = await runTransaction(counterRef, (c) => (c || 0) + 1);
          if(!tx.committed) throw new Error("Alloc failed");
          const seq = tx.snapshot.val();
          const displayName = `NFT FANS AGENT #${pad4(seq)}`;
          const newRef = push(agentsRef);
          agentKey = newRef.key;
          await set(newRef, {
            displayName, seq, countryName: country.countryName, countryCode: country.countryCode,
            color, lat, lng, createdAt: serverTimestamp(), updatedAt: serverTimestamp()
          });
          localStorage.setItem("nftFansAgentKey", agentKey);
          localStorage.setItem("nftFansColor", color);
          toast("Welcome, Agent!");
        } else {
          const snap = await get(child(agentsRef, existingKey));
          const d = snap.val() || {};
          const seq = d.seq || 0;
          const displayName = d.displayName || (seq ? `NFT FANS AGENT #${pad4(seq)}` : "NFT FANS AGENT");
          await update(child(agentsRef, existingKey), {
            displayName, seq, countryName: country.countryName, countryCode: country.countryCode,
            color, lat, lng, updatedAt: serverTimestamp()
          });
          toast("Location updated.");
        }
        map.flyTo([lat, lng], Math.max(map.getZoom(), 15), { duration: 0.8 });
      }catch(e){ console.error(e); toast("Join failed."); }
      finally{ btnJoin.disabled = false; }
    });

    // ========== Tabs Logic ==========
    const tabs = document.querySelectorAll('.tab-btn');
    const contents = document.querySelectorAll('.tab-content');
    tabs.forEach(btn => {
      btn.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        contents.forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(`tab-${btn.dataset.tab}`).classList.add('active');
      });
    });

    // ========== Rendering Tables ==========
    const latestBody = document.getElementById('latestBody');
    const countriesBody = document.getElementById('countriesBody');
    const grandTotalEl = document.getElementById('grandTotalCount');

    function renderLatest(){
      // 1. Latest List (First Tab)
      const allAgents = Array.from(agentsStore.values());
      const sorted = [...allAgents].sort((a,b) => (b.createdAt||0) - (a.createdAt||0));
      const displayList = sorted.slice(0, 30);

      latestBody.innerHTML = displayList.map(a => {
        const f = countryCodeToEmoji(a.countryCode || "");
        const name = a.displayName || "NFT FANS AGENT";
        const country = a.countryName || "Unknown";
        const color = a.color || DEFAULT_COLOR;
        return `
          <tr>
            <td>
              <div class="agent-cell">
                <span class="dot" style="background:${color}; border-color:${color};"></span>
                <span class="nameText">${name}</span>
              </div>
            </td>
            <td>
              <div class="countryText"><span>${f}</span><span>${country}</span></div>
            </td>
          </tr>
        `;
      }).join("");

      // 2. Countries Grouped (Second Tab)
      const grouped = {};
      let totalCount = 0;
      allAgents.forEach(a => {
        const cCode = a.countryCode || "XX";
        const cName = a.countryName || "Unknown";
        if(!grouped[cCode]) grouped[cCode] = { code: cCode, name: cName, count: 0 };
        grouped[cCode].count++;
        totalCount++;
      });
      grandTotalEl.textContent = totalCount;

      const groupArr = Object.values(grouped).sort((a,b) => b.count - a.count);
      countriesBody.innerHTML = groupArr.map(g => {
        const f = countryCodeToEmoji(g.code === "XX" ? "" : g.code);
        const shortName = getShortCountryName(g.name);
        return `
          <tr>
            <td>
              <div class="countryText" style="font-size:12px;">
                <span style="font-size:14px; margin-right:6px;">${f}</span>
                <span style="font-weight:700; color:#e5f3ff;">${shortName}</span>
              </div>
            </td>
            <td style="text-align:right;">
              <span style="color:var(--accent); font-weight:800; font-size:12px;">(${g.count})</span>
            </td>
          </tr>
        `;
      }).join("");
    }

    // ========== Chat Logic ==========
    const msgInput = document.getElementById('msgInput');
    const btnSend = document.getElementById('btnSend');
    const chatList = document.getElementById('chatList');
    const btnLoadMore = document.getElementById('btnLoadMore');
    
    let messageLimit = 10;
    let messageUnsub = null;

    // Send Message
    btnSend.addEventListener('click', async () => {
        const text = msgInput.value.trim();
        if(!text) return;

        const key = localStorage.getItem("nftFansAgentKey");
        if(!key){
            toast("Please Join first to post.");
            return;
        }

        // Fetch user info from local store
        const agent = agentsStore.get(key);
        if(!agent){
            toast("Agent data not found. Try joining again.");
            return;
        }

        const newMsg = {
            agentKey: key,
            agentName: agent.displayName,
            countryCode: agent.countryCode || "",
            countryName: getShortCountryName(agent.countryName || "Unknown"),
            text: text,
            timestamp: serverTimestamp()
        };

        try {
            await push(messagesRef, newMsg);
            msgInput.value = "";
        } catch(e) {
            console.error(e);
            toast("Failed to send.");
        }
    });

    // Load/Listen Messages
    function subscribeToMessages(){
        if(messageUnsub) messageUnsub(); // Detach previous listener

        // We listen to the last N messages
        const q = query(messagesRef, orderByChild('timestamp'), limitToLast(messageLimit));
        
        messageUnsub = onValue(q, (snapshot) => {
            const val = snapshot.val();
            if(!val) {
                chatList.innerHTML = "";
                return;
            }

            // Convert object to array
            const arr = Object.values(val);

            // Filter out undefined names & sort LATEST ON TOP (descending)
            const sorted = arr
                .filter(m => m.agentName && m.agentName !== "undefined" && m.text)
                .sort((a,b) => (b.timestamp||0) - (a.timestamp||0));

            chatList.innerHTML = sorted.map(m => {
                const f = countryCodeToEmoji(m.countryCode);
                // Safe check for text
                const safeText = m.text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
                return `
                    <div class="chat-bubble">
                        <div class="bubble-header">
                            <span class="bubble-flag">${f}</span>
                            <span class="bubble-agent">${m.agentName}</span>
                            <span class="bubble-country">(${m.countryName})</span>
                        </div>
                        <div class="bubble-msg">${safeText}</div>
                    </div>
                `;
            }).join("");
        });
    }

    // Load More
    btnLoadMore.addEventListener('click', () => {
        messageLimit += 10;
        subscribeToMessages();
    });

    // Init
    (async function initData(){
      try{
        const snap = await get(agentsRef);
        snap.forEach(child => {
          const data = child.val();
          if(data){
            upsertStore(child.key, data);
            if(typeof data.lat==="number" && typeof data.lng==="number") upsertMarker(child.key, data);
          }
        });
        renderLatest();
      }catch(e){ console.warn("Load failed", e); }
      
      // Start chat listener
      subscribeToMessages();
    })();
  </script>
</body>
</html>
