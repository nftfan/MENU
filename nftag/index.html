<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>NFT FANS WORLD</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0a0b0f" />

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <!-- Material Icons -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <style>
    :root{
      --bg:#0a0b0f;
      --fg:#cfeaff;
      --sub:#8eaccb;
      --accent:#00e5ff;
      --accent2:#ff00d4;
      --border:rgba(160,210,255,0.25);
      --panel:#0f1218;
      --label:#0e1018;
    }
    html,body{
      height:100%;
      margin:0;
      background:var(--bg);
      color:var(--fg);
      font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", sans-serif;
    }

    /* Top half map (no repeat) */
    #map{
      height:50dvh; /* half screen */
      min-height:260px;
      width:100%;
      background:#06070a;
    }

    /* Bottom panel with sleek title, color control, buttons, and table */
    .panel{
      box-sizing:border-box;
      width:100%;
      padding:12px 14px calc(env(safe-area-inset-bottom) + 14px);
      background:var(--panel);
      border-top:1px solid var(--border);
    }
    .bar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      padding:6px 8px;
      border:1px solid var(--border);
      border-radius:10px;
      background:linear-gradient(135deg, rgba(0,229,255,0.08), rgba(255,0,212,0.08));
    }
    .brand{
      display:flex;
      align-items:center;
      gap:8px;
      min-width:0;
    }
    .logo{
      width:18px;height:18px;border-radius:5px;
      background:linear-gradient(135deg, rgba(0,229,255,0.3), rgba(255,0,212,0.3));
      border:1px solid var(--border);
      color:white;
      display:flex;align-items:center;justify-content:center;
      font-weight:900;font-size:9px;letter-spacing:-0.2px;
      flex:0 0 auto;
    }
    .title{
      font-weight:900;font-size:10px; /* 10px as requested */
      letter-spacing:0.3px;color:var(--fg);
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .hint{
      font-size:10px; /* 10px as requested */
      color:var(--sub);
      white-space:nowrap;
    }

    /* Color picker row */
    .colorRow{
      margin-top:10px;
      display:flex;
      align-items:center;
      gap:10px;
    }
    .colorPickerWrap{
      display:flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 8px;
      background:#0c0f16;
      flex:1 1 auto;
    }
    .colorLabel{
      font-size:11px;
      color:#9fb9d4;
    }
    #colorPicker{
      width:36px;
      height:24px;
      padding:0;
      border:1px solid var(--border);
      border-radius:6px;
      background:#0c0f16;
      cursor:pointer;
    }
    .btnMini{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:8px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#11131a;
      color:#e8f6ff;
      font-size:12px;
      font-weight:800;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
    }

    /* Controls ABOVE the table */
    .controls{
      margin-top:10px;
      display:flex;
      gap:10px;
    }
    .btn{
      flex:1 1 0%;
      display:inline-flex;align-items:center;justify-content:center;gap:6px;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#11131a;
      color:#e8f6ff;
      font-size:12px;font-weight:800;
      cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;
    }
    .btn.primary{
      background:linear-gradient(135deg, var(--accent), var(--accent2));
      color:#001015;
      border:1px solid transparent;
    }
    .btn .material-icons{font-size:18px;line-height:1;}

    .list-container{
      margin-top:12px;
      border:1px solid var(--border);
      border-radius:10px;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    /* Tab Headers */
    .tabs{
      display:flex;
      background:#0c0f16;
      border-bottom:1px solid var(--border);
    }
    .tab-btn{
      flex:1;
      padding:8px;
      font-size:10px;
      color:var(--sub);
      text-align:center;
      cursor:pointer;
      font-weight:700;
      background:transparent;
      border:none;
      border-bottom:2px solid transparent;
    }
    .tab-btn.active{
      color:var(--accent);
      border-bottom-color:var(--accent);
      background:rgba(0,229,255,0.05);
    }

    /* Tab Content Areas */
    .tab-content{
      display:none;
    }
    .tab-content.active{
      display:block;
    }

    /* Grand total row style */
    .grand-total-row td {
        font-weight: 800;
        color: var(--accent);
        border-top: 2px solid var(--border);
    }

    table{
      width:100%;
      border-collapse:collapse;
      background:#0c0f16;
    }
    thead th{
      text-align:left;
      font-size:10px;
      color:#9fb9d4;
      padding:6px 8px;
      border-bottom:1px solid var(--border);
      font-weight:700;
    }
    tbody td{
      font-size:11px;
      color:#d6ecff;
      padding:8px 8px;
      border-bottom:1px solid rgba(160,210,255,0.15);
      vertical-align:middle;
    }
    tbody tr:last-child td{ border-bottom:none; }
    .agent-cell{
      display:flex;align-items:center;gap:8px;min-width:0;
    }
    .dot{
      width:6px;height:6px;border-radius:50%;
      flex:0 0 auto;
      border:1px solid transparent;
    }
    .nameText{
      white-space:nowrap;overflow:hidden;text-overflow:ellipsis;
    }
    .countryText{
      display:flex;align-items:center;gap:6px;
      color:#b8d1ea;
      font-size:11px;
    }

    .toast{
      margin-top:10px;
      background:var(--label);
      color:#e6f7ff;
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px 10px;
      font-size:12px;
      display:none;
    }
    .toast.show{display:block;}

    /* Leaflet dark UI: remove watermark and zoom buttons */
    .leaflet-container{background:#06070a;}
    .leaflet-control-attribution{ display:none !important; } /* hide watermark */
    .leaflet-control-zoom{ display:none !important; }        /* hide zoom buttons */

    /* Micro labels (max 8px) + hide at low zoom */
    .agent-label{
      background:var(--label);
      color:#cfeaff;
      border:1px solid var(--border);
      border-radius:8px;
      padding:4px 6px;
      font-size:8px; /* MAX 8px */
      line-height:1.15;
      letter-spacing:0.2px;
      box-shadow:none;
    }
    .agent-label .name{font-weight:900;color:#e5f3ff;}
    .agent-label .country{color:#8eaccb;font-size:8px;}
    .agent-label .flag{margin-right:4px;}
    .labels-hidden .leaflet-tooltip{display:none !important;}
  </style>
</head>
<body>

  <!-- Top: Map (half screen) -->
  <div id="map" role="application" aria-label="World map of NFT FANS agents"></div>

  <!-- Bottom: Sleek title, color control, buttons ABOVE table, and table -->
  <section class="panel">
    <div class="bar">
      <div class="brand">
        <div class="logo">NF</div>
        <div class="title">NFT FANS WORLD</div>
      </div>
      <div class="hint">Join the map â€” be an Agent</div>
    </div>

    <div class="colorRow">
      <div class="colorPickerWrap">
        <span class="colorLabel">Dot & Agent area color</span>
        <input type="color" id="colorPicker" value="#23ffd5" aria-label="Choose dot color" />
      </div>
      <button id="btnApplyColor" class="btnMini" title="Apply color to my agent">
        <span class="material-icons" aria-hidden="true" style="font-size:18px;">palette</span>
        Apply
      </button>
    </div>

    <!-- Buttons ABOVE the table -->
    <div class="controls" aria-label="Actions">
      <button id="btnJoin" class="btn primary">
        <span class="material-icons" aria-hidden="true">group_add</span>
        Join
      </button>
      <button id="btnLocate" class="btn" title="Go to my location" aria-label="Go to my location">
        <span class="material-icons" aria-hidden="true">my_location</span>
        My Location
      </button>
    </div>

    <!-- Tabbed List Container -->
    <div class="list-container" aria-label="Agents lists">
      <div class="tabs">
        <button class="tab-btn active" data-tab="latest">Latest Agents</button>
        <button class="tab-btn" data-tab="country">By Country</button>
      </div>

      <!-- Tab 1: Latest Agents -->
      <div id="tab-latest" class="tab-content active">
        <table aria-describedby="Latest agents joining and their country">
            <thead>
            <tr>
                <th style="width:58%">Agent</th>
                <th style="width:42%">Country</th>
            </tr>
            </thead>
            <tbody id="latestBody">
            <!-- rows injected -->
            </tbody>
        </table>
      </div>

      <!-- Tab 2: By Country -->
      <div id="tab-country" class="tab-content">
        <table aria-describedby="Agents grouped by country">
            <thead>
            <tr>
                <th style="width:70%">Country</th>
                <th style="width:30%; text-align:right;">Users</th>
            </tr>
            </thead>
            <tbody id="countryBody">
            <!-- rows injected -->
            </tbody>
            <tfoot id="countryFoot">
                <!-- Grand total injected here -->
            </tfoot>
        </table>
      </div>
    </div>

    <div id="toast" class="toast" role="status" aria-live="polite"></div>
  </section>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Firebase (Modular SDK) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getDatabase, ref, push, set, onChildAdded, onChildChanged, onChildRemoved,
      runTransaction, serverTimestamp, update, child, get,
      query, orderByChild, startAt, endAt, limitToLast
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";

    // Firebase initialization (your config)
    const firebaseConfig = {
      apiKey: "AIzaSyBuBB-Cha7eLG1O7SxOTfFt8e6hVAWjkxI",
      authDomain: "tokentransfer-4a9b3.firebaseapp.com",
      databaseURL: "https://tokentransfer-4a9b3-default-rtdb.firebaseio.com",
      projectId: "tokentransfer-4a9b3",
      storageBucket: "tokentransfer-4a9b3.firebasestorage.app",
      messagingSenderId: "205455490321",
      appId: "1:205455490321:web:9919f5dde059316c9320b0",
      measurementId: "G-Y6CVEDL9XH"
    };
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);

    const agentsRef = ref(db, "agents");
    const counterRef = ref(db, "counters/agents");

    const DEFAULT_COLOR = "#23ffd5";

    // Map setup: dark, no wrap (map shows only once), remove watermark & zoom buttons
    const worldBounds = L.latLngBounds(L.latLng(-85, -180), L.latLng(85, 180));
    const map = L.map('map', {
      zoomControl: false,        // hide zoom buttons
      attributionControl: false, // hide bottom-right watermark
      minZoom: 2,
      maxZoom: 19,
      maxBounds: worldBounds,
      maxBoundsViscosity: 1.0,
      worldCopyJump: false
    });
    const tiles = L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png",
      {
        maxZoom: 19,
        noWrap: true,
        bounds: worldBounds
      }
    ).addTo(map);
    map.setView([20, 0], 2);
    window.addEventListener('resize', () => map.invalidateSize(), { passive: true });

    // Create a dedicated pane for lines so they render behind markers
    map.createPane('linesPane');
    map.getPane('linesPane').style.zIndex = 399;

    // Group to manage connection lines
    const linesGroup = L.layerGroup().addTo(map);

    // UI helpers
    const toastEl = document.getElementById('toast');
    function toast(msg, ms = 2800) {
      toastEl.textContent = msg;
      toastEl.classList.add('show');
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(() => toastEl.classList.remove('show'), ms);
    }
    function pad4(n){ return String(n).padStart(4,'0'); }
    function countryCodeToEmoji(countryCode){
      if(!countryCode || countryCode.length !== 2) return "ðŸ³ï¸";
      const cps = [...countryCode.toUpperCase()].map(c => 127397 + c.charCodeAt());
      return String.fromCodePoint(...cps);
    }
    function buildLabel(agent){
      const flag = countryCodeToEmoji(agent.countryCode);
      return `
        <div class="label">
          <span class="flag">${flag}</span>
          <span class="name">${agent.displayName}</span><br/>
          <span class="country">${agent.countryName || "Unknown"}</span>
        </div>
      `;
    }

    // Label visibility control
    const LABELS_MIN_ZOOM = 11;
    function refreshLabelVisibility(){
      const c = map.getContainer();
      if(map.getZoom() < LABELS_MIN_ZOOM) c.classList.add('labels-hidden');
      else c.classList.remove('labels-hidden');
    }
    map.on('zoomend', refreshLabelVisibility);
    refreshLabelVisibility();

    // Markers and Agent area (50m circle), both use agent.color
    const DOT_RADIUS = 3;
    const markers = new Map(); // key -> { dot, circle }
    function upsertMarker(key, agent){
      const pos = [agent.lat, agent.lng];
      const html = buildLabel(agent);
      const color = agent.color || DEFAULT_COLOR;

      if(markers.has(key)){
        const rec = markers.get(key);
        rec.dot.setLatLng(pos);
        rec.dot.setStyle({ color, fillColor: color, opacity: 0.9, fillOpacity: 0.95 });
        if(rec.dot.getTooltip()) rec.dot.setTooltipContent(html);
        rec.circle.setLatLng(pos);
        rec.circle.setStyle({ color, fillColor: color, opacity: 0.6, fillOpacity: 0.08 });
      } else {
        const dot = L.circleMarker(pos, {
          radius: DOT_RADIUS,
          color: color,
          weight: 1,
          opacity: 0.9,
          fillColor: color,
          fillOpacity: 0.95
        }).addTo(map);

        dot.bindTooltip(html, {
          permanent: true,
          direction: 'top',
          className: 'agent-label',
          offset: [0, -6]
        });

        const circle = L.circle(pos, {
          radius: 50,              // 50 meters
          color: color,
          weight: 1,
          opacity: 0.6,
          fillColor: color,
          fillOpacity: 0.08
        }).addTo(map);

        markers.set(key, { dot, circle });
      }
    }
    function removeMarker(key){
      const rec = markers.get(key);
      if(rec){
        map.removeLayer(rec.dot);
        map.removeLayer(rec.circle);
        markers.delete(key);
      }
    }

    // Store for all agents (for connection lines)
    const agentsStore = new Map(); // key -> {lat,lng,color,createdAt,updatedAt,displayName,countryName,countryCode}

    function upsertStore(key, data){
      if(!data || typeof data.lat !== "number" || typeof data.lng !== "number") return;
      agentsStore.set(key, {
        lat: data.lat,
        lng: data.lng,
        color: data.color || DEFAULT_COLOR,
        createdAt: data.createdAt || 0,
        updatedAt: data.updatedAt || 0,
        displayName: data.displayName || "NFT FANS AGENT",
        countryName: data.countryName || "Unknown",
        countryCode: data.countryCode || ""
      });
      recomputeLines();
      renderCountryStats(); // Refresh stats whenever data updates
    }
    function removeFromStore(key){
      agentsStore.delete(key);
      recomputeLines();
      renderCountryStats(); // Refresh stats whenever data updates
    }

    // ---------- Non-crossing connections via Euclidean Minimum Spanning Tree (Prim's algorithm) ----------
    // MST is planar (no edges cross), so drawing MST edges guarantees no line cuts another line.
    function recomputeLines(){
      linesGroup.clearLayers();
      const nodes = Array.from(agentsStore.entries()).map(([key, v]) => ({
        key, lat: v.lat, lng: v.lng, color: v.color
      }));

      const n = nodes.length;
      if(n < 2) return;

      // Prim's algorithm on squared Euclidean distance in lat/lng space
      const inMST = Array(n).fill(false);
      const minCost = Array(n).fill(Infinity);
      const parent = Array(n).fill(-1);

      // Start from node 0
      minCost[0] = 0;

      function dist2(i, j){
        const dx = nodes[i].lat - nodes[j].lat;
        const dy = nodes[i].lng - nodes[j].lng;
        return dx*dx + dy*dy;
      }

      for(let k = 0; k < n; k++){
        // pick the non-MST node with minimum cost
        let u = -1, best = Infinity;
        for(let i = 0; i < n; i++){
          if(!inMST[i] && minCost[i] < best){
            best = minCost[i];
            u = i;
          }
        }
        if(u === -1) break; // disconnected safeguard
        inMST[u] = true;

        // update costs for neighbors
        for(let v = 0; v < n; v++){
          if(!inMST[v]){
            const d2 = dist2(u, v);
            if(d2 < minCost[v]){
              minCost[v] = d2;
              parent[v] = u;
            }
          }
        }
      }

      // Draw MST edges
      for(let v = 0; v < n; v++){
        const u = parent[v];
        if(u !== -1){
          const a = nodes[u];
          const b = nodes[v];
          const line = L.polyline([[a.lat, a.lng], [b.lat, b.lng]], {
            color: a.color || DEFAULT_COLOR, // color by source node (parent)
            weight: 2,
            opacity: 0.7,
            pane: 'linesPane'
          });
          line.addTo(linesGroup);
        }
      }
    }

    // Live sync agents on map, table, and lines
    onChildAdded(agentsRef, (snap) => {
      const key = snap.key, data = snap.val();
      if(data && typeof data.lat === "number" && typeof data.lng === "number"){
        upsertMarker(key, data);
        upsertStore(key, data);
      }
      upsertLatest(key, data);
    });
    onChildChanged(agentsRef, (snap) => {
      const key = snap.key, data = snap.val();
      if(data && typeof data.lat === "number" && typeof data.lng === "number"){
        upsertMarker(key, data);
        upsertStore(key, data);
      }
      upsertLatest(key, data);
    });
    onChildRemoved(agentsRef, (snap) => {
      const key = snap.key;
      removeMarker(key);
      removeLatest(key);
      removeFromStore(key);
    });

    // Geo helpers and proximity rule (no new joins within 50m)
    function getCurrentPosition(options = { enableHighAccuracy:true, timeout:15000, maximumAge:0 }){
      return new Promise((resolve, reject) => {
        if(!navigator.geolocation){ reject(new Error("Geolocation not supported")); return; }
        navigator.geolocation.getCurrentPosition(resolve, reject, options);
      });
    }
    function toRad(x){ return x * Math.PI / 180; }
    function haversineMeters(lat1, lon1, lat2, lon2){
      const R = 6371000;
      const dLat = toRad(lat2-lat1);
      const dLon = toRad(lon2-lon1);
      const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
      return 2*R*Math.asin(Math.sqrt(a));
    }
    async function nearAgentExists(lat, lng, radiusMeters = 50, excludeKey = null){
      // Bounding box in degrees
      const dLat = radiusMeters / 111320; // ~ meters per degree latitude
      const cosLat = Math.cos(toRad(lat)) || 1e-6;
      const dLng = radiusMeters / (111320 * cosLat);

      const minLat = lat - dLat, maxLat = lat + dLat;
      const minLng = lng - dLng, maxLng = lng + dLng;

      const q = query(agentsRef, orderByChild("lat"), startAt(minLat), endAt(maxLat));
      const snap = await get(q);
      let found = false;
      snap.forEach(childSnap => {
        if(found) return;
        const key = childSnap.key;
        const v = childSnap.val() || {};
        if(excludeKey && key === excludeKey) return;
        if(typeof v.lng !== "number" || typeof v.lat !== "number") return;
        if(v.lng < minLng || v.lng > maxLng) return;
        const d = haversineMeters(lat, lng, v.lat, v.lng);
        if(d <= radiusMeters) found = true;
      });
      return found;
    }

    // Reverse geocoding (country)
    async function reverseGeocodeCountry(lat, lng){
      const url = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${encodeURIComponent(lat)}&longitude=${encodeURIComponent(lng)}&localityLanguage=en`;
      const res = await fetch(url, { cache: "no-store" });
      if(!res.ok) throw new Error("Reverse geocoding failed");
      const data = await res.json();
      return { countryName: data.countryName || "Unknown", countryCode: data.countryCode || "" };
    }

    // Buttons and color handling
    const btnJoin = document.getElementById('btnJoin');
    const btnLocate = document.getElementById('btnLocate');
    const colorPicker = document.getElementById('colorPicker');
    const btnApplyColor = document.getElementById('btnApplyColor');

    // Load preferred color
    const savedColor = localStorage.getItem("nftFansColor");
    if(savedColor) colorPicker.value = savedColor;
    colorPicker.addEventListener('input', () => {
      localStorage.setItem("nftFansColor", colorPicker.value);
    });

    btnApplyColor.addEventListener('click', async () => {
      const key = localStorage.getItem("nftFansAgentKey");
      const color = colorPicker.value || DEFAULT_COLOR;
      localStorage.setItem("nftFansColor", color);

      if(!key){
        toast("Color saved locally. Join to publish your color.");
        return;
      }
      try{
        await update(child(agentsRef, key), { color, updatedAt: serverTimestamp() });
        toast("Dot color updated.");
      }catch(e){
        console.error(e);
        toast("Failed to update color.");
      }
    });

    btnLocate.addEventListener('click', async () => {
      try{
        toast("Locating...");
        const pos = await getCurrentPosition();
        const { latitude:lat, longitude:lng } = pos.coords;
        map.flyTo([lat,lng], Math.max(map.getZoom(), 14), { duration: 0.8 });
        toast("Centered on your location");
      }catch(e){
        console.error(e); toast("Unable to get your location. Please allow permission.");
      }
    });

    btnJoin.addEventListener('click', async () => {
      btnJoin.disabled = true;
      try{
        toast("Requesting your location...");
        const pos = await getCurrentPosition();
        const lat = pos.coords.latitude;
        const lng = pos.coords.longitude;

        const existingKey = localStorage.getItem("nftFansAgentKey");

        // Do NOT allow a new join if another user is within 50m
        if(!existingKey){
          const tooClose = await nearAgentExists(lat, lng, 50 /* meters */);
          if(tooClose){
            toast("Another agent is within 50m. Try a different spot.");
            return;
          }
        }

        // Country info (best-effort)
        let country = { countryName: "Unknown", countryCode: "" };
        try{ country = await reverseGeocodeCountry(lat, lng); }catch{}

        const color = colorPicker.value || DEFAULT_COLOR;

        let agentKey = existingKey;
        let displayName, seqNumber;

        if(!existingKey){
          // Allocate next agent number atomically
          const tx = await runTransaction(counterRef, (current) => (current || 0) + 1);
          if(!tx.committed) throw new Error("Could not allocate agent number");
          seqNumber = tx.snapshot.val();
          displayName = `NFT FANS AGENT #${pad4(seqNumber)}`;

          const newRef = push(agentsRef);
          agentKey = newRef.key;

          await set(newRef, {
            displayName,
            seq: seqNumber,
            countryName: country.countryName,
            countryCode: country.countryCode,
            color,
            lat, lng,
            createdAt: serverTimestamp(),
            updatedAt: serverTimestamp()
          });
          localStorage.setItem("nftFansAgentKey", agentKey);
          localStorage.setItem("nftFansColor", color);
          toast("Welcome, Agent! You are on the map.");
        } else {
          // Update existing agent (allowed even if near others)
          const agentRef = child(agentsRef, existingKey);
          const snap = await get(agentRef);
          const data = snap.val() || {};
          seqNumber = data.seq || 0;
          displayName = data.displayName || (seqNumber ? `NFT FANS AGENT #${pad4(seqNumber)}` : "NFT FANS AGENT");

          await update(agentRef, {
            displayName,
            seq: seqNumber,
            countryName: country.countryName,
            countryCode: country.countryCode,
            color,
            lat, lng,
            updatedAt: serverTimestamp()
          });
          localStorage.setItem("nftFansColor", color);
          toast("Location updated.");
        }

        map.flyTo([lat, lng], Math.max(map.getZoom(), 15), { duration: 0.8 });
      }catch(e){
        console.error(e);
        toast(e.message || "Join failed. Please allow location permission.");
      }finally{
        btnJoin.disabled = false;
      }
    });

    // ========== Tabs Handling ==========
    const tabBtns = document.querySelectorAll('.tab-btn');
    const tabContents = document.querySelectorAll('.tab-content');

    tabBtns.forEach(btn => {
      btn.addEventListener('click', () => {
        // remove active from all
        tabBtns.forEach(b => b.classList.remove('active'));
        tabContents.forEach(c => c.classList.remove('active'));

        // add active to clicked
        btn.classList.add('active');
        const tabId = `tab-${btn.dataset.tab}`;
        document.getElementById(tabId).classList.add('active');
      });
    });

    // ========== Latest agents (table) ==========
    const latestBody = document.getElementById('latestBody');
    const latestMap = new Map(); // key -> data

    function flagEmoji(cc){ return countryCodeToEmoji(cc); }

    function upsertLatest(key, data){
      if(!data) return;
      latestMap.set(key, data);
      renderLatest();
      // Also update country stats when new data comes in
      renderCountryStats();
    }
    function removeLatest(key){
      latestMap.delete(key);
      renderLatest();
      renderCountryStats();
    }
    function renderLatest(limit = 10){
      const arr = Array.from(latestMap.entries())
        .map(([k,v]) => ({ key:k, ...v }))
        .sort((a,b) => (b.createdAt||0) - (a.createdAt||0))
        .slice(0, limit);

      latestBody.innerHTML = arr.map(a => {
        const f = flagEmoji(a.countryCode || "");
        const name = a.displayName || "NFT FANS AGENT";
        const country = a.countryName || "Unknown";
        const color = a.color || DEFAULT_COLOR;
        return `
          <tr>
            <td>
              <div class="agent-cell">
                <span class="dot" aria-hidden="true" style="background:${color}; border-color:${color};"></span>
                <span class="nameText">${name}</span>
              </div>
            </td>
            <td>
              <div class="countryText"><span>${f}</span><span>${country}</span></div>
            </td>
          </tr>
        `;
      }).join("");
    }

    // ========== Country Stats (table) ==========
    const countryBody = document.getElementById('countryBody');
    const countryFoot = document.getElementById('countryFoot');

    function renderCountryStats(){
        // 1. Group by country code
        const stats = {};
        const allAgents = Array.from(latestMap.values());
        
        allAgents.forEach(agent => {
            const cc = agent.countryCode || "XX";
            const cName = agent.countryName || "Unknown";
            
            if(!stats[cc]){
                stats[cc] = { 
                    count: 0, 
                    name: cName,
                    code: cc 
                };
            }
            stats[cc].count++;
        });

        // 2. Convert to array and sort by count desc
        const sortedStats = Object.values(stats).sort((a,b) => b.count - a.count);

        // 3. Render Body
        countryBody.innerHTML = sortedStats.map(s => {
            const f = flagEmoji(s.code === "XX" ? "" : s.code);
            return `
                <tr>
                    <td>
                        <div class="countryText" style="font-size:12px;">
                            <span style="font-size:14px; margin-right:6px;">${f}</span>
                            <span class="nameText">${s.name}</span>
                        </div>
                    </td>
                    <td style="text-align:right;">
                        <span style="font-weight:700;">[ ${s.count} ]</span>
                    </td>
                </tr>
            `;
        }).join("");

        // 4. Render Footer (Grand Total)
        const grandTotal = allAgents.length;
        countryFoot.innerHTML = `
            <tr class="grand-total-row">
                <td>GRAND TOTAL</td>
                <td style="text-align:right;">[ ${grandTotal} ]</td>
            </tr>
        `;
    }

    // Initial fetch of agents and populate store/markers
    (async function initData(){
      try{
        const snap = await get(agentsRef);
        snap.forEach(child => {
          const data = child.val();
          if(data){
            upsertStore(child.key, data);
            upsertLatest(child.key, data);
            if(typeof data.lat === "number" && typeof data.lng === "number"){
              upsertMarker(child.key, data);
            }
          }
        });
        renderLatest();
        renderCountryStats();
        recomputeLines();
      }catch(e){
        console.warn("Failed to load agents", e);
      }
    })();

    // Initial label state
    refreshLabelVisibility();
  </script>
</body>
</html>
