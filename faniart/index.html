
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="ART.Fun - Trade ARTs as NFTs">
  <meta property="og:description" content="The fun way to collect and trade ARTs as NFTs. Powered by NFTFans Token on Polygon Matic. Start your NFT journey today!">
  <meta property="og:image" content="https://raw.githubusercontent.com/leuvenfd/coinfun/refs/heads/main/xzaaa.PNG">
  <meta property="og:url" content="https://www.nftfanstoken.com/artfun/">
  <meta property="og:type" content="website">

  <!-- Twitter Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="ART.Fun - Trade ARTs as NFTs">
  <meta name="twitter:description" content="Collect, trade, and earn with ART.Fun â€” the NFT ART marketplace powered by NFTFans Token on Polygon. Explore now!">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/leuvenfd/coinfun/refs/heads/main/xzaaa.PNG">
  <meta name="twitter:url" content="https://www.nftfanstoken.com/artfun/">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">


  <title>ART.Fun</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
  <style>
/* Reset and base */
* { box-sizing: border-box; margin: 0; padding: 0; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }

@font-face {
  font-family: 'Cyberpunk';
  src: url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap');
}

:root{
  --bg-0:#0b0f19;
  --bg-1:#0f1526;
  --bg-2:#121a2f;
  --card:#151e33cc;
  --outline:#223052;
  --glass:#1b2742a8;
  --text:#e6edf3;
  --muted:#9fb0c2;

  --primary:#7c3aed;     /* violet */
  --primary-2:#a855f7;
  --accent:#06b6d4;      /* cyan */
  --success:#10b981;     /* green */
  --warn:#f59e0b;        /* amber */
  --danger:#ef4444;      /* red */

  --ring: 0 0 0 2px color-mix(in oklab, var(--accent) 50%, transparent);
  --shadow-xl: 0 10px 30px rgba(0,0,0,.35);
  --shadow-md: 0 6px 18px rgba(0,0,0,.28);
  --shadow-sm: 0 3px 10px rgba(0,0,0,.2);
}

html, body{
  min-height:100vh;
  background:
    radial-gradient(1200px 600px at 80% -10%, #13213f 0%, transparent 60%),
    radial-gradient(900px 500px at -10% 20%, #1a1440 0%, transparent 60%),
    linear-gradient(180deg, var(--bg-0), var(--bg-1) 40%, var(--bg-2) 100%);
  color:var(--text);
  font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  font-size: 10px;
  line-height: 1.5;
  overflow-x:hidden;
}

/* Top status bar */
.status-bar{
  position: fixed; top:0; left:0; width:100%;
  z-index:1000;
  display:flex; align-items:center; gap:10px;
  padding:10px 16px;
  background: linear-gradient(180deg, #11182acc, #0e1627cc);
  backdrop-filter: blur(10px);
  border-bottom: 1px solid #1f2b47;
  font-size: 11px; font-weight: 700; letter-spacing:.3px;
  color: var(--muted);
}
.status-bar .material-icons{ font-size:18px; color:var(--accent); }
.status-info{ }
.status-success .material-icons{ color:var(--success); }
.status-error .material-icons{ color:var(--danger); }
.status-warn .material-icons{ color:var(--warn); }

body, html { padding-top: 54px; }

/* Banner */
.banner-top{
  width:100%;
  display:flex; align-items:center; justify-content:center;
  background:
    radial-gradient(1000px 400px at 50% 0%, color-mix(in oklab, var(--primary) 26%, transparent) 0%, transparent 60%),
    linear-gradient(135deg, #0f1424, #111a30 60%, #0b1326 100%);
  border-bottom:1px solid #1f2b47;
  position:relative;
  overflow:hidden;
  padding: 14px 0;
  isolation:isolate;
}
.banner-top::after{
  content:'';
  position:absolute; inset:auto 0 -1px 0; height:1px;
  background: linear-gradient(90deg, transparent, var(--primary), var(--accent), transparent);
  opacity:.6;
}
.banner-top img{
  max-width: 980px; width: 92%;
  object-fit: cover; display:block;
  filter: contrast(1.05) brightness(1.02) saturate(1.05);
  border-radius: 14px;
  box-shadow: var(--shadow-md);
}

/* Wrapper */
.wrapper{
  max-width: 1120px;
  margin: 0 auto;
  padding: 18px 16px 44px;
}

/* Header */
.header{
  display:flex; align-items:center; justify-content:space-between;
  gap:14px;
  padding: 14px 16px;
  background: linear-gradient(180deg, var(--glass), color-mix(in oklab, var(--glass) 80%, transparent));
  border:1px solid var(--outline);
  border-radius: 14px;
  box-shadow: var(--shadow-sm);
}
.header .material-icons{ font-size: 22px; color: var(--accent); }
.header-title, .header{
  font-weight:900; font-size: 15px; letter-spacing: 1px;
}
.header{ color: var(--text); }

/* Top bar with wallet */
.top-bar{
  margin-top: 14px;
  display:flex; align-items:center; justify-content:space-between; gap:12px;
}

.nftfan-balance-bar{
  display:flex; align-items:center; gap:8px;
  padding:8px 12px;
  background: color-mix(in oklab, var(--glass) 88%, transparent);
  border:1px solid var(--outline);
  border-radius: 10px; color: var(--muted);
}
.nftfan-token-icon{ width:16px; height:16px; border-radius:4px; }

.connect-btn{
  display:inline-flex; align-items:center; justify-content:center; gap:8px;
  padding:10px 14px; min-width: 140px;
  background: linear-gradient(180deg, color-mix(in oklab, var(--accent) 22%, transparent), transparent);
  border:1px solid color-mix(in oklab, var(--accent) 40%, var(--outline));
  color: var(--text);
  border-radius: 10px; font-weight:800; font-size: 11px; letter-spacing: .8px; text-transform: uppercase;
  cursor:pointer;
  transition: transform .14s ease, box-shadow .2s ease, border-color .2s ease, background .2s ease;
  box-shadow: 0 0 0 0 transparent;
}
.connect-btn:hover{
  transform: translateY(-1px);
  border-color: color-mix(in oklab, var(--accent) 60%, var(--outline));
  box-shadow: var(--shadow-sm);
}
.connect-btn:active{ transform: translateY(0); }
.connect-btn .material-icons{ font-size:18px; color: var(--accent); }

/* Tabs */
.tab-bar{
  margin: 18px 0 8px;
  display:flex; gap: 8px;
  background: transparent;
}
.tab-btn{
  flex:1;
  display:flex; align-items:center; justify-content:center; gap:6px;
  padding:10px 6px;
  font-size:10px; font-weight:900; letter-spacing: .8px; text-transform: uppercase;
  color: var(--muted);
  background: linear-gradient(180deg, var(--glass), color-mix(in oklab, var(--glass) 60%, transparent));
  border:1px solid var(--outline);
  border-radius:10px;
  cursor:pointer;
  transition: all .18s ease;
}
.tab-btn .material-icons{ font-size:16px; color: var(--muted); }
.tab-btn .tab-count{
  background: #1f2b47;
  color: var(--muted);
  font-size: 9px; font-weight: 800;
  padding: 2px 6px; border-radius: 999px; margin-left: 4px;
  border: 1px solid #293454;
}
.tab-btn:hover{
  color: var(--text);
  border-color: color-mix(in oklab, var(--accent) 35%, var(--outline));
}
.tab-btn.active{
  color: var(--text);
  background: linear-gradient(180deg, color-mix(in oklab, var(--primary) 12%, var(--glass)), color-mix(in oklab, var(--glass) 66%, transparent));
  border-color: color-mix(in oklab, var(--primary) 45%, var(--outline));
  box-shadow: inset 0 0 0 1px color-mix(in oklab, var(--primary) 30%, transparent);
}
.tab-btn.active .material-icons{ color: var(--primary-2); }
.tab-btn.active .tab-count{
  background: color-mix(in oklab, var(--primary) 20%, #1b2541);
  border-color: color-mix(in oklab, var(--primary) 40%, #1b2541);
  color: var(--text);
}

/* Lists as Grid */
.nft-list{
  list-style:none;
  margin: 14px 2px 0;
  padding:0;
  display:grid;
  grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
  gap: 16px;
}

/* Card */
.nft-post{
  position:relative;
  display:flex; flex-direction:column;
  gap:10px;
  padding: 12px;
  background: linear-gradient(180deg, var(--card), color-mix(in oklab, var(--card) 70%, transparent));
  border:1px solid var(--outline);
  border-radius: 14px;
  box-shadow: var(--shadow-sm);
  transition: transform .14s ease, box-shadow .18s ease, border-color .18s ease;
  min-width:0;
  overflow:hidden;
}
.nft-post:hover{
  transform: translateY(-4px);
  border-color: color-mix(in oklab, var(--accent) 32%, var(--outline));
  box-shadow: var(--shadow-md);
}

/* Image */
.nft-avatar{
  width:100%; height: 100%; object-fit: cover;
  border-radius: 10px;
  border:1px solid #22314e;
  background:#0e1627;
  transition: transform .2s ease, box-shadow .2s ease, border-color .2s ease;
}
.nft-avatar:hover{
  transform: scale(1.02);
  border-color: color-mix(in oklab, var(--accent) 40%, #22314e);
  box-shadow: 0 8px 24px rgba(0,0,0,.35);
}

/* Content */
.nft-content{
  display:flex; flex-direction:column; gap:6px;
  min-width:0;
}
.nft-title{
  font-size: 12px; font-weight: 800; color: var(--text);
  white-space: nowrap; overflow:hidden; text-overflow: ellipsis;
}
.nft-description{
  font-size: 10px; color: var(--muted);
  display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;
}

/* Price + actions */
.nft-actions{
  margin-top:auto;
  display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap: wrap;
}
.price-tab{
  font-size: 11px; font-weight: 900;
  color: var(--text);
  padding: 6px 10px;
  border-radius: 10px;
  background: linear-gradient(180deg, #16213a, #141e34);
  border:1px solid #263352;
}

/* Buttons */
.buy-btn, .sell-btn, .delist-btn, #sellModalContent .confirm-btn, #sellModalContent .cancel-btn{
  font-size: 10px; font-weight: 900; letter-spacing:.6px; text-transform: uppercase;
  padding: 8px 10px;
  border-radius: 9px;
  border:1px solid var(--outline);
  background: linear-gradient(180deg, var(--glass), color-mix(in oklab, var(--glass) 70%, transparent));
  color: var(--text);
  cursor:pointer;
  transition: transform .12s ease, box-shadow .18s ease, border-color .18s ease, background .18s ease;
}
.buy-btn{ border-color: color-mix(in oklab, var(--success) 30%, var(--outline)); }
.sell-btn{ border-color: color-mix(in oklab, var(--primary-2) 35%, var(--outline)); }
.delist-btn{ border-color: color-mix(in oklab, var(--warn) 35%, var(--outline)); }

.buy-btn:hover{
  transform: translateY(-2px);
  border-color: color-mix(in oklab, var(--success) 55%, var(--outline));
  box-shadow: var(--shadow-sm);
}
.sell-btn:hover{
  transform: translateY(-2px);
  border-color: color-mix(in oklab, var(--primary-2) 60%, var(--outline));
  box-shadow: var(--shadow-sm);
}
.delist-btn:hover{
  transform: translateY(-2px);
  border-color: color-mix(in oklab, var(--warn) 60%, var(--outline));
  box-shadow: var(--shadow-sm);
}

.sold-out{
  font-size: 10px; font-weight: 900; text-transform: uppercase;
  padding: 7px 10px;
  border-radius: 9px;
  background: linear-gradient(180deg, #2a1620, #221018);
  border:1px solid color-mix(in oklab, var(--danger) 45%, #2c1b1f);
  color: #ffd6d6;
}

/* Loading and error */
.loading{
  text-align:center; padding: 18px 0; font-size: 10px; color: var(--muted);
}
.error{
  display:none;
  background: #2a1316;
  color:#ffb4b4;
  padding:10px; border-radius: 10px; border:1px solid #402126;
  margin: 8px 2px; font-size: 10px;
}

/* Overlay for all modals */
#sellModal, #confirmModal, #quantityModal{
  display:none; position:fixed; inset:0; z-index:999;
  background: #0b0f19cc; backdrop-filter: blur(6px);
  justify-content:center; align-items:center;
  padding: 16px;
}

/* Shared modal content styling */
#sellModalContent, #confirmModalContent, #quantityModalContent{
  width: 100%; max-width: 420px;
  background: linear-gradient(180deg, var(--glass), color-mix(in oklab, var(--glass) 70%, transparent));
  border:1px solid var(--outline);
  border-radius: 14px;
  padding: 18px 16px;
  display:flex; flex-direction:column; gap:14px;
  color: var(--text);
  box-shadow: var(--shadow-xl);
  position:relative;
}

#sellModalContent h3, #confirmModalContent h3, #quantityModalContent h3{
  font-size: 14px; font-weight: 900; letter-spacing: 1px; display:flex; align-items:center; gap:8px;
  color: var(--text);
}

#sellModalContent input, #quantityModalContent input{
  width:100%;
  padding: 12px 12px;
  border-radius: 10px;
  border:1px solid var(--outline);
  background:#0f1629;
  color: var(--text);
  font-size: 12px;
  transition: box-shadow .2s ease, border-color .2s ease;
}
#sellModalContent input:focus, #quantityModalContent input:focus{
  outline:none;
  border-color: color-mix(in oklab, var(--accent) 45%, var(--outline));
  box-shadow: var(--ring);
}

/* Shared buttons */
#sellModalContent .confirm-btn, #confirmModalContent .confirm-btn, #quantityModalContent .confirm-btn{
  font-size: 10px; font-weight: 900; letter-spacing:.6px; text-transform: uppercase;
  padding: 8px 10px; border-radius: 9px; cursor:pointer;
  border:1px solid color-mix(in oklab, var(--accent) 45%, var(--outline));
  background: linear-gradient(180deg, var(--glass), color-mix(in oklab, var(--glass) 70%, transparent));
  color: var(--text);
}
#sellModalContent .confirm-btn:hover, #confirmModalContent .confirm-btn:hover, #quantityModalContent .confirm-btn:hover{
  border-color: color-mix(in oklab, var(--accent) 65%, var(--outline));
}

#sellModalContent .cancel-btn, #confirmModalContent .cancel-btn, #quantityModalContent .cancel-btn{
  font-size: 10px; font-weight: 900; letter-spacing:.6px; text-transform: uppercase;
  padding: 8px 10px; border-radius: 9px; cursor:pointer;
  border:1px solid color-mix(in oklab, var(--danger) 35%, var(--outline));
  background: linear-gradient(180deg, var(--glass), color-mix(in oklab, var(--glass) 70%, transparent));
  color: var(--text);
}
#sellModalContent .cancel-btn:hover, #confirmModalContent .cancel-btn:hover, #quantityModalContent .cancel-btn:hover{
  border-color: color-mix(in oklab, var(--danger) 55%, var(--outline));
}

/* Close buttons */
#sellModalClose, #confirmModalClose, #quantityModalClose{
  position:absolute; top:10px; right:10px;
  background:none; border:none; color: var(--muted);
  display:inline-flex; align-items:center; justify-content:center;
  padding:6px; border-radius: 8px; cursor:pointer;
  transition: background .16s ease, color .16s ease;
}
#sellModalClose:hover, #confirmModalClose:hover, #quantityModalClose:hover{ background:#111a30; color: var(--text); }

/* Error/info areas for new modals */
#quantityModalError, #confirmModalText{
  font-size: 11px;
  color:#cbd5e1;
}
#quantityModalError{
  color:#ffd6d6;
  background:#2a1316;
  border:1px solid #402126;
  padding:10px; border-radius: 10px;
  display:none;
}

/* Utility */
.glitch-hover:hover{}

/* Responsive */
@media (max-width: 980px){
  .nft-list{ grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); }
}
@media (max-width: 720px){
  .wrapper{ padding: 14px 12px 36px; }
  .tab-bar{ gap:6px; }
  .tab-btn{ padding:8px 6px; font-size:9px; }
  .nft-avatar{ height: 160px; }
}
@media (max-width: 520px){
  .banner-top img{ width: 94%; }
  .nft-list{ grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 12px; }
  .nft-avatar{ height: 100%; }
  .nft-title{ font-size:11px; }
  .nft-description{ font-size: 9px; }
  .price-tab{ font-size:10px; padding:5px 8px; }
  .buy-btn, .sell-btn, .delist-btn{ font-size:9px; padding:7px 8px; }
}
@media (max-width: 380px){
  .nft-list{ grid-template-columns: 1fr; }
}

    input,
textarea,
select {
  font-size: 16px; /* prevents iOS auto-zoom */
}

  </style>
</head>
<body>
 
  <div class="wrapper">
    <div class="header">
      <span class="material-icons"></span>
      Fani's Gallery
    </div>
    <div class="top-bar">
      <div class="nftfan-balance-bar" id="nftfanBalanceBar" style="display:none;">
        <img class="nftfan-token-icon" src="https://i.imgur.com/ODP45iQ.png" alt="NFTFAN Token">
        <span id="nftfanBalance">--</span>
        <span style="font-size:7px;font-weight:400;color:#888;margin-left:2px;">NFTFAN</span>
      </div>
      <button class="connect-btn" id="connect-btn" onclick="connectWallet()">
        <span class="material-icons">link</span>
        Connect Wallet
      </button>
    </div>
    <div class="status-bar status-info" id="statusBar">
      <span class="material-icons" id="statusBarIcon">info</span>
      Status: Initializing...
    </div>
    <div class="tab-bar">
      <button class="tab-btn" id="tab-listings" onclick="showTab('listings')">
        <span class="material-icons">list_alt</span>Listed<span class="tab-count" id="listings-count">0</span>
      </button>
      <button class="tab-btn active" id="tab-shop" onclick="showTab('shop')">
        <span class="material-icons">storefront</span>Shop<span class="tab-count" id="shop-count">0</span>
      </button>
      <button class="tab-btn" id="tab-mynfts" onclick="showTab('mynfts')">
        <span class="material-icons">account_balance_wallet</span>My<span class="tab-count" id="mynfts-count">0</span>
      </button>
    </div>
    <!-- Shop Tab -->
    <div class="tab-content" id="tab-content-shop">
      <div id="shop-loading" class="loading">Loading NFTs...</div>
      <div id="shop-error" class="error"></div>
      <ul class="nft-list" id="shopGrid" style="display: none;"></ul>
    </div>
    <!-- My NFTs Tab -->
    <div class="tab-content" id="tab-content-mynfts" style="display:none;">
      <div id="my-loading" class="loading">Loading Your NFTs...</div>
      <div id="my-error" class="error"></div>
      <ul class="nft-list" id="myGrid" style="display: none;"></ul>
    </div>
    <!-- User Listings Tab -->
    <div class="tab-content" id="tab-content-listings" style="display:none;">
      <div id="listings-loading" class="loading">Loading User Listings...</div>
      <div id="listings-error" class="error"></div>
      <ul class="nft-list" id="listingsGrid" style="display: none;"></ul>
    </div>
  </div>
  <!-- Sell Modal -->
  <div id="sellModal">
    <div id="sellModalContent">
      <button id="sellModalClose" onclick="closeSellModal()" title="Close"><span class="material-icons">close</span></button>
      <h3>
        <span class="material-icons">sell</span>
        Sell Your NFT
      </h3>
      <div>
        <span class="material-icons" style="font-size:12px;vertical-align:middle;">confirmation_number</span>
        Token ID: <span id="sellTokenId"></span>
      </div>
      <div>
        <span class="material-icons" style="font-size:12px;vertical-align:middle;">inventory_2</span>
        You own: <span id="sellMaxAmount"></span>
      </div>
      <input type="number" id="sellAmountInput" min="1" placeholder="Amount to sell">
      <input type="number" id="sellPriceInput" step="0.000000000000000001" placeholder="Price per NFT (POL)">
      <div style="display:flex;gap:8px;width:100%;justify-content:flex-start;flex-wrap:wrap;">
        <button onclick="confirmSellNFT()" class="confirm-btn">
          <span class="material-icons">check_circle</span>Sell
        </button>
        <button onclick="closeSellModal()" class="cancel-btn">
          <span class="material-icons">cancel</span>Cancel
        </button>
      </div>
      <div id="sellModalError"></div>
    </div>
  </div>
  
  <!-- Confirm Modal -->
<div id="confirmModal">
  <div id="confirmModalContent">
    <button id="confirmModalClose" title="Close"><span class="material-icons">close</span></button>
    <h3><span class="material-icons">help</span>Confirm Action</h3>
    <div id="confirmModalText">Are you sure?</div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
      <button id="confirmModalConfirmBtn" class="confirm-btn"><span class="material-icons">check_circle</span>Confirm</button>
      <button id="confirmModalCancelBtn" class="cancel-btn"><span class="material-icons">cancel</span>Cancel</button>
    </div>
  </div>
</div>

<!-- Quantity Prompt Modal -->
<div id="quantityModal">
  <div id="quantityModalContent">
    <button id="quantityModalClose" title="Close"><span class="material-icons">close</span></button>
    <h3 id="quantityModalTitle"><span class="material-icons">shopping_cart</span>Quantity</h3>
    <input type="number" id="quantityModalInput" min="1" placeholder="Enter amount">
    <div id="quantityModalError"></div>
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin-top:8px;">
      <button id="quantityModalConfirmBtn" class="confirm-btn"><span class="material-icons">check_circle</span>OK</button>
      <button id="quantityModalCancelBtn" class="cancel-btn"><span class="material-icons">cancel</span>Cancel</button>
    </div>
  </div>
</div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
<script>
  // --- CONFIG ---
  const POLYGON_PARAMS = {
    chainId: "0x89",
    chainName: "Polygon Mainnet",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: [
      "https://polygon-rpc.com/",
      "https://rpc.polygon.technology/",
      "https://rpc-mainnet.matic.network/",
    ],
    blockExplorerUrls: ["https://polygonscan.com/"],
  };
  const NFTFAN_SHOP_CA = "0x958BD1b8773Ac12Ab9FAD848B0462831Bc4Cb113";
    const NFTFAN_SHOP_ABI = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "creator",
        type: "address",
      },
      {
        indexed: false,
        internalType: "string",
        name: "tokenURI",
        type: "string",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NFTMinted",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "buyer",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NFTBought",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NFTListed",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "NFTUnlisted",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "listingIndex",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "ListingCancelled",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "buyNFT",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "listingIndex",
        type: "uint256",
      },
    ],
    name: "cancelListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "exists",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "getListings",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "seller",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256",
          },
        ],
        internalType: "struct NFTFansShop.Listing[]",
        name: "",
        type: "tuple[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "getShopInventory",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getShopNFTs",
    outputs: [
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]",
      },
      {
        internalType: "string[]",
        name: "uris",
        type: "string[]",
      },
      {
        internalType: "uint256[]",
        name: "prices",
        type: "uint256[]",
      },
      {
        internalType: "bool[]",
        name: "isForSale",
        type: "bool[]",
      },
      {
        internalType: "uint256[]",
        name: "shopAmounts",
        type: "uint256[]",
      },
      {
        internalType: "uint256[]",
        name: "maxSupplies",
        type: "uint256[]",
      },
      {
        internalType: "uint256[]",
        name: "currentSupplies",
        type: "uint256[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_tokenURI",
        type: "string",
      },
      {
        internalType: "uint256",
        name: "_price",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_maxSupply",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "mintNFT",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "mintAdditional",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "nextTokenId",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "nftInfo",
    outputs: [
      {
        internalType: "string",
        name: "tokenURI",
        type: "string",
      },
      {
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        internalType: "bool",
        name: "forSale",
        type: "bool",
      },
      {
        internalType: "address",
        name: "originalCreator",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "maxSupply",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "currentSupply",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_price",
        type: "uint256",
      },
    ],
    name: "sellNFT",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address",
      },
    ],
    name: "tokensOfOwner",
    outputs: [
      {
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]",
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "unlistNFT",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
];

  let userAccount = null,
    web3,
    nftfanShop = null,
    lastError = null,
    statusTimeout = null;
  let sellModalTokenId = null,
    sellModalMaxAmount = null;

 function setStatusBar(type, message) {
  const statusBar = document.getElementById("statusBar");
  const iconSpan = document.getElementById("statusBarIcon");
  statusBar.className = `status-bar status-${type}`;
  if (iconSpan) {
    if (type === "success") iconSpan.textContent = "check_circle";
    else if (type === "error") iconSpan.textContent = "error";
    else if (type === "warn") iconSpan.textContent = "warning";
    else iconSpan.textContent = "info";
  }
  statusBar.style.display = "flex";
  statusBar.textContent = "";
  statusBar.appendChild(iconSpan);
  statusBar.appendChild(document.createTextNode(message));
}

function updateStatus(message, type = "info") {
  setStatusBar(type, message);
  // Status bar stays on screen; no timeout to hide it.
}

function logError(error, context = "") {
  lastError = `${context}: ${error.message || error}`;
}

function showError(elementId, message) {
  const errorEl = document.getElementById(elementId);
  errorEl.textContent = message;
  errorEl.style.display = "block";
  updateStatus(message, "error");
}

function hideError(elementId) {
  document.getElementById(elementId).style.display = "none";
}

  async function connectWallet() {
    try {
      updateStatus("Connecting wallet...", "info");
      if (!window.ethereum) throw new Error("Please install MetaMask or a compatible wallet!");
      const chainId = await window.ethereum.request({ method: "eth_chainId" });
      if (chainId !== POLYGON_PARAMS.chainId) {
        updateStatus("Switching to Polygon network...", "info");
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: POLYGON_PARAMS.chainId }],
          });
        } catch (switchError) {
          if (switchError.code === 4902) {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [POLYGON_PARAMS],
            });
          } else {
            throw switchError;
          }
        }
      }
      const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
      userAccount = accounts[0];
      document.getElementById("connect-btn").textContent = formatAddress(userAccount);
      await setupContracts();
      updateStatus("Connected successfully", "success");
      loadShopNFTs();
      loadUserNFTs();
      loadUserListings();
    } catch (error) {
      console.error("connectWallet failed:", error);
      logError(error, "Wallet Connection");
      updateStatus("Connection failed: " + error.message, "error");
    }
  }

  async function setupContracts() {
    try {
      updateStatus("Setting up contracts...", "info");
      const rpcUrls = POLYGON_PARAMS.rpcUrls;
      let provider = null;
      if (window.ethereum) {
        provider = window.ethereum;
        console.log("Using MetaMask provider");
      } else {
        for (const rpcUrl of rpcUrls) {
          try {
            const testWeb3 = new Web3(rpcUrl);
            const blockNumber = await testWeb3.eth.getBlockNumber();
            console.log(`Connected to RPC ${rpcUrl}, block number: ${blockNumber}`);
            provider = rpcUrl;
            break;
          } catch (e) {
            console.error(`Failed to connect to RPC ${rpcUrl}:`, e);
          }
        }
      }
      if (!provider) throw new Error("No working RPC provider found");
      web3 = new Web3(provider);
      nftfanShop = new web3.eth.Contract(NFTFAN_SHOP_ABI, NFTFAN_SHOP_CA);
      console.log("Contract initialized at address:", NFTFAN_SHOP_CA);
      updateStatus("Contracts initialized", "success");
    } catch (error) {
      console.error("Contract setup failed:", error);
      logError(error, "Contract Setup");
      updateStatus("Contract setup failed: " + error.message, "error");
      throw error;
    }
  }

  async function fetchOpenSeaMeta(uri) {
    if (!uri) return null;
    try {
      if (uri.startsWith("ipfs://")) uri = "https://ipfs.io/ipfs/" + uri.slice(7);
      if (uri.startsWith("ar://")) uri = "https://arweave.net/" + uri.slice(5);
      const res = await fetch(uri, { mode: "cors" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      console.error("fetchOpenSeaMeta failed for URI", uri, ":", e);
      updateStatus("Metadata fetch failed: " + (uri || "unknown"), "warn");
      return null;
    }
  }

  let permanentlySoldOutIds = JSON.parse(localStorage.getItem("nftfans_permanently_sold_out_ids") || "[]");

  function markPermanentlySoldOut(tokenId) {
    if (!permanentlySoldOutIds.includes(tokenId)) {
      permanentlySoldOutIds.push(tokenId);
      localStorage.setItem("nftfans_permanently_sold_out_ids", JSON.stringify(permanentlySoldOutIds));
    }
  }

async function loadShopNFTs() {
  const shopGrid = document.getElementById("shopGrid");
  const loading = document.getElementById("shop-loading");
  const countEl = document.getElementById("shop-count");
  shopGrid.innerHTML = "";
  loading.style.display = "block";
  shopGrid.style.display = "none";
  countEl.style.display = "none";
  hideError("shop-error");
  try {
    updateStatus("Loading shop NFTs...", "info");
    if (!nftfanShop) await setupContracts();
    const result = await nftfanShop.methods.getShopNFTs().call();
    console.log("getShopNFTs result:", result);
    const { ids, uris, prices, isForSale, shopAmounts, maxSupplies } = result;
    if (!ids.length) {
      loading.textContent = "No NFTs in Shop";
      countEl.textContent = "ART: 0";
      countEl.style.display = "block";
      updateStatus("No NFTs in shop", "info");
      return;
    }
    updateStatus(`Loading metadata for ${ids.length} NFTs...`, "info");
    const metaArr = await Promise.all(
      uris.map(async (uri, i) => {
        try {
          const meta = await fetchOpenSeaMeta(uri);
          console.log(`Metadata for URI ${uri}:`, meta);
          return meta;
        } catch (e) {
          console.error(`Failed to fetch metadata for URI ${uri}:`, e);
          return null;
        }
      })
    );
    let html = "";
    let visibleCount = 0;
    for (let i = 0; i < ids.length; i++) {
      const id = ids[i],
        meta = metaArr[i],
        name = meta?.name || `NFTFAN #${id}`,
        img = meta?.image || uris[i] || "https://via.placeholder.com/92x92?text=NFT",
        desc = meta?.description || "",
        price = web3.utils.fromWei(prices[i], "ether"),
        forSale = isForSale[i],
        available = shopAmounts[i],
        maxSupply = maxSupplies ? maxSupplies[i] : "";
      let statusBadge = "";
      if (forSale && available > 0) {
        statusBadge = `<span class="nft-status-label nft-status-listed">Listed</span>`;
      } else {
        statusBadge = `<span class="nft-status-label nft-status-notlisted">Not listed</span>`;
      }
      html += `<li class="nft-post">
        <div class="nft-post-left">
          <span class="serial-number">${++visibleCount}</span>
          <img class="nft-avatar" src="${img}" alt="NFT ${name}" onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
          <div class="nft-content">
            <div class="nft-title">${name}
              ${maxSupply ? `<span class="nft-supply">Â· Max: ${maxSupply}</span>` : ""}
            </div>
            <div class="nft-description">${
              desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
            }</div>
            ${statusBadge}
          </div>
        </div>
        <div class="nft-actions">
          <div class="price-tab">${price} POL</div>
          ${
            forSale && available != "0"
              ? `<button class="buy-btn" onclick="buyNFT(${id}, '${prices[i]}', ${available})" ${
                  !userAccount ? "disabled" : ""
                }><span class="material-icons">shopping_cart</span>Buy</button>`
              : `<div class="sold-out"><span class="material-icons">block</span>Sold Out</div>`
          }
        </div>
      </li>`;
    }
    shopGrid.innerHTML = html;
    loading.style.display = "none";
    shopGrid.style.display = visibleCount > 0 ? "block" : "none";
    countEl.textContent = `T: ${visibleCount}`;
    countEl.style.display = "block";
    if (visibleCount === 0) {
      loading.textContent = "No NFTs available in shop.";
      loading.style.display = "block";
    }
    updateStatus("Shop loaded", "success");
  } catch (error) {
    console.error("loadShopNFTs failed:", error);
    logError(error, "Shop Loading");
    showError("shop-error", "Failed to load NFTs: " + error.message);
    countEl.textContent = "T: 0";
    countEl.style.display = "block";
  }
}

 async function loadUserNFTs() {
  const myGrid = document.getElementById("myGrid");
  const loading = document.getElementById("my-loading");
  const countEl = document.getElementById("mynfts-count");
  myGrid.innerHTML = "";
  loading.style.display = "block";
  myGrid.style.display = "none";
  countEl.style.display = "none";
  hideError("my-error");
  if (!userAccount) {
    loading.textContent = "Connect wallet to view your NFTs.";
    countEl.textContent = "T: 0";
    countEl.style.display = "block";
    updateStatus("Connect wallet to view your NFTs", "info");
    return;
  }
  try {
    updateStatus("Loading your NFTs...", "info");
    if (!nftfanShop) await setupContracts();
    const tokens = await nftfanShop.methods.tokensOfOwner(userAccount).call();
    console.log("tokensOfOwner result:", tokens);
    const { tokenIds, amounts } = tokens;
    let metaArr = await Promise.all(
      tokenIds.map(async (id, idx) => {
        try {
          let meta = await nftfanShop.methods.nftInfo(id).call();
          console.log(`nftInfo for token ${id}:`, meta);
          let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
          console.log(`Metadata for token ${id}:`, metaJson);
          let listings = await nftfanShop.methods.getListings(id).call();
          console.log(`Listings for token ${id}:`, listings);
          let userListings = listings
            .map((l, index) => ({ ...l, listingIndex: index }))
            .filter((l) => l.seller.toLowerCase() === userAccount.toLowerCase() && Number(l.amount) > 0);
          console.log(`User listings for token ${id}:`, userListings);
          return { id, amount: amounts[idx], meta, metaJson, userListings };
        } catch (e) {
          console.error(`Failed to load data for token ${id}:`, e);
          return { id, amount: amounts[idx], meta: null, metaJson: null, userListings: [] };
        }
      })
    );
    // Include NFTs with listings even if amount is 0
    let additionalListings = [];
    const allShopNFTs = await nftfanShop.methods.getShopNFTs().call();
    for (let i = 0; i < allShopNFTs.ids.length; i++) {
      const id = allShopNFTs.ids[i];
      if (!tokenIds.includes(id)) {
        try {
          let listings = await nftfanShop.methods.getListings(id).call();
          let userListings = listings
            .map((l, index) => ({ ...l, listingIndex: index }))
            .filter((l) => l.seller.toLowerCase() === userAccount.toLowerCase() && Number(l.amount) > 0);
          if (userListings.length > 0) {
            let meta = await nftfanShop.methods.nftInfo(id).call();
            let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
            additionalListings.push({
              id,
              amount: 0,
              meta,
              metaJson,
              userListings
            });
            console.log(`Added token ${id} with listings but no ownership`);
          }
        } catch (e) {
          console.error(`Failed to check listings for token ${id}:`, e);
        }
      }
    }
    metaArr = metaArr.concat(additionalListings);
    if (!metaArr.length) {
      loading.textContent = "You own no NFTs and have no active listings.";
      countEl.textContent = "T: 0";
      countEl.style.display = "block";
      updateStatus("No NFTs or listings found", "info");
      return;
    }
    let html = "";
    for (let i = 0; i < metaArr.length; i++) {
      const item = metaArr[i];
      const { id, amount, meta, metaJson, userListings } = item;
      const name = metaJson?.name || `NFTFAN #${id}`;
      const img =
        metaJson?.image || (meta?.tokenURI || "https://via.placeholder.com/92x92?text=NFT");
      const desc = metaJson?.description || "";
      const maxSupply = meta?.maxSupply || "";
      let listingsHtml = "";
      if (userListings.length > 0) {
        listingsHtml = `<div class="nft-listings" style="margin-top:5px;font-size:8px;color:#93c5fd;">Your Listings:</div>`;
        listingsHtml += userListings
          .map(
            (l, idx) => `
              <div style="display:flex;gap:5px;align-items:center;margin-top:3px;">
                <span>Price: ${web3.utils.fromWei(l.price, "ether")} POL</span>
                <span>Amount: ${l.amount}</span>
                <button class="delist-btn" onclick="cancelListing(${id}, ${l.listingIndex})">
                  <span class="material-icons">cancel</span>Delist
                </button>
              </div>`
          )
          .join("");
      }
      html += `<li class="nft-post">
        <div class="nft-post-left">
          <span class="serial-number">${i + 1}</span>
          <img class="nft-avatar" src="${img}" alt="NFT ${name}" 
               onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
          <div class="nft-content">
            <div class="nft-title">${name}
              ${maxSupply ? `<span class="nft-supply">Â· Max: ${maxSupply}</span>` : ""}
            </div>
            <div class="nft-description">${
              desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
            }</div>
            <div class="nft-supply" style="margin-top:3px;color:#60a5fa;">You own: ${amount}</div>
            <button class="sell-btn" style="margin-top:5px;width:90px;" 
                    onclick="openSellModal(${id}, ${amount})" 
                    ${amount == 0 ? "disabled" : ""}>
              <span class="material-icons">sell</span>Sell
            </button>
            ${listingsHtml}
          </div>
        </div>
      </li>`;
    }
    myGrid.innerHTML = html;
    loading.style.display = "none";
    myGrid.style.display = "block";
    countEl.textContent = `T: ${metaArr.length}`;
    countEl.style.display = "block";
    updateStatus("Your NFTs loaded", "success");
  } catch (error) {
    console.error("loadUserNFTs failed:", error);
    logError(error, "User NFTs Loading");
    showError("my-error", "Failed to load your NFTs: " + error.message);
    countEl.textContent = "T: 0";
    countEl.style.display = "block";
  }
}

async function loadUserListings() {
  const listingsGrid = document.getElementById("listingsGrid");
  const loading = document.getElementById("listings-loading");
  const countEl = document.getElementById("listings-count");
  listingsGrid.innerHTML = "";
  loading.style.display = "block";
  listingsGrid.style.display = "none";
  countEl.style.display = "none";
  hideError("listings-error");
  try {
    updateStatus("Loading user listings...", "info");
    if (!nftfanShop) await setupContracts();
    const result = await nftfanShop.methods.getShopNFTs().call();
    console.log("getShopNFTs for listings:", result);
    const { ids, uris } = result;
    if (!ids.length) {
      loading.textContent = "No NFTs in Shop";
      countEl.textContent = "T: 0";
      countEl.style.display = "block";
      updateStatus("No NFTs in shop", "info");
      return;
    }
    let allListings = [];
    for (let i = 0; i < ids.length; i++) {
      try {
        const id = ids[i];
        const uri = uris[i];
        const listings = await nftfanShop.methods.getListings(id).call();
        console.log(`Listings for token ${id}:`, listings);
        const meta = await nftfanShop.methods.nftInfo(id).call();
        console.log(`nftInfo for token ${id}:`, meta);
        const originalCreator = meta.originalCreator;
        const filtered = listings
          .map((l, index) => ({ ...l, id, uri, meta, listingIndex: index }))
          .filter(
            (l) =>
              l.seller.toLowerCase() !== originalCreator.toLowerCase() &&
              Number(l.amount) > 0
          );
        allListings = allListings.concat(filtered);
      } catch (e) {
        console.error(`Failed to load listings for token ${ids[i]}:`, e);
      }
    }
    if (!allListings.length) {
      loading.textContent = "No other user listings yet.";
      countEl.textContent = "T: 0";
      countEl.style.display = "block";
      updateStatus("No user listings", "info");
      return;
    }
    updateStatus(`Loading metadata for ${allListings.length} listings...`, "info");
    let html = "";
    for (let i = 0; i < allListings.length; i++) {
      const l = allListings[i];
      let metaJson = await fetchOpenSeaMeta(l.meta.tokenURI);
      console.log(`Metadata for listing ${l.id}:`, metaJson);
      let name = metaJson?.name || `NFTFAN #${l.id}`;
      let img =
        metaJson?.image || l.meta.tokenURI || "https://via.placeholder.com/92x92?text=NFT";
      let desc = metaJson?.description || "";
      let price = web3.utils.fromWei(l.price, "ether");
      html += `<li class="nft-post">
        <div class="nft-post-left">
          <span class="serial-number">${i + 1}</span>
          <img class="nft-avatar" src="${img}" alt="NFT ${name}" 
               onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
          <div class="nft-content">
            <div class="nft-title">${name}
              ${l.meta.maxSupply ? `<span class="nft-supply">Â· Max: ${l.meta.maxSupply}</span>` : ""}
            </div>
            <div class="nft-description">${
              desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
            }</div>
            <div class="nft-supply" style="margin-top:3px;color:#60a5fa;">Seller: ${formatAddress(
              l.seller
            )}</div>
          </div>
        </div>
        <div class="nft-actions">
          <div class="price-tab">${price} POL</div>
          <button class="buy-btn" onclick="buyUserListing('${l.id}', '${l.seller}', '${
            l.price
          }', '${l.amount}')" ${!userAccount ? "disabled" : ""}>
            <span class="material-icons">shopping_cart</span>Buy
          </button>
        </div>
      </li>`;
    }
    listingsGrid.innerHTML = html;
    loading.style.display = "none";
    listingsGrid.style.display = "block";
    countEl.textContent = `T: ${allListings.length}`;
    countEl.style.display = "block";
    updateStatus("User listings loaded", "success");
  } catch (error) {
    console.error("loadUserListings failed:", error);
    logError(error, "User Listings Loading");
    showError("listings-error", "Failed to load user listings: " + error.message);
    countEl.textContent = "T: 0";
    countEl.style.display = "block";
  }
}

 window.buyNFT = async function (tokenId, priceWei, availableAmount) {
  if (!userAccount) return updateStatus("Connect your wallet first!", "error");

  let amount = 1;
  if (Number(availableAmount) > 1) {
    const res = await openQuantityModal({
      title: `How many would you like to buy? (max ${availableAmount})`,
      max: Number(availableAmount),
      defaultValue: 1
    });
    if (res == null) return; // cancelled
    amount = res;
  }

  try {
    updateStatus("Processing purchase...", "info");
    await nftfanShop.methods.buyNFT(tokenId, amount).send({
      from: userAccount,
      value: (BigInt(priceWei) * BigInt(amount)).toString(),
    });
    updateStatus("NFT bought successfully!", "success");
    await loadShopNFTs();
    await loadUserNFTs();
    await loadUserListings();
  } catch (error) {
    console.error("buyNFT failed:", error);
    logError(error, "NFT Purchase");
    updateStatus("Purchase failed: " + error.message, "error");
  }
};

window.buyUserListing = async function (tokenId, seller, priceWei, availableAmount) {
  if (!userAccount) return updateStatus("Connect your wallet first!", "error");

  let amount = 1;
  if (Number(availableAmount) > 1) {
    const res = await openQuantityModal({
      title: `How many would you like to buy from user? (max ${availableAmount})`,
      max: Number(availableAmount),
      defaultValue: 1
    });
    if (res == null) return; // cancelled
    amount = res;
  }

  try {
    updateStatus("Processing purchase...", "info");
    await nftfanShop.methods.buyNFT(tokenId, amount).send({
      from: userAccount,
      value: (BigInt(priceWei) * BigInt(amount)).toString(),
    });
    updateStatus("NFT bought successfully!", "success");
    await loadShopNFTs();
    await loadUserNFTs();
    await loadUserListings();
  } catch (error) {
    console.error("buyUserListing failed:", error);
    logError(error, "NFT User Listing Purchase");
    updateStatus("Purchase failed: " + error.message, "error");
  }
};

window.cancelListing = async function (tokenId, listingIndex) {
  if (!userAccount) return updateStatus("Connect your wallet first!", "error");

  const ok = await openConfirmModal("Are you sure you want to delist this NFT?");
  if (!ok) return;

  try {
    updateStatus("Delisting NFT...", "info");
    await nftfanShop.methods
      .cancelListing(tokenId, listingIndex)
      .send({ from: userAccount });
    updateStatus("NFT delisted successfully!", "success");
    await loadShopNFTs();
    await loadUserNFTs();
    await loadUserListings();
  } catch (error) {
    console.error("cancelListing failed:", error);
    logError(error, "Delist NFT");
    updateStatus("Delist failed: " + error.message, "error");
  }
};

  window.openSellModal = function (tokenId, maxAmount) {
    sellModalTokenId = tokenId;
    sellModalMaxAmount = maxAmount;
    document.getElementById("sellModal").style.display = "flex";
    document.getElementById("sellTokenId").textContent = tokenId;
    document.getElementById("sellMaxAmount").textContent = maxAmount;
    document.getElementById("sellAmountInput").value = "";
    document.getElementById("sellAmountInput").max = maxAmount;
    document.getElementById("sellPriceInput").value = "";
    document.getElementById("sellModalError").textContent = "";
  };

  window.closeSellModal = function () {
    document.getElementById("sellModal").style.display = "none";
    sellModalTokenId = null;
    sellModalMaxAmount = null;
  };

  window.confirmSellNFT = async function () {
    const amount = parseInt(document.getElementById("sellAmountInput").value);
    const price = document.getElementById("sellPriceInput").value;
    document.getElementById("sellModalError").textContent = "";
    if (!userAccount) return document.getElementById("sellModalError").textContent = "Connect your wallet first!";
    if (!amount || isNaN(amount) || amount < 1 || amount > sellModalMaxAmount)
      return document.getElementById("sellModalError").textContent = "Invalid amount!";
    if (!price || isNaN(price) || Number(price) <= 0)
      return document.getElementById("sellModalError").textContent = "Invalid price!";
    let priceWei = "0";
    try {
      priceWei = web3.utils.toWei(price, "ether");
    } catch {
      return document.getElementById("sellModalError").textContent = "Invalid price.";
    }
    try {
      updateStatus("Processing sale...", "info");
      await nftfanShop.methods.sellNFT(sellModalTokenId, amount, priceWei).send({ from: userAccount });
      updateStatus("NFT listed for sale!", "success");
      closeSellModal();
      await loadShopNFTs();
      await loadUserNFTs();
      await loadUserListings();
    } catch (error) {
      console.error("confirmSellNFT failed:", error);
      logError(error, "NFT Sale");
      updateStatus("Sale listing failed: " + error.message, "error");
      document.getElementById("sellModalError").textContent = "Sale failed: " + error.message;
    }
  };

  window.onclick = function (event) {
    const modal = document.getElementById("sellModal");
    if (event.target === modal) closeSellModal();
  };

  function formatAddress(address) {
    if (!address) return "";
    return `${address.slice(0, 5)}...${address.slice(-4)}`;
  }

  if (window.ethereum) {
    window.ethereum.on("accountsChanged", function (accounts) {
      userAccount = accounts[0] || null;
      const connectBtn = document.getElementById("connect-btn");
      connectBtn.textContent = userAccount ? formatAddress(userAccount) : "ðŸ”— Connect Wallet";
      if (userAccount) {
        setupContracts().then(() => {
          loadShopNFTs();
          loadUserNFTs();
          loadUserListings();
          updateStatus("Account changed", "success");
        });
      } else {
        updateStatus("Wallet disconnected", "info");
      }
    });
    window.ethereum.on("chainChanged", function (chainId) {
      updateStatus("Network changed - reconnecting...", "info");
      setupContracts().then(() => {
        loadShopNFTs();
        loadUserNFTs();
        loadUserListings();
        updateStatus("Network changed", "success");
      });
    });
    nftfanShop.events
      .ListingCancelled({})
      .on("data", async (event) => {
        updateStatus(`Listing for NFT #${event.returnValues.tokenId} cancelled`, "success");
        await loadShopNFTs();
        await loadUserNFTs();
        await loadUserListings();
      })
      .on("error", (error) => {
        console.error("ListingCancelled event error:", error);
        updateStatus("Failed to process listing cancellation event", "error");
      });
  }

window.addEventListener("DOMContentLoaded", async () => {
  try {
    console.log('Initializing app...');
    updateStatus("Initializing...", "info");
    await setupContracts();
    console.log('Contracts set up successfully');
    await loadShopNFTs();
    console.log('Shop NFTs loaded');
    await loadUserListings();
    console.log('User listings loaded');
    await loadUserNFTs();
    console.log('User NFTs loaded');
    updateStatus("Ready", "success");
    // Bind tab button events
    const tabButtons = {
      'listings': document.getElementById('tab-listings'),
      'shop': document.getElementById('tab-shop'),
      'mynfts': document.getElementById('tab-mynfts')
    };
    Object.keys(tabButtons).forEach(tab => {
      if (tabButtons[tab]) {
        tabButtons[tab].addEventListener('click', () => {
          console.log(`Tab button clicked: ${tab}`);
          showTab(tab);
        });
      } else {
        console.error(`Tab button not found: tab-${tab}`);
      }
    });
  } catch (error) {
    console.error("Initialization failed:", error);
    logError(error, "Initialization");
    updateStatus("Initialization failed: " + error.message, "error");
    showError("shop-error", "Failed to initialize the application. Please refresh.");
  }
});
  
function showTab(tab) {
  try {
    console.log(`Switching to tab: ${tab}`);
    const tabContents = ['shop', 'mynfts', 'listings'];
    tabContents.forEach((t) => {
      const content = document.getElementById(`tab-content-${t}`);
      if (content) {
        content.style.display = 'none';
      } else {
        console.error(`Tab content element not found: tab-content-${t}`);
      }
    });
    const selectedContent = document.getElementById(`tab-content-${tab}`);
    if (selectedContent) {
      selectedContent.style.display = 'block';
    } else {
      throw new Error(`Invalid tab content ID: tab-content-${tab}`);
    }
    tabContents.forEach((t) => {
      const btn = document.getElementById(`tab-${t}`);
      if (btn) {
        btn.classList.remove('active');
      } else {
        console.error(`Tab button element not found: tab-${t}`);
      }
    });
    const selectedBtn = document.getElementById(`tab-${tab}`);
    if (selectedBtn) {
      selectedBtn.classList.add('active');
    } else {
      throw new Error(`Invalid tab button ID: tab-${tab}`);
    }
    if (tab === 'shop') {
      loadShopNFTs().catch((e) => {
        console.error('loadShopNFTs failed in showTab:', e);
        updateStatus('Failed to load shop NFTs', 'error');
      });
    } else if (tab === 'mynfts') {
      loadUserNFTs().catch((e) => {
        console.error('loadUserNFTs failed in showTab:', e);
        updateStatus('Failed to load your NFTs', 'error');
      });
    } else if (tab === 'listings') {
      loadUserListings().catch((e) => {
        console.error('loadUserListings failed in showTab:', e);
        updateStatus('Failed to load user listings', 'error');
      });
    } else {
      throw new Error(`Invalid tab: ${tab}`);
    }
    console.log(`Tab switched successfully: ${tab}`);
  } catch (error) {
    console.error('showTab failed:', error);
    updateStatus(`Failed to switch to ${tab} tab: ${error.message}`, 'error');
  }
}

// Opens a custom confirm modal. Returns Promise<boolean>
function openConfirmModal(message = "Are you sure?") {
  return new Promise((resolve) => {
    const modal = document.getElementById("confirmModal");
    const text = document.getElementById("confirmModalText");
    const btnOk = document.getElementById("confirmModalConfirmBtn");
    const btnCancel = document.getElementById("confirmModalCancelBtn");
    const btnClose = document.getElementById("confirmModalClose");

    text.textContent = message;
    modal.style.display = "flex";

    const cleanup = (value) => {
      modal.style.display = "none";
      btnOk.removeEventListener("click", onOk);
      btnCancel.removeEventListener("click", onCancel);
      btnClose.removeEventListener("click", onCancel);
      modal.removeEventListener("click", onBackdrop);
      document.removeEventListener("keydown", onEsc);
      resolve(value);
    };
    const onOk = () => cleanup(true);
    const onCancel = () => cleanup(false);
    const onBackdrop = (e) => { if (e.target === modal) onCancel(); };
    const onEsc = (e) => { if (e.key === "Escape") onCancel(); };

    btnOk.addEventListener("click", onOk);
    btnCancel.addEventListener("click", onCancel);
    btnClose.addEventListener("click", onCancel);
    modal.addEventListener("click", onBackdrop);
    document.addEventListener("keydown", onEsc);
  });
}

// Opens a quantity modal with validation. Returns Promise<number|null>
function openQuantityModal({ title = "Quantity", max = null, defaultValue = 1 } = {}) {
  return new Promise((resolve) => {
    const modal = document.getElementById("quantityModal");
    const titleEl = document.getElementById("quantityModalTitle");
    const input = document.getElementById("quantityModalInput");
    const errorEl = document.getElementById("quantityModalError");
    const btnOk = document.getElementById("quantityModalConfirmBtn");
    const btnCancel = document.getElementById("quantityModalCancelBtn");
    const btnClose = document.getElementById("quantityModalClose");

    titleEl.innerHTML = `<span class="material-icons">shopping_cart</span>${title}`;
    input.value = defaultValue || 1;
    input.min = 1;
    if (max != null) input.max = max;
    errorEl.style.display = "none";
    errorEl.textContent = "";

    modal.style.display = "flex";
    input.focus();
    input.select();

    const finish = (value) => {
      modal.style.display = "none";
      btnOk.removeEventListener("click", onOk);
      btnCancel.removeEventListener("click", onCancel);
      btnClose.removeEventListener("click", onCancel);
      modal.removeEventListener("click", onBackdrop);
      document.removeEventListener("keydown", onEsc);
      resolve(value);
    };

    const onOk = () => {
      const raw = Number(input.value);
      if (!Number.isFinite(raw) || raw < 1 || (max != null && raw > Number(max))) {
        errorEl.textContent = `Enter a valid amount${max != null ? ` (1 - ${max})` : ""}.`;
        errorEl.style.display = "block";
        return;
      }
      finish(raw);
    };
    const onCancel = () => finish(null);
    const onBackdrop = (e) => { if (e.target === modal) onCancel(); };
    const onEsc = (e) => { if (e.key === "Escape") onCancel(); };

    btnOk.addEventListener("click", onOk);
    btnCancel.addEventListener("click", onCancel);
    btnClose.addEventListener("click", onCancel);
    modal.addEventListener("click", onBackdrop);
    document.addEventListener("keydown", onEsc);
  });
}

</script>

</body>
</html>
