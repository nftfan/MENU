<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CyberTerritories â€” Mint your digital land</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Firebase (compat SDK) -->
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>
  <style>
    :root {
      --primary: #00f9ff;
      --primary-glow: rgba(0, 249, 255, 0.5);
      --primary-dark: #00b2ff;
      --accent: #ff2cf0;
      --accent-glow: rgba(255, 44, 240, 0.5);
      --success: #12ff9b;
      --success-glow: rgba(18, 255, 155, 0.4);
      --error: #ff3860;
      --error-glow: rgba(255, 56, 96, 0.4);
      --bg: #0c0b1d;
      --bg-dark: #07061a;
      --card: #12122a;
      --text: #eef2ff;
      --muted: #8f9cce;
      --border: #3e3f82;
      --border-glow: rgba(0, 249, 255, 0.2);
      --radius: 12px;
      --shadow: rgba(0, 0, 0, 0.4);
      --neon-shadow: 0 0 10px var(--primary-glow);
      --accent-shadow: 0 0 10px var(--accent-glow);
    }

    * { box-sizing: border-box; }
    
    html, body { 
      height: 100%; 
      scroll-behavior: smooth; 
      overscroll-behavior: none; 
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      margin: 0;
      font-family: 'Rajdhani', sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      line-height: 1.4;
      overflow-x: hidden;
      letter-spacing: 0.2px;
      font-weight: 500;
    }

    #app-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      background: radial-gradient(800px at 15% 15%, rgba(0, 249, 255, 0.08), transparent 70%),
                  radial-gradient(600px at 85% 20%, rgba(255, 44, 240, 0.08), transparent 70%),
                  linear-gradient(180deg, var(--bg-dark), var(--bg));
    }

    .cyber-grid {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: -1;
        background-image:
            linear-gradient(rgba(0, 249, 255, 0.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 249, 255, 0.05) 1px, transparent 1px);
        background-size: 40px 40px;
        animation: gridPulse 15s infinite linear;
        perspective: 1000px;
        transform-style: preserve-3d;
    }
    .cyber-grid::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(to bottom, transparent 0%, var(--bg-dark) 100%);
        animation: scanline 8s infinite linear;
        opacity: 0.5;
    }

    @keyframes gridPulse {
        0%, 100% { background-size: 40px 40px; opacity: 1; }
        50% { background-size: 42px 42px; opacity: 0.8; }
    }
    
    @keyframes scanline {
        0% { transform: translateY(-100%); }
        100% { transform: translateY(100%); }
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      position: relative;
      z-index: 10;
    }

    .brand { 
      display: flex; 
      align-items: center; 
      gap: 12px; 
    }
    
    .logo {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      display: grid;
      place-items: center;
      box-shadow: 0 0 15px rgba(0, 249, 255, 0.4);
      position: relative;
      overflow: hidden;
    }
    
    .logo::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(transparent, var(--primary), transparent 30%);
      animation: rotate 4s linear infinite;
    }
    
    .logo::after {
      content: '';
      position: absolute;
      inset: 3px;
      border-radius: 6px;
      background: var(--bg-dark);
    }
    
    .logo .material-icons { 
      font-size: 22px;
      color: var(--primary);
      position: relative;
      z-index: 2;
      text-shadow: 0 0 8px var(--primary-glow);
    }

    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .title h1 { 
      margin: 0;
      font-size: 24px;
      font-weight: 700;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 5px rgba(0, 249, 255, 0.3);
    }
    
    .title p { 
      margin: 0;
      font-size: 14px;
      color: var(--muted);
    }

    .actions { 
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    button {
      appearance: none;
      border: 1px solid transparent;
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 14px;
      font-weight: 600;
      font-family: 'Rajdhani', sans-serif;
      color: var(--text);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(32, 33, 77, 0.6);
      border-color: var(--border);
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    button::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: 0.5s;
    }
    
    button:hover::after {
      left: 100%;
    }
    
    button .material-icons { font-size: 18px; }
    
    button.primary { 
      background: linear-gradient(135deg, var(--primary-dark), var(--primary));
      border-color: var(--primary);
      box-shadow: 0 0 10px var(--primary-glow);
      text-shadow: 0 0 5px var(--primary);
    }
    
    button.success { 
      background: linear-gradient(135deg, var(--success), #00ddb9);
      border-color: var(--success);
      box-shadow: 0 0 10px var(--success-glow);
      color: #07172c;
      font-weight: 700;
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
    }
    
    button.accent { 
      background: linear-gradient(135deg, var(--accent), #ff6afc);
      border-color: var(--accent);
      box-shadow: 0 0 10px var(--accent-glow);
      color: #07172c;
      font-weight: 700;
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
    }
    
    button:disabled { 
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none;
    }
    
    button:not(:disabled):active { 
      transform: translateY(1px) scale(0.98);
    }

    .wallet { 
      color: var(--primary);
      font-size: 14px;
      font-weight: 700;
      text-shadow: 0 0 5px var(--primary-glow);
      background: rgba(0, 249, 255, 0.1);
      padding: 4px 10px;
      border-radius: 8px;
      border: 1px solid rgba(0, 249, 255, 0.3);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(15, 16, 40, 0.7);
      color: var(--muted);
      backdrop-filter: blur(5px);
    }
    
    .pill .material-icons {
      font-size: 16px;
      color: var(--primary);
    }

    main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      padding: 0 16px 16px;
      flex: 1;
    }
    
    @media (min-width: 980px) {
      main {
        grid-template-columns: 1.6fr 1fr;
        max-width: 1440px;
        margin: 0 auto;
        width: 100%;
      }
    }

    .map-container {
      position: relative;
      width: 100%;
      height: 70vh;
      border-radius: var(--radius);
      grid-column: 1 / -1;
      overflow: hidden;
      background: var(--card);
      padding: 2px;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      box-shadow: 0 0 25px rgba(0, 0, 0, 0.5),
                 0 0 15px var(--primary-glow);
    }
    
    #map {
      height: 100%;
      width: 100%;
      border-radius: calc(var(--radius) - 2px);
      overflow: hidden;
      background: #070814;
    }
    
    .leaflet-control-attribution {
      background: rgba(7, 8, 30, 0.7) !important;
      color: var(--muted) !important;
      font-family: 'Rajdhani', sans-serif;
      font-size: 10px;
      backdrop-filter: blur(5px);
      border-radius: 4px !important;
      padding: 2px 5px !important;
    }
    
    .leaflet-control-attribution a {
      color: var(--primary) !important;
    }
    
    .leaflet-control-zoom {
      border: none !important;
      border-radius: 8px !important;
      overflow: hidden;
    }
    
    .leaflet-control-zoom a {
      background: rgba(15, 16, 40, 0.9) !important;
      color: var(--primary) !important;
      border: 1px solid var(--border) !important;
      transition: all 0.2s ease !important;
    }
    
    .leaflet-control-zoom a:hover {
      background: rgba(30, 31, 70, 0.9) !important;
      color: var(--text) !important;
    }

    .leaflet-popup-content-wrapper {
      background: rgba(15, 16, 40, 0.95) !important;
      border-radius: 10px !important;
      border: 1px solid var(--border) !important;
      backdrop-filter: blur(10px) !important;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.5) !important;
    }
    
    .leaflet-popup-content {
      color: var(--text) !important;
      font-family: 'Rajdhani', sans-serif !important;
      margin: 12px 16px !important;
    }
    
    .leaflet-popup-tip {
      background: rgba(15, 16, 40, 0.95) !important;
    }
    
    .leaflet-popup-close-button {
      color: var(--primary) !important;
      text-shadow: 0 0 5px var(--primary-glow);
    }

    .popup-action-btn {
      width: 100%;
      margin-top: 12px;
      padding: 8px 12px;
      font-size: 13px;
      background: rgba(0, 249, 255, 0.1);
      border-color: rgba(0, 249, 255, 0.3);
      color: var(--primary);
    }
    .popup-action-btn:hover {
        background: rgba(0, 249, 255, 0.2);
        box-shadow: 0 0 8px var(--primary-glow);
    }

    .panel {
      background: rgba(18, 18, 42, 0.75);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      display: grid;
      gap: 16px;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 25px var(--shadow);
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .panel::after {
      content: '';
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--primary), var(--accent), transparent);
      z-index: 2;
      box-shadow: 0 0 15px var(--primary-glow);
    }
    
    .row { 
      display: grid;
      gap: 12px;
    }
    
    .row.inline { 
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(62, 63, 130, 0.3);
    }
    
    .panel-header h2 {
      margin: 0;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      color: var(--primary);
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 5px var(--primary-glow);
    }

    .legend {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 14px;
      color: var(--muted);
    }
    
    .legend .key { 
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    
    .legend .box { 
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
    }
    
    .status {
      min-height: 46px;
      display: grid;
      place-items: center;
      text-align: center;
      font-size: 14px;
      border-radius: 8px;
      padding: 12px;
      background: rgba(8, 9, 33, 0.5);
      border: 1px solid rgba(62, 63, 130, 0.3);
      color: var(--muted);
      transition: all 0.3s ease;
    }
    
    .status.success { 
      background: rgba(18, 255, 155, 0.07);
      color: var(--success);
      border-color: rgba(18, 255, 155, 0.25);
      box-shadow: 0 0 10px rgba(18, 255, 155, 0.1);
    }
    
    .status.error { 
      background: rgba(255, 56, 96, 0.07);
      color: var(--error);
      border-color: rgba(255, 56, 96, 0.25);
      box-shadow: 0 0 10px rgba(255, 56, 96, 0.1);
    }
    
    .status.loading { 
      display: inline-flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
    }
    
    .spinner {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-left-color: var(--primary);
      animation: spin 1s linear infinite;
      box-shadow: 0 0 10px var(--primary-glow);
    }
    
    @keyframes spin { 
      to { transform: rotate(360deg); }
    }

    .toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      background: rgba(12, 13, 38, 0.9);
      color: var(--text);
      border-left: 3px solid var(--primary);
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3),
                 0 0 10px var(--primary-glow);
      z-index: 9999;
      font-size: 14px;
      backdrop-filter: blur(10px);
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -10px); }
      to { opacity: 1; transform: translate(-50%, 0); }
    }
    
    .toast .spinner { 
      width: 18px;
      height: 18px;
      border-width: 2px;
    }
    
    .toast .material-icons { 
      font-size: 20px;
      color: var(--primary);
      text-shadow: 0 0 5px var(--primary-glow);
    }

    .form-group {
      display: grid;
      gap: 6px;
    }

    .form-group label {
      font-size: 14px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .form-group input[type="text"],
    .form-group input[type="color"] {
      font-family: 'Rajdhani', sans-serif;
      font-size: 16px;
      color: var(--text);
      background: rgba(8, 9, 33, 0.5);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      transition: all 0.2s ease;
    }

    .form-group input[type="text"]:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 8px var(--primary-glow);
    }
    
    .form-group input[type="color"] {
      padding: 4px 8px;
      height: 40px;
      cursor: pointer;
    }

    .resource-marker {
      font-size: 24px;
      text-align: center;
      animation: neon-glow 2.5s infinite alternate;
      text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px var(--primary), 0 0 20px var(--primary);
    }

    @keyframes neon-glow {
      from {
        text-shadow: 0 0 4px #fff, 0 0 8px #fff, 0 0 12px var(--primary-glow), 0 0 16px var(--primary-glow);
      }
      to {
        text-shadow: 0 0 6px #fff, 0 0 12px #fff, 0 0 18px var(--primary-glow), 0 0 24px var(--primary-glow);
      }
    }
    
    .leaderboard-panel {
      grid-column: 1 / -1;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .leaderboard-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .leaderboard-table th, .leaderboard-table td {
      padding: 8px 10px;
      text-align: left;
      border-bottom: 1px solid rgba(62, 63, 130, 0.3);
    }
    
    .leaderboard-table th {
      color: var(--primary);
      font-family: 'Orbitron', sans-serif;
      font-weight: 500;
      font-size: 11px;
    }
    
    .leaderboard-table td {
      color: var(--muted);
    }
    
    .leaderboard-table tr:last-child td {
      border-bottom: none;
    }
    .leaderboard-table tr:hover {
        background: rgba(0, 249, 255, 0.05);
    }

    .leaderboard-table .rank { width: 40px; text-align: center; color: var(--accent); font-weight: 700; font-size: 11px; }
    .leaderboard-table .owner { width: 150px; font-weight: 600; }
    .leaderboard-table .value { text-align: right; color: var(--success); font-weight: 700; }
    .leaderboard-table .area { text-align: right; color: var(--primary); font-weight: 700; }
    .leaderboard-table .rewards { text-align: right; color: var(--accent); font-weight: 700; }

    @media (max-width: 640px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
      
      .actions {
        width: 100%;
        justify-content: space-between;
      }
      
      main {
        padding: 0 12px 12px;
        gap: 12px;
      }
      
      .map-container {
        height: 60vh;
      }
      
      button {
        padding: 8px 12px;
        font-size: 13px;
      }
      
      .panel {
        padding: 12px;
      }
      
      .legend {
        font-size: 12px;
        gap: 10px;
      }
      
      .status {
        font-size: 13px;
        padding: 10px;
        min-height: 42px;
      }
    }

    @keyframes glitch {
      0% { transform: translate(0); }
      20% { transform: translate(-2px, 1px); }
      40% { transform: translate(-2px, -1px); }
      60% { transform: translate(2px, 1px); }
      80% { transform: translate(2px, -1px); }
      100% { transform: translate(0); }
    }
    
    .glitch-text {
      position: relative;
      display: inline-block;
    }
    
    .glitch-text:hover::before,
    .glitch-text:hover::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg);
    }
    
    .glitch-text:hover::before {
      animation: glitch 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) both infinite;
      color: var(--primary);
      text-shadow: 0 0 5px var(--primary-glow);
      clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
      transform: translate(-2px, -2px);
    }
    
    .glitch-text:hover::after {
      animation: glitch 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) reverse both infinite;
      color: var(--accent);
      text-shadow: 0 0 5px var(--accent-glow);
      clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
      transform: translate(2px, 2px);
    }

    #initial-loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: var(--bg-dark);
      z-index: 10000;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }

    #initial-loader .loader-content {
      text-align: center;
      color: var(--primary);
    }

    #initial-loader .spinner {
      width: 50px;
      height: 50px;
      border-width: 4px;
      margin: 0 auto 20px;
    }

    #initial-loader .loader-text {
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      letter-spacing: 1px;
      text-shadow: 0 0 10px var(--primary-glow);
    }

    #initial-loader.hidden {
      opacity: 0;
      visibility: hidden;
    }
  </style>
</head>
<body>
  <div id="initial-loader">
    <div class="loader-content">
      <div class="spinner"></div>
      <div class="loader-text">Initializing CyberTerritories...</div>
    </div>
  </div>

  <div id="app-container">
    <div class="cyber-grid"></div>
    <header>
      <div class="brand">
        <div class="logo"><span class="material-icons">language</span></div>
        <div class="title">
          <h1 class="glitch-text" data-text="CyberTerritories">CyberTerritories</h1>
          <p>Mint your digital land in the metaverse</p>
        </div>
      </div>
      <div class="actions">
        <span class="pill">
          <span class="material-icons">paid</span> 
          <span>Mint Price: <strong style="margin-left:4px;color:var(--primary);">0.01 - 100 POL (by area)</strong></span>
        </span>
        <button id="connectBtn" class="primary">
          <span class="material-icons">account_balance_wallet</span>Connect
        </button>
        <span id="wallet" class="wallet" style="display:none;"></span>
      </div>
    </header>

    <main>
      <div class="map-container">
        <div id="map" aria-label="Map"></div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <h2 class="glitch-text" data-text="Territory Control">Territory Control</h2>
        </div>
        
        <div class="row">
          <div class="legend">
            <div class="key"><span class="box" style="background:#191d3b;box-shadow:0 0 3px rgba(0,249,255,0.2);"></span> Not selected</div>
            <div class="key"><span class="box" style="background:#0055ff;box-shadow:0 0 5px #0055ff;"></span> Selected</div>
            <div class="key"><span class="box" style="background:#ff2cf0;box-shadow:0 0 5px rgba(255,44,240,0.5);"></span> Minted (Other)</div>
            <div class="key"><span class="box" style="background:#12ff9b;box-shadow:0 0 5px rgba(18,255,155,0.5);"></span> Minted (You)</div>
          </div>
        </div>

        <div class="row" style="grid-template-columns: 1fr 100px; gap: 10px;">
            <div class="form-group">
                <label for="empireNameInput">Empire Name</label>
                <input type="text" id="empireNameInput" placeholder="e.g. The Void Syndicate" maxlength="32" />
            </div>
            <div class="form-group">
                <label for="empireColorInput">Empire Color</label>
                <input type="color" id="empireColorInput" value="#00f9ff" />
            </div>
        </div>

        <div class="row inline">
          <span id="selectionPill" class="pill" style="display:none;"></span>
          <span id="ownedCountPill" class="pill" style="display:none;"></span>
          <span id="mintedCountPill" class="pill" style="display:none;"></span>
        </div>

        <div class="row inline">
          <button id="mintBtn" class="success" disabled>
            <span class="material-icons">rocket_launch</span>Mint Territory
          </button>
          <button id="clearBtn" class="accent">
            <span class="material-icons">delete_sweep</span>Clear
          </button>
          <button id="refreshBtn">
            <span class="material-icons">refresh</span>Refresh
          </button>
        </div>

        <div id="status" class="status">Select a territory on the map to claim it</div>
      </div>
      
      <div id="leaderboard" class="panel leaderboard-panel">
        <div class="panel-header">
          <h2 class="glitch-text" data-text="Richest Owners">Richest Owners</h2>
        </div>
        <table class="leaderboard-table">
          <thead>
            <tr>
              <th class="rank">#</th>
              <th class="owner">Owner</th>
              <th class="value">Total Value</th>
              <th class="area">Total Area (kmÂ²)</th>
              <th class="rewards">NFTFAN Rewards</th>
            </tr>
          </thead>
          <tbody id="leaderboard-body">
          </tbody>
        </table>
      </div>

    </main>
  </div>

  <div id="cityLoading" class="toast" role="status" aria-live="assertive" aria-atomic="true">
    <span class="spinner" aria-hidden="true"></span>
    <span class="material-icons" aria-hidden="true">location_city</span>
    <span class="text">Loading territory data...</span>
  </div>

  <script>
    // Polygon Mainnet
    const POLYGON_PARAMS = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 }, // Use MATIC for broad wallet compatibility
      rpcUrls: ['https://polygon-rpc.com/'],
      blockExplorerUrls: ['https://polygonscan.com/']
    };

    const CONTRACT_ADDRESS = "0xb7d9E197905A0Fe7A59d82029eEFCBfDa631E2CC";
    const CONTRACT_ABI = [
      "function mintWithURI(string tokenURI) external payable returns (uint256)",
      "function mintPrice() view returns (uint256)",
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"
    ];

    const firebaseConfig = {
      apiKey: "AIzaSyC6wYBu-KOXkDmB-84_7OPtY71zBX4FzRY",
      authDomain: "newnft-47bd7.firebaseapp.com",
      databaseURL: "https://newnft-47bd7-default-rtdb.firebaseio.com",
      projectId: "newnft-47bd7",
      storageBucket: "newnft-47bd7.firebasestorage.app",
      messagingSenderId: "172043823738",
      appId: "1:172043823738:web:daf1fcfb7862d7d8f029c3",
      measurementId: "G-8VB3DYRNXR"
    };
    
    const RESOURCE_EMOJIS = ['ðŸ’°', 'ðŸ’Ž', 'ðŸ’µ', 'ðŸª™', 'â˜¢ï¸', 'ðŸ’£', 'ðŸ”', 'ðŸ•', 'ðŸŽ', 'ðŸž', 'ðŸ§‘â€ðŸ¤â€ðŸ§‘', 'ðŸ‘¨â€ðŸ‘©â€ðŸ‘§â€ðŸ‘¦'];

    let map, mintedLayerGroup, resourceLayerGroup, selectionLayer;
    let selected = null; 
    let isCityLoading = false;
    let searchBounds = null;
    let currentMintPrice = 0;
    let selectedAreaKm2 = 0;

    const mintedLayersByAreaId = new Map(); 
    const areaDataByAreaId = new Map(); 

    let web3Provider, signer, userAddress;
    let empireName = '', empireColor = '#00f9ff';

    let fbApp, fbDb, allNftsRef = null;
    let bootComplete = false;

    const initialLoader = document.getElementById('initial-loader');
    const connectBtn = document.getElementById('connectBtn');
    const walletEl = document.getElementById('wallet');
    const mintBtn = document.getElementById('mintBtn');
    const clearBtn = document.getElementById('clearBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const statusEl = document.getElementById('status');
    const selectionPill = document.getElementById('selectionPill');
    const ownedCountPill = document.getElementById('ownedCountPill');
    const mintedCountPill = document.getElementById('mintedCountPill');
    const cityLoadingEl = document.getElementById('cityLoading');
    const empireNameInput = document.getElementById('empireNameInput');
    const empireColorInput = document.getElementById('empireColorInput');
    const leaderboardBody = document.getElementById('leaderboard-body');
    const mapEl = document.getElementById('map');

    function markBootComplete(reason = '') {
      if (bootComplete) return;
      bootComplete = true;
      initialLoader.classList.add('hidden');
      if (reason) console.log('Boot complete:', reason);
    }

    function showCityLoading(text = 'Loading territory data...') {
      cityLoadingEl.querySelector('.text').textContent = text;
      cityLoadingEl.style.display = 'inline-flex';
      setTimeout(() => {
        if (cityLoadingEl.style.display !== 'none') hideCityLoading();
      }, 20000);
    }
    
    function hideCityLoading() {
      cityLoadingEl.style.display = 'none';
    }

    function setStatus(msg, type = '') {
      if (!msg) {
        statusEl.textContent = '';
        statusEl.className = 'status';
        return;
      }
      statusEl.className = 'status';
      if (type === 'success') statusEl.classList.add('success');
      if (type === 'error') statusEl.classList.add('error');
      if (type === 'loading') {
        statusEl.classList.add('loading');
        statusEl.innerHTML = `<span class="spinner"></span><span>${msg}</span>`;
      } else {
        statusEl.textContent = msg;
      }
    }
    
    function toFixed5(n) { return (Math.round(n * 100000) / 100000).toFixed(5); }
    function escapeHTML(s) { return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }
    function shortAddr(a) { return a ? `${a.slice(0,6)}...${a.slice(-4)}` : ''; }
    function radians(deg) { return deg * Math.PI / 180; }

    function calculateAreaInKm2(geojson) {
      if (!geojson || !geojson.coordinates) return 0;
      const coordinates = geojson.type === 'Polygon' ? [geojson.coordinates] : geojson.coordinates;
      let area = 0;
      const R = 6378.137;
      for (const polygon of coordinates) {
        const ring = polygon[0];
        for (let i = 0; i < ring.length - 1; i++) {
          const p1 = ring[i];
          const p2 = ring[i + 1];
          const lon1 = radians(p1[0]);
          const lat1 = radians(p1[1]);
          const lon2 = radians(p2[0]);
          const lat2 = radians(p2[1]);
          area += (lon2 - lon1) * (2 + Math.sin(lat1) + Math.sin(lat2));
        }
      }
      area = Math.abs(area) * (R * R) / 2;
      return area;
    }

    function initMap() {
      if (!window.L) { 
        setStatus('Leaflet map library failed to load.', 'error');
        markBootComplete('leaflet-failed');
        return;
      }
      
      map = L.map('map', {
        center: [20, 0],
        zoom: 3,
        zoomControl: true,
        worldCopyJump: false,
        maxBounds: [[-90, -180], [90, 180]],
        minZoom: 2,
        maxBoundsViscosity: 1.0
      });

      const tiles = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        subdomains: 'abcd',
      }).addTo(map);

      // Hide loader when tiles load or after a short fallback
      tiles.on('load', () => markBootComplete('tiles-loaded'));
      setTimeout(() => markBootComplete('tiles-fallback-2s'), 2000);

      mintedLayerGroup = L.layerGroup().addTo(map);
      resourceLayerGroup = L.layerGroup().addTo(map);
      map.on('click', onMapClick);
      map.on('popupopen', onPopupOpen);
      setTimeout(() => map.invalidateSize(), 300);
      setStatus('Connect your wallet or select a territory on the map.');
    }

    async function onMapClick(e) {
      if (isCityLoading) return;
      
      const { lat, lng } = e.latlng;

      if (searchBounds && !searchBounds.contains(e.latlng)) {
          setStatus('Click inside the highlighted exploration area.', 'error');
          return;
      }

      try {
        isCityLoading = true;
        showCityLoading('Searching for territory...');
        setStatus('Looking up territory for this location...', 'loading');

        const area = await reverseGeocodeWithPolygon(lat, lng);

        if (!area) {
          setStatus('No mintable territory found here. Try clicking on a city or defined region.', 'error');
          return;
        }
        
        selectArea(area);
        setStatus('Territory selected. Ready to mint.', 'success');
      } catch (err) {
        console.error("Reverse geocode error:", err);
        setStatus('Territory lookup failed. The service may be busy.', 'error');
      } finally {
        isCityLoading = false;
        hideCityLoading();
      }
    }
    
    async function reverseGeocodeWithPolygon(lat, lng) {
      const mapZoom = map.getZoom();
      let nominatimZoom;

      if (mapZoom >= 15) nominatimZoom = 18;
      else if (mapZoom >= 13) nominatimZoom = 16;
      else if (mapZoom >= 10) nominatimZoom = 14;
      else if (mapZoom >= 8) nominatimZoom = 10;
      else if (mapZoom >= 6) nominatimZoom = 8;
      else if (mapZoom >= 4) nominatimZoom = 5;
      else nominatimZoom = 3;

      const url = new URL('https://nominatim.openstreetmap.org/reverse');
      url.searchParams.set('format', 'jsonv2');
      url.searchParams.set('lat', lat);
      url.searchParams.set('lon', lng);
      url.searchParams.set('zoom', nominatimZoom);
      url.searchParams.set('polygon_geojson', '1');
      url.searchParams.set('addressdetails', '1');

      if (searchBounds) {
          url.searchParams.set('viewbox', searchBounds.toBBoxString());
          url.searchParams.set('bounded', '1');
      }

      // Abort fetch if too slow to keep UI responsive
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 12000);

      const res = await fetch(url.toString(), { 
        signal: controller.signal,
        headers: { 'Accept': 'application/json' } // avoid forbidden headers like User-Agent
      }).catch(err => {
        if (err.name === 'AbortError') throw new Error('Reverse geocoding timed out');
        throw err;
      });
      clearTimeout(timeout);
      
      if (!res.ok) throw new Error(`Nominatim reverse geocoding failed with status ${res.status}`);
      const data = await res.json();

      const geojson = data.geojson || data.geometry;
      if (!geojson || !geojson.type || !geojson.coordinates || !data.osm_id) return null;

      const { osm_id, osm_type, display_name, class: cls, type: typ, lat: data_lat, lon: data_lon } = data;
      const center = { lat: Number(data_lat), lng: Number(data_lon) };
      const id = makeAreaId(osm_type, osm_id);
      
      return { id, name: display_name || 'Unknown area', type: `${cls || 'region'}:${typ || 'unknown'}`, center, geojson };
    }

    function makeAreaId(osmType, osmId) {
      return `osm:${(osmType || '').toLowerCase()}:${osmId}`;
    }

    function areaStyle(isMinted, isMine, isSelected, ownerData = {}) {
      let fill = '#191d3b';
      let weight = 1.5;
      let opacity = 0.7;
      let fillOpacity = 0.5;
      
      if (isMinted) {
        fill = ownerData.empireColor || '#ff2cf0';
        weight = 2;
      }
      
      if (isMine) {
        fill = ownerData.empireColor || '#12ff9b';
      }
      
      if (isSelected && !isMinted) {
        fill = '#0055ff';
        weight = 2.5;
        opacity = 1;
        fillOpacity = 0.6;
      }
      
      return { 
        color: '#3a3f6d', weight, opacity, fillColor: fill, fillOpacity,
        dashArray: isSelected ? undefined : '3',
      };
    }

    function shortenName(name) {
      const n = String(name || '');
      if (n.length <= 60) return n;
      const firstComma = n.indexOf(',');
      return (firstComma > 0) ? n.slice(0, firstComma) + 'â€¦' : n.slice(0, 57) + 'â€¦';
    }

    function selectArea(area) {
      clearSelection();
      selected = area;
      
      const isMinted = areaDataByAreaId.has(area.id);
      const ownerData = areaDataByAreaId.get(area.id) || {};
      const isMine = userAddress && ownerData.owner === userAddress.toLowerCase();
      const demoPrice = calculateDemoPrice(area.geojson);
      selectedAreaKm2 = calculateAreaInKm2(area.geojson);

      // Smooth mint price scaling; avoid scientific notation with parseUnits later
      if (selectedAreaKm2 <= 100000) {
        currentMintPrice = 1;
      } else {
        currentMintPrice = selectedAreaKm2 * 0.00001;
      }

      selectionLayer = L.geoJSON(area.geojson, { 
        style: () => areaStyle(isMinted, isMine, true, ownerData) 
      }).addTo(map);

      if (!isMinted) {
        spawnResources(area.geojson);
      }

      const bounds = selectionLayer.getBounds();
      if (bounds.isValid()) {
          map.fitBounds(bounds, { padding: [50, 50], maxZoom: 14 });
      }

      const popupColor = isMine ? (ownerData.empireColor || '#12ff9b') : isMinted ? (ownerData.empireColor || '#ff2cf0') : '#00f9ff';
      const statusText = isMine ? 'âœ“ You own this territory' : isMinted ? `âš  Minted by ${ownerData.empireName || 'another user'}` : 'âœ¦ Available for minting';
      const rewards = selectedAreaKm2 * 1000000;
      
      let popupHTML = `
        <div style="min-width:250px;">
          <div style="font-weight:800;margin-bottom:8px;font-family:'Orbitron',sans-serif;color:${popupColor};text-shadow:0 0 5px ${popupColor}80;font-size:15px;">${escapeHTML(shortenName(area.name))}</div>
          <div style="font-size:13px;color:#8f9cce;margin:4px 0;">Value: <span style="color:var(--success);font-weight:700;">${formatCurrency(demoPrice)}</span></div>
          <div style="font-size:13px;color:#8f9cce;margin:4px 0;">Area: <span style="color:var(--primary);font-weight:700;">${selectedAreaKm2.toFixed(2)} kmÂ²</span></div>
          <div style="font-size:13px;color:#8f9cce;margin:4px 0;">NFTFAN Rewards: <span style="color:var(--accent);font-weight:700;">${rewards.toLocaleString()} $NFTFAN</span></div>
          <div style="font-size:13px;color:#8f9cce;margin:4px 0;">Center: <span style="color:#eef2ff">${toFixed5(area.center.lat)}, ${toFixed5(area.center.lng)}</span></div>
          <div style="font-size:13px;color:#eef2ff;margin-top:10px;padding:6px 10px;border-radius:6px;background:rgba(0,0,0,0.2);border-left:3px solid ${popupColor}">${statusText}</div>
      `;
      if (!isMinted && !isMine) {
        popupHTML += `<div style="font-size:13px;color:#8f9cce;margin:4px 0;">Mint Cost: <span style="color:var(--success);font-weight:700;">${currentMintPrice.toFixed(2)} POL</span></div>`;
      }
      popupHTML += `
          <div style="font-size:11px;color:#5a5f8a;margin-top:10px;">ID: ${escapeHTML(area.id)}</div>
        </div>
      `;

      selectionLayer.bindPopup(popupHTML).openPopup();

      selectionPill.style.display = 'inline-flex';
      selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">${isMine ? 'verified' : isMinted ? 'gavel' : 'place'}</span> ${escapeHTML(shortenName(area.name))} Â· ${selectedAreaKm2.toFixed(2)} kmÂ² Â· <span style="color:${popupColor};">${isMine ? 'You own' : isMinted ? 'Minted' : 'Available'}</span>`;
      
      updateMintButtonState();
      if (!isMinted) {
        mintBtn.innerHTML = `<span class="material-icons">rocket_launch</span>Mint for ${currentMintPrice.toFixed(2)} POL`;
        setStatus(`Territory selected. Mint price: ${currentMintPrice.toFixed(2)} POL. Rewards: ${rewards.toLocaleString()} $NFTFAN tokens.`, 'success');
      }
    }

    async function switchToPolygon() {
      if (!window.ethereum) return false;
      try {
        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: POLYGON_PARAMS.chainId }] });
        return true;
      } catch (e) {
        if (e.code === 4902) {
          try {
            await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [POLYGON_PARAMS] });
            return true;
          } catch { setStatus('Failed to add Polygon network', 'error'); return false; }
        }
        setStatus('Failed to switch network', 'error');
        return false;
      }
    }

    async function connectWallet() {
      if (!window.ethereum) { setStatus('Please install MetaMask to continue', 'error'); return; }
      
      try {
        setStatus('Connecting wallet...', 'loading');
        if (!await switchToPolygon()) return;

        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        await web3Provider.send('eth_requestAccounts', []);
        signer = web3Provider.getSigner();
        userAddress = await signer.getAddress();

        connectBtn.disabled = true;
        connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
        walletEl.textContent = shortAddr(userAddress);
        walletEl.style.display = 'inline-block';
        
        await loadEmpireSettings();
        setStatus('Wallet connected.', 'success');
        
        restyleAllMintedPolygons();
        updateMintButtonState();

        if (window.ethereum?.on) {
          window.ethereum.removeListener?.('accountsChanged', onAccountsChanged);
          window.ethereum.on('accountsChanged', onAccountsChanged);
          window.ethereum.removeListener?.('chainChanged', onChainChanged);
          window.ethereum.on('chainChanged', onChainChanged);
        }
      } catch (e) {
        console.error(e);
        setStatus('Wallet connection failed', 'error');
      }
    }

    async function onAccountsChanged(accounts) {
      userAddress = (accounts && accounts[0]) ? accounts[0] : null;
      if (userAddress) {
        walletEl.textContent = shortAddr(userAddress);
        walletEl.style.display = 'inline-block';
        connectBtn.disabled = true;
        connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
        await loadEmpireSettings();
      } else {
        walletEl.style.display = 'none';
        connectBtn.disabled = false;
        connectBtn.innerHTML = '<span class="material-icons">account_balance_wallet</span>Connect';
      }
      restyleAllMintedPolygons();
      updateMintButtonState();
    }

    function onChainChanged(chainId) {
      if (chainId !== POLYGON_PARAMS.chainId) {
        setStatus('Wrong network. Switching to Polygon...', 'loading');
        switchToPolygon().then((ok) => {
          if (!ok) setStatus('Please switch to Polygon network (0x89).', 'error');
          else setStatus('Switched to Polygon.', 'success');
        });
      }
    }
    
    function buildAreaTokenURI(area, empireName, empireColor) {
      const image = buildAreaSVG(area, empireName, empireColor);
      const areaKm2 = calculateAreaInKm2(area.geojson);
      const metadata = {
        name: `Territory: ${shortenName(area.name)}`,
        description: `Digital territory NFT from the ${empireName} empire. OSM Type: ${area.type}`,
        image,
        attributes: [
          { trait_type: "Area ID", value: area.id },
          { trait_type: "Area Type", value: area.type },
          { trait_type: "Area (kmÂ²)", value: areaKm2.toFixed(2) },
          { trait_type: "Center Latitude", value: Number(area.center.lat.toFixed(6)) },
          { trait_type: "Center Longitude", value: Number(area.center.lng.toFixed(6)) },
          { trait_type: "Empire Name", value: empireName },
          { trait_type: "Empire Color", value: empireColor }
        ]
      };
      const json = JSON.stringify(metadata);
      return "data:application/json;base64," + btoa(unescape(encodeURIComponent(json)));
    }

    function buildAreaSVG(area, empireName, empireColor) {
        const name = escapeHTML(shortenName(area.name));
        const type = escapeHTML(area.type || '');
        const lat = toFixed5(area.center.lat);
        const lng = toFixed5(area.center.lng);
        const empName = escapeHTML(empireName);

        const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="800" height="420" viewBox="0 0 800 420">
          <defs>
            <linearGradient id="bgGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#070814" />
              <stop offset="100%" stop-color="#12122a" />
            </linearGradient>
            <linearGradient id="titleGrad" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="${empireColor}" />
              <stop offset="100%" stop-color="#eef2ff" />
            </linearGradient>
            <filter id="glow">
              <feGaussianBlur stdDeviation="3.5" result="blur" />
              <feFlood flood-color="${empireColor}" flood-opacity="0.4" result="color" />
              <feComposite in="color" in2="blur" operator="in" result="glow" />
              <feMerge>
                <feMergeNode in="glow" />
                <feMergeNode in="SourceGraphic" />
              </feMerge>
            </filter>
            <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
              <path d="M 40 0 L 0 0 0 40" fill="none" stroke="${empireColor}" stroke-width="0.5" opacity="0.2" />
            </pattern>
          </defs>
          <rect width="800" height="420" fill="url(#bgGrad)" />
          <rect width="800" height="420" fill="url(#grid)" />
          <rect x="10" y="10" width="780" height="400" rx="15" fill="none" 
                stroke="${empireColor}" stroke-width="2" filter="url(#glow)" />
          <g font-family="'Orbitron', sans-serif">
            <text x="40" y="80" font-size="28" font-weight="700" fill="url(#titleGrad)" filter="url(#glow)">
              ${empName.toUpperCase()}
            </text>
            <text x="40" y="130" font-size="40" font-weight="900" fill="#eef2ff">${name}</text>
            <text x="40" y="175" font-size="20" fill="#8f9cce">${type}</text>
            <text x="40" y="220" font-size="18" fill="#8f9cce">Location: ${lat}, ${lng}</text>
            <g transform="translate(40,270)">
              <rect width="280" height="60" rx="10" fill="none" stroke="${empireColor}" stroke-width="2" />
              <rect x="1" y="1" width="278" height="58" rx="9" fill="${empireColor}1A" />
              <text x="30" y="38" font-size="22" font-weight="700" fill="${empireColor}" filter="url(#glow)">DIGITAL TERRITORY</text>
            </g>
          </g>
        </svg>`;
      
      return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
    }

    async function mintSelectedArea() {
      try {
        if (!userAddress) { setStatus('Please connect your wallet first', 'error'); return; }
        if (!selected) { setStatus('Select a territory on the map first', 'error'); return; }
        if (areaDataByAreaId.has(selected.id)) { setStatus('This territory is already minted', 'error'); return; }
        if (!empireName) { setStatus('Please enter an Empire Name before minting', 'error'); return; }

        setStatus('Submitting mint transaction...', 'loading');
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        const tokenURI = buildAreaTokenURI(selected, empireName, empireColor);

        // Avoid scientific notation issues by fixing decimals and using parseUnits
        const priceWei = ethers.utils.parseUnits(Number(currentMintPrice).toFixed(6), 'ether');

        const tx = await contract.mintWithURI(tokenURI, { value: priceWei });
        
        setStatus('Transaction sent! Waiting for confirmation...', 'loading');
        const receipt = await tx.wait();

        const ev = receipt.events?.find(e => e.event === 'Transfer');
        const mintedTokenId = ev?.args?.tokenId?.toString() || `temp-${Date.now()}`;
        
        const fullNftData = {
          owner: userAddress,
          meta: {
            name: `Territory: ${shortenName(selected.name)}`,
            description: `Digital territory NFT from the ${empireName} empire. OSM Type: ${selected.type}`,
            area_id: selected.id,
            area_km2: selectedAreaKm2,
            empire_name: empireName,
            empire_color: empireColor,
            geojson: selected.geojson,
            center: selected.center,
            demoPrice: calculateDemoPrice(selected.geojson)
          }
        };

        await writeNftToFirebase(mintedTokenId, fullNftData);
        await saveEmpireSettings();

        if (selectionLayer) {
            selectionLayer.bindPopup(`
            <div style="min-width:250px;text-align:center;">
              <div style="font-weight:800;margin:8px 0;color:${empireColor};font-family:'Orbitron',sans-serif;font-size:16px;text-shadow:0 0 8px ${empireColor}90;">TERRITORY MINTED!</div>
              <div style="font-size:14px;margin:15px 0;color:#eef2ff;">${escapeHTML(shortenName(selected.name))}</div>
              <a href="https://opensea.io/assets/matic/${CONTRACT_ADDRESS}/${mintedTokenId}" target="_blank" rel="noopener noreferrer" style="display:inline-block;background:${empireColor};color:#07061a;text-decoration:none;padding:8px 15px;border-radius:6px;font-weight:700;font-family:'Rajdhani',sans-serif;">View on OpenSea â†’</a>
            </div>
          `).openPopup();
        }
        
        setStatus('Success! Your territory has been minted.', 'success');
        updateMintButtonState();

      } catch (e) {
        console.error("Minting failed:", e);
        const msg = e?.data?.message || e?.reason || e?.message || 'Unknown transaction error.';
        setStatus(`Minting failed: ${msg}`, 'error');
      }
    }
    
    function initFirebase() {
      try {
        if (!window.firebase) throw new Error("Firebase script not loaded");
        fbApp = firebase.initializeApp(firebaseConfig);
        fbDb = firebase.database();
        subscribeMintedOnFirebase();
      } catch (e) { 
        console.error('Firebase init failed', e); 
        setStatus("Could not connect to the database.", "error");
        markBootComplete('firebase-init-failed');
      }
    }

    async function subscribeMintedOnFirebase() {
      if (!fbDb) return;
      allNftsRef = fbDb.ref('nfts');

      let initialProcessed = false;

      // Attach real-time listeners immediately
      allNftsRef.on('child_added', (snap) => {
        upsertMintedAreaOnMap(snap.key, snap.val());
        if (!initialProcessed) {
          initialProcessed = true;
          markBootComplete('firebase-first-child');
        }
      });
      allNftsRef.on('child_changed', (snap) => upsertMintedAreaOnMap(snap.key, snap.val()));
      allNftsRef.on('child_removed', (snap) => removeMintedAreaFromMap(snap.key, snap.val()));

      // Try a one-time initial load with timeout fallback
      try {
        const timeoutPromise = new Promise(resolve => setTimeout(resolve, 6000, null));
        const snapshotPromise = allNftsRef.once('value');
        const snapshot = await Promise.race([snapshotPromise, timeoutPromise]);
        if (snapshot && snapshot.forEach) {
          snapshot.forEach((childSnapshot) => {
              upsertMintedAreaOnMap(childSnapshot.key, childSnapshot.val());
          });
          markBootComplete('firebase-initial-once');
        } else {
          // No data yet; still end boot to avoid stuck loader
          markBootComplete('firebase-initial-timeout');
        }
      } catch (err) {
        console.error("Firebase initial read failed:", err);
        setStatus("Cannot read territory data. Check DB rules.", "error");
        markBootComplete('firebase-initial-error');
      }

      // Absolute fallback to ensure loader never sticks
      setTimeout(() => markBootComplete('absolute-fallback-10s'), 10000);
    }

    function upsertMintedAreaOnMap(tokenId, data) {
      if (!data || !data.meta) return;
      const areaId = data.meta.area_id;
      if (!areaId) return;

      const ownerLower = (data.owner || '').toLowerCase();
      const isMine = userAddress && ownerLower === userAddress.toLowerCase();
      const areaKm2 = data.meta.area_km2 || calculateAreaInKm2(data.meta.geojson);
      
      const fullAreaData = {
          owner: ownerLower,
          empireName: data.meta.empire_name,
          empireColor: data.meta.empire_color,
          geojson: data.meta.geojson,
          name: data.meta.name,
          demoPrice: data.meta.demoPrice || calculateDemoPrice(data.meta.geojson),
          areaKm2: areaKm2
      };
      
      areaDataByAreaId.set(areaId, fullAreaData);
      
      const geojson = fullAreaData.geojson;
      if (!geojson) return;

      const prevLayer = mintedLayersByAreaId.get(areaId);
      if (prevLayer) {
        mintedLayerGroup.removeLayer(prevLayer);
      }
      
      try {
        const geoLayer = L.geoJSON(geojson, { style: () => areaStyle(true, isMine, false, fullAreaData) });

        const rewards = areaKm2 * 1000000;
        let popupHTML = `
          <div style="min-width:220px;">
            <div style="font-weight:800;margin-bottom:8px;font-family:'Orbitron',sans-serif;color:${fullAreaData.empireColor || '#ff2cf0'};font-size:15px;">
              ${escapeHTML(shortenName(fullAreaData.name))}
            </div>
            <div style="font-size:13px;color:#8f9cce;margin:4px 0;">Value: <span style="color:var(--success);font-weight:700;">${formatCurrency(fullAreaData.demoPrice)}</span></div>
            <div style="font-size:13px;color:#8f9cce;margin:4px 0;">Area: <span style="color:var(--primary);font-weight:700;">${areaKm2.toFixed(2)} kmÂ²</span></div>
            <div style="font-size:13px;color:#8f9cce;margin:4px 0;">NFTFAN Rewards: <span style="color:var(--accent);font-weight:700;">${rewards.toLocaleString()} $NFTFAN</span></div>
            <div style="font-size:13px;color:#8f9cce;margin:8px 0;">Empire: <span style="color:#eef2ff;font-weight:bold;">${escapeHTML(fullAreaData.empireName || '')}</span></div>
            <div style="font-size:12px;color:#8f9cce;margin:8px 0;">Minted by: <span style="color:#eef2ff">${shortAddr(data.owner)}</span></div>
            <div style="font-size:11px;color:#5a5f8a;margin-top:10px;">ID: ${escapeHTML(areaId)}</div>
        `;
        
        if (!isMine) {
            popupHTML += `<button class="popup-action-btn" data-area-id="${escapeHTML(areaId)}">Explore & Mint Inside</button>`;
        }
        popupHTML += `</div>`;

        geoLayer.bindPopup(popupHTML);

        geoLayer.addTo(mintedLayerGroup);
        mintedLayersByAreaId.set(areaId, geoLayer);
      } catch (e) {
        console.error(`[upsert] Leaflet failed to draw geojson for ${areaId}.`, e, geojson);
      }

      updateCountsAndLeaderboard();
      if (selected && selected.id === areaId) selectArea(selected);
    }

    function removeMintedAreaFromMap(tokenId, data) {
        if (!data || !data.meta) return;
        const areaId = data.meta.area_id;
        if(!areaId) return;

        const prevLayer = mintedLayersByAreaId.get(areaId);
        if (prevLayer) mintedLayerGroup.removeLayer(prevLayer);
        
        mintedLayersByAreaId.delete(areaId);
        areaDataByAreaId.delete(areaId);
        updateCountsAndLeaderboard();
    }

    async function writeNftToFirebase(tokenId, fullNftData) {
      if (!fbDb) return;
      await fbDb.ref(`nfts/${tokenId}`).set(fullNftData);
    }
    
    function updateCountsAndLeaderboard() {
        let myOwnedCount = 0;
        const ownerValues = {};
        const ownerAreas = {};
        const ownerRewards = {};

        if (userAddress) {
            const userAddrLower = userAddress.toLowerCase();
            for (const data of areaDataByAreaId.values()) {
                if (data.owner === userAddrLower) {
                    myOwnedCount++;
                }
            }
        }
        
        ownedCountPill.style.display = myOwnedCount > 0 ? 'inline-flex' : 'none';
        ownedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;color:var(--success);">verified</span> You own: <strong style="margin-left:4px;color:var(--success);">${myOwnedCount}</strong>`;
        
        const totalMinted = areaDataByAreaId.size;
        mintedCountPill.style.display = 'inline-flex';
        mintedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;">public</span> Total minted: <strong style="margin-left:4px;color:var(--primary);">${totalMinted}</strong>`;

        for(const data of areaDataByAreaId.values()){
            if(data.owner){
                ownerValues[data.owner] = (ownerValues[data.owner] || 0) + (data.demoPrice || 0);
                ownerAreas[data.owner] = (ownerAreas[data.owner] || 0) + (data.areaKm2 || 0);
                ownerRewards[data.owner] = (ownerRewards[data.owner] || 0) + (data.areaKm2 || 0) * 1000000;
            }
        }

        const sortedOwners = Object.entries(ownerValues)
            .map(([owner, value]) => ({ owner, value, area: ownerAreas[owner], rewards: ownerRewards[owner] }))
            .sort((a, b) => b.value - a.value);

        renderLeaderboard(sortedOwners.slice(0, 10));
    }

    function clearSelection() {
      selected = null;
      searchBounds = null;
      selectedAreaKm2 = 0;
      currentMintPrice = 0;
      mapEl.style.cursor = '';
      if (selectionLayer) selectionLayer.remove();
      resourceLayerGroup.clearLayers();
      selectionPill.style.display = 'none';
      mintBtn.innerHTML = `<span class="material-icons">rocket_launch</span>Mint Territory`;
      updateMintButtonState();
      setStatus('Selection cleared. Click anywhere to explore territories.', 'success');
    }

    function restyleAllMintedPolygons() {
      for (const [areaId, geoLayer] of mintedLayersByAreaId.entries()) {
        const data = areaDataByAreaId.get(areaId) || {};
        const isMine = userAddress && data.owner === userAddress.toLowerCase();
        geoLayer.setStyle(areaStyle(true, isMine, false, data));
      }
      updateCountsAndLeaderboard();
    }

    async function saveEmpireSettings() {
        if (!fbDb || !userAddress) return;
        await fbDb.ref(`empires/${userAddress.toLowerCase()}`).set({
            name: empireName,
            color: empireColor
        });
    }

    async function loadEmpireSettings() {
        if (!fbDb || !userAddress) return;
        const snapshot = await fbDb.ref(`empires/${userAddress.toLowerCase()}`).get();
        if (snapshot.exists()) {
            const data = snapshot.val();
            empireNameInput.value = data.name || '';
            empireColorInput.value = data.color || '#00f9ff';
        }
        updateEmpireState();
    }
    
    function updateEmpireState() {
        empireName = empireNameInput.value.trim();
        empireColor = empireColorInput.value;
        updateMintButtonState();
    }
    
    function updateMintButtonState() {
        const isMinted = selected && areaDataByAreaId.has(selected.id);
        mintBtn.disabled = !userAddress || !selected || isMinted || !empireName;
    }

    function calculateDemoPrice(geojson) {
        if (!geojson || !window.L) return 0;
        try {
            const tempLayer = L.geoJSON(geojson);
            const bounds = tempLayer.getBounds();
            if(!bounds.isValid()) return 1_000_000;

            const area = (bounds.getEast() - bounds.getWest()) * (bounds.getNorth() - bounds.getSouth());
            const logArea = Math.log10(Math.max(1e-9, area));

            const minLogArea = -12;
            const maxLogArea = 2;
            const normalized = Math.max(0, Math.min(1, (logArea - minLogArea) / (maxLogArea - minLogArea)));
            
            const minPrice = 1_000_000;
            const maxPrice = 1_000_000_000_000_000;

            const price = minPrice * Math.pow(maxPrice / minPrice, 1 - Math.pow(1 - normalized, 3));
            return Math.round(price);
        } catch {
            return 1_000_000;
        }
    }

    function formatCurrency(num) {
        if (num >= 1e15) return `$${(num / 1e15).toFixed(2)}Q`;
        if (num >= 1e12) return `$${(num / 1e12).toFixed(2)}T`;
        if (num >= 1e9) return `$${(num / 1e9).toFixed(2)}B`;
        if (num >= 1e6) return `$${(num / 1e6).toFixed(2)}M`;
        if (num >= 1e3) return `$${(num / 1e3).toFixed(2)}K`;
        return `$${Number(num).toLocaleString()}`;
    }

    function renderLeaderboard(sortedOwners) {
        leaderboardBody.innerHTML = '';
        if (sortedOwners.length === 0) {
            leaderboardBody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:var(--muted);padding:20px;">No territories minted yet.</td></tr>';
            return;
        }
        sortedOwners.forEach((entry, index) => {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td class="rank">${index + 1}</td>
                <td class="owner">${shortAddr(entry.owner)}</td>
                <td class="value">${formatCurrency(entry.value)}</td>
                <td class="area">${entry.area.toFixed(2)}</td>
                <td class="rewards">${entry.rewards.toLocaleString()} $NFTFAN</td>
            `;
            leaderboardBody.appendChild(row);
        });
    }

    function spawnResources(geojson) {
        const bounds = L.geoJSON(geojson).getBounds();
        const count = Math.floor(Math.random() * 10) + 5;

        for (let i = 0; i < count; i++) {
            const point = getRandomPointInPolygon(geojson, bounds);
            if (point) {
                const emoji = RESOURCE_EMOJIS[Math.floor(Math.random() * RESOURCE_EMOJIS.length)];
                const icon = L.divIcon({
                    className: 'resource-marker',
                    html: emoji,
                    iconSize: [24, 24],
                });
                L.marker([point[1], point[0]], { icon }).addTo(resourceLayerGroup);
            }
        }
    }

    function getRandomPointInPolygon(geojson, bounds) {
        const MAX_ATTEMPTS = 50;
        const minX = bounds.getWest(), minY = bounds.getSouth();
        const maxX = bounds.getEast(), maxY = bounds.getNorth();

        for (let i = 0; i < MAX_ATTEMPTS; i++) {
            const lat = minY + (Math.random() * (maxY - minY));
            const lng = minX + (Math.random() * (maxX - minX));
            if (isPointInPolygon([lng, lat], geojson)) {
                return [lng, lat];
            }
        }
        return null;
    }

    function isPointInPolygon(point, geojson) {
        let isInside = false;
        try {
            const poly = L.geoJSON(geojson);
            const layers = poly.getLayers();
            for (const layer of layers) {
                if (layer.getLatLngs && layer.getBounds().contains(L.latLng(point[1], point[0]))) {
                    const latlngsRaw = layer.getLatLngs();
                    const latlngs = Array.isArray(latlngsRaw[0]) ? latlngsRaw[0] : latlngsRaw;
                    if (!Array.isArray(latlngs) || latlngs.length === 0) continue;
                    for (let i = 0, j = latlngs.length - 1; i < latlngs.length; j = i++) {
                        const xi = latlngs[i].lng, yi = latlngs[i].lat;
                        const xj = latlngs[j].lng, yj = latlngs[j].lat;

                        const intersect = ((yi > point[1]) !== (yj > point[1]))
                            && (point[0] < (xj - xi) * (point[1] - yi) / (yj - yi) + xi);
                        if (intersect) isInside = !isInside;
                    }
                    if (isInside) return true;
                }
            }
        } catch(e) { console.warn("isPointInPolygon failed:", e); }
        return isInside;
    }

    function onPopupOpen(e) {
        const button = e.popup._contentNode.querySelector('.popup-action-btn');
        if (button) {
            button.addEventListener('click', onMintInsideClick, { once: true }); // prevent duplicate listeners
        }
    }

    function onMintInsideClick(e) {
        const areaId = e.target.dataset.areaId;
        if (!areaId) return;

        const layer = mintedLayersByAreaId.get(areaId);
        if (layer) {
            map.closePopup();
            clearSelection();
            searchBounds = layer.getBounds();
            
            selectionLayer = L.rectangle(searchBounds, { 
                color: '#00f9ff', weight: 2, opacity: 0.8, fillOpacity: 0.1, dashArray: '5, 5' 
            }).addTo(map);

            mapEl.style.cursor = 'crosshair';
            setStatus('Exploration Mode: Click inside the highlighted area to find smaller territories.', 'success');
        }
    }

    connectBtn.addEventListener('click', connectWallet);
    mintBtn.addEventListener('click', mintSelectedArea);
    clearBtn.addEventListener('click', clearSelection);
    refreshBtn.addEventListener('click', () => { 
        setStatus("Refreshing data is now automatic. Manual refresh disabled.", "error"); 
    });
    empireNameInput.addEventListener('input', updateEmpireState);
    empireColorInput.addEventListener('input', updateEmpireState);

    window.addEventListener('DOMContentLoaded', () => {
      initMap();
      initFirebase();
      // Absolute boot fallback if something blocks early
      setTimeout(() => markBootComplete('domcontent-fallback-5s'), 5000);
    });

    // As a final guarantee, hide loader when page fully loaded
    window.addEventListener('load', () => markBootComplete('window-load'));
  </script>
</body>
</html>
