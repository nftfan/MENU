<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Art NFT Mint</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#0b1022" />
  <style>
    :root {
      --bg: #0b1022;
      --bg-alt: #121a36;
      --panel: #141d3d;
      --panel-alt: #1b2549;
      --accent: #58d0ff;
      --accent-grad: linear-gradient(180deg,#58d0ff,#16a5ff);
      --text: #dde5f4;
      --muted: #8d97ad;
      --border: rgba(255,255,255,0.08);
      --border-soft: rgba(255,255,255,0.04);
      --shadow: 0 4px 18px -6px rgba(0,0,0,0.6),0 0 0 1px rgba(255,255,255,0.02);
      --font-max: 10px;
      --warn: #ff6d5e;
      --success: #12ff9b;
      font-size: 10px;
    }

    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body {
      margin: 0;
      height: 100%;
      background: radial-gradient(900px 600px at 15% 10%, #1b2549 0%, #0b1022 55%) fixed;
      color: var(--text);
      font-family: system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      -webkit-font-smoothing: antialiased;
    }
    body {
      display: flex;
      flex-direction: column;
      line-height: 1.2;
      overscroll-behavior: none;
    }

    header {
      padding: env(safe-area-inset-top) 12px 6px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }
    header h1 {
      margin: 0;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: .4px;
    }
    header .sub {
      font-size: 8px;
      color: var(--muted);
      letter-spacing: .3px;
      margin-top: 2px;
    }

    .brand { display: flex; flex-direction: column; }

    .wallet-info {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 4px;
      font-size: 8px;
    }
    .wallet-tag {
      padding: 4px 8px;
      background: rgba(88,208,255,0.12);
      border: 1px solid rgba(88,208,255,0.4);
      border-radius: 8px;
      font-size: 8px;
      font-weight: 600;
      letter-spacing: .4px;
      color: var(--accent);
      display: none;
    }
    .net-tag {
      padding: 4px 8px;
      background: rgba(255,255,255,0.06);
      border: 1px dashed var(--border);
      border-radius: 8px;
      font-size: 8px;
      letter-spacing: .4px;
    }

    main.app {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 0 10px 10px;
      max-width: 520px;
      width: 100%;
      margin: 0 auto;
    }

    .panel {
      background: linear-gradient(180deg,var(--panel) 0%,var(--panel-alt) 100%);
      border: 1px solid var(--border);
      border-radius: 10px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      position: relative;
    }

    .panel h2 {
      margin: 0;
      padding: 6px 10px;
      font-size: 9px;
      font-weight: 600;
      letter-spacing: .5px;
      background: rgba(255,255,255,0.03);
      border-bottom: 1px solid var(--border-soft);
    }

    .preview-wrap {
      position: relative;
      padding: 10px 10px 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }
    .canvas-frame {
      width: 100%;
      aspect-ratio: 1/1;
      background: #0d1329;
      border-radius: 10px;
      border: 1px solid var(--border);
      box-shadow: inset 0 1px 2px rgba(255,255,255,0.05),0 6px 20px -8px rgba(0,0,0,0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      position: relative;
    }
    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      max-width: 100%;
      max-height: 100%;
      width: 100% !important;
      height: 100% !important;
      display: block;
      border-radius: 4px;
      background: #101a38;
    }
    .hint {
      font-size: 8px;
      color: var(--muted);
      text-align: center;
      letter-spacing: .4px;
    }

    .controls {
      display: grid;
      padding: 8px 10px 46px;
      gap: 10px;
      grid-template-columns: repeat(auto-fill,minmax(90px,1fr));
      align-items: start;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }
    label {
      font-size: 8px;
      color: var(--muted);
      font-weight: 500;
      letter-spacing: .4px;
      display: flex;
      justify-content: space-between;
      gap: 4px;
      white-space: nowrap;
    }
    input[type="number"],
    input[type="text"],
    select {
      height: 26px;
      border-radius: 7px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      color: var(--text);
      font-size: 9px;
      padding: 0 7px;
      outline: none;
      letter-spacing: .3px;
      width: 100%;
    }
    input[type="text"]::placeholder { color: #5f6a82; }
    input[type="checkbox"] {
      width: 14px;
      height: 14px;
      accent-color: var(--accent);
      margin: 0;
      flex-shrink: 0;
    }
    .switch {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 8px;
      color: var(--text);
    }
    .switch + .switch { margin-top: 4px; }

    .palette-preview {
      display: flex;
      gap: 2px;
      flex-wrap: wrap;
      min-height: 14px;
      padding: 2px 0 0;
    }
    .swatch {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      border: 1px solid rgba(0,0,0,0.3);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.2);
    }

    .action-bar {
      position: fixed;
      left: 0;
      bottom: 0;
      width: 100%;
      padding: 8px 10px calc(8px + env(safe-area-inset-bottom));
      background: linear-gradient(180deg,rgba(15,22,45,0.85),rgba(10,15,30,0.95));
      backdrop-filter: blur(14px);
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      border-top: 1px solid var(--border);
      box-shadow: 0 -4px 18px -8px rgba(0,0,0,.7);
      z-index: 40;
    }
    button {
      appearance: none;
      border: 1px solid var(--border);
      background: #233058;
      color: var(--text);
      font-size: 9px;
      font-weight: 600;
      letter-spacing: .4px;
      border-radius: 8px;
      padding: 0 12px;
      height: 30px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: background .18s, transform .18s;
    }
    button:active { transform: translateY(1px); }
    button:hover { background: #2b3a6d; }
    .btn-accent {
      background: var(--accent-grad);
      color: #0a162c;
      border: none;
      font-weight: 700;
      text-shadow: 0 1px 0 rgba(255,255,255,0.3);
    }
    .btn-accent:hover { filter: brightness(1.07); }
    .btn-ghost {
      background: transparent;
      border: 1px dashed var(--border);
    }
    .btn-danger {
      background: linear-gradient(180deg,#ff627f,#ff385f);
      border: none;
      color: #fff;
    }
    .btn-success {
      background: linear-gradient(180deg,#12ff9b,#00d8a5);
      border: none;
      color: #072523;
      font-weight: 700;
    }
    button:disabled { opacity: .55; cursor: not-allowed; }

    .footer {
      margin: 4px 0 60px;
      text-align: center;
      font-size: 7px;
      color: var(--muted);
      letter-spacing: .5px;
    }

    .log {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 8px;
      padding: 6px 8px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.04);
      border-radius: 6px;
      max-height: 90px;
      overflow-y: auto;
      line-height: 1.25;
      white-space: pre-wrap;
    }

    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    input[type=number] { -moz-appearance: textfield; }

    @media (min-width: 620px) {
      .controls { grid-template-columns: repeat(auto-fill,minmax(110px,1fr)); }
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <h1>Pixel Art NFT Mint</h1>
      <div class="sub">Generate & mint pixel art on Polygon (1 POL)</div>
    </div>
    <div class="wallet-info">
      <div class="net-tag" id="netTag">Not Connected</div>
      <div class="wallet-tag" id="walletTag"></div>
    </div>
  </header>

  <main class="app">
    <section class="panel" id="previewPanel">
      <h2>PREVIEW</h2>
      <div class="preview-wrap">
        <div class="canvas-frame">
          <canvas id="canvas" width="320" height="320" aria-label="Pixel art preview"></canvas>
        </div>
        <div class="hint">Tap Mint to regenerate & mint. Press R to regenerate only.</div>
      </div>
    </section>

    <section class="panel" id="controlsPanel">
      <h2>CONTROLS</h2>
      <div class="controls">
        <div class="field">
          <label for="gridW">Width</label>
          <input id="gridW" type="number" min="2" max="256" value="32" />
        </div>
        <div class="field">
          <label for="gridH">Height</label>
          <input id="gridH" type="number" min="2" max="256" value="32" />
        </div>
        <div class="field">
          <label for="previewScale">Preview px</label>
          <input id="previewScale" type="number" min="2" max="40" value="10" />
        </div>
        <div class="field">
          <label for="exportScale">Export px</label>
          <input id="exportScale" type="number" min="1" max="150" value="16" />
        </div>

        <div class="field" style="grid-column: span 2">
          <label for="paletteSelect">Palette</label>
          <select id="paletteSelect">
            <option value="PICO-8">PICO-8</option>
            <option value="GB">Game Boy</option>
            <option value="C64">C64</option>
            <option value="Vaporwave">Vaporwave</option>
            <option value="Pastel">Pastel</option>
            <option value="Monochrome">Mono</option>
            <option value="Random">Random</option>
            <option value="Custom">Custom</option>
          </select>
          <div id="palettePreview" class="palette-preview" aria-hidden="true"></div>
        </div>

        <div class="field" id="customPaletteWrap" style="display:none;grid-column:span 2">
          <label for="customPalette">Colors (#a,#b,...)</label>
          <input id="customPalette" type="text" placeholder="#ffcc00,#2244ff,#11aa88" />
        </div>

        <div class="field">
          <label for="colorCount">Use colors</label>
          <input id="colorCount" type="number" min="2" max="16" value="8" />
        </div>
        <div class="field">
          <label for="emptyChance">Empty 0â€“1</label>
          <input id="emptyChance" type="number" step="0.05" min="0" max="1" value="0" />
        </div>

        <div class="field">
          <label>Symmetry</label>
          <div class="switch">
            <input id="symV" type="checkbox" checked />
            <label for="symV">Vertical</label>
          </div>
          <div class="switch">
            <input id="symH" type="checkbox" />
            <label for="symH">Horizontal</label>
          </div>
        </div>

        <div class="field">
          <label>Noise</label>
          <div class="switch">
            <input id="jitter" type="checkbox" />
            <label for="jitter">Cluster</label>
          </div>
          <div class="switch">
            <input id="outline" type="checkbox" />
            <label for="outline">Outline</label>
          </div>
        </div>

        <div class="field" style="grid-column: span 2">
          <label for="seed">Seed<span style="color:var(--muted)"> (blank=auto)</span></label>
          <div style="display:flex; gap:6px;">
            <input id="seed" type="text" style="flex:1" placeholder="auto" />
            <button id="rndSeed" class="btn-ghost" style="height:26px;padding:0 10px;font-size:9px;">ðŸŽ²</button>
          </div>
        </div>

        <div class="field" style="grid-column: span 2">
          <label>Mint Log</label>
          <div id="log" class="log">Ready.</div>
        </div>
      </div>
    </section>

    <div class="footer">Seeded randomness â€¢ Mint as on-chain metadata â€¢ Polygon Mainnet â€¢ 1 POL</div>
  </main>

  <nav class="action-bar">
    <button id="connectBtn" class="btn-accent">Connect</button>
    <button id="mintBtn" class="btn-success">Mint (1 POL)</button>
    <button id="btnClear" class="btn-ghost">Clear</button>
    <button id="btnDownload" class="btn-ghost">PNG</button>
  </nav>

  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <script>
    /* ===== Polygon Network Params ===== */
    const POLYGON_PARAMS = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'POL', symbol: 'POL', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com/'],
      blockExplorerUrls: ['https://polygonscan.com/']
    };

    /* ===== Contract (mintWithURI) ===== */
    const CONTRACT_ADDRESS = "0xb7d9E197905A0Fe7A59d82029eEFCBfDa631E2CC";
    const CONTRACT_ABI = [
      "function mintWithURI(string tokenURI) external payable returns (uint256)",
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"
    ];
    
    /* ===== Lighthouse.storage ===== */
    const LIGHTHOUSE_API_KEY = "77e3d8a1.f432a2cac0784531ad66cc2ea3cea538";

    /* ===== Pixel Art Generator ===== */
    const PALETTES = {
      "PICO-8": ["#000000","#1D2B53","#7E2553","#008751","#AB5236","#5F574F","#C2C3C7","#FFF1E8","#FF004D","#FFA300","#FFEC27","#00E436","#29ADFF","#83769C","#FF77A8","#FFCCAA"],
      "GB": ["#0F380F","#306230","#8BAC0F","#9BBC0F"],
      "C64": ["#000000","#FFFFFF","#68372B","#70A4B2","#6F3D86","#588D43","#352879","#B8C76F","#6F4F25","#433900","#9A6759","#444444","#6C6C6C","#9AD284","#6C5EB5","#959595"],
      "Vaporwave": ["#FF71CE","#01CDFE","#05FFA1","#B967FF","#FFFB96","#FD3E81","#00F5D4","#7B2CBF"],
      "Pastel": ["#FFADAD","#FFD6A5","#FDFFB6","#CAFFBF","#9BF6FF","#A0C4FF","#BDB2FF","#FFC6FF"],
      "Monochrome": ["#0b0e1f","#1a1f3d","#2a3466","#5166a1","#9db5ff"]
    };

    let pixels = [];
    let lastSeed = "";
    let rng = makeRNG("");

    /* ===== DOM Elements ===== */
    const els = {
      gridW: document.getElementById("gridW"),
      gridH: document.getElementById("gridH"),
      previewScale: document.getElementById("previewScale"),
      exportScale: document.getElementById("exportScale"),
      paletteSelect: document.getElementById("paletteSelect"),
      customPaletteWrap: document.getElementById("customPaletteWrap"),
      customPalette: document.getElementById("customPalette"),
      colorCount: document.getElementById("colorCount"),
      emptyChance: document.getElementById("emptyChance"),
      symV: document.getElementById("symV"),
      symH: document.getElementById("symH"),
      jitter: document.getElementById("jitter"),
      outline: document.getElementById("outline"),
      seed: document.getElementById("seed"),
      rndSeed: document.getElementById("rndSeed"),
      btnClear: document.getElementById("btnClear"),
      btnDownload: document.getElementById("btnDownload"),
      canvas: document.getElementById("canvas"),
      palettePreview: document.getElementById("palettePreview"),
      mintBtn: document.getElementById("mintBtn"),
      connectBtn: document.getElementById("connectBtn"),
      walletTag: document.getElementById("walletTag"),
      netTag: document.getElementById("netTag"),
      log: document.getElementById("log")
    };
    const ctx = els.canvas.getContext("2d");

    /* ===== Wallet State ===== */
    let provider = null;
    let signer = null;
    let userAddress = null;

    /* ===== RNG Helpers ===== */
    function xmur3(str) {
      let h = 1779033703 ^ str.length;
      for (let i=0;i<str.length;i++) {
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return function() {
        h = Math.imul(h ^ (h >>> 16), 2246822507);
        h = Math.imul(h ^ (h >>> 13), 3266489909);
        return (h ^= h >>> 16) >>> 0;
      };
    }
    function mulberry32(a) {
      return function() {
        let t = (a += 0x6D2B79F5);
        t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }
    function makeRNG(seedStr) {
      const seed = seedStr && seedStr.trim().length ? seedStr.trim() : String(Date.now());
      const seedFn = xmur3(seed);
      return { rand: mulberry32(seedFn()), seed };
    }

    /* ===== Utility ===== */
    function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }
    function choice(list) { return list[Math.floor(rng.rand() * list.length)]; }
    function logLine(msg) {
      const time = new Date().toISOString().split("T")[1].split(".")[0];
      els.log.textContent = (els.log.textContent ? els.log.textContent + "\n" : "") + `[${time}] ${msg}`;
      els.log.scrollTop = els.log.scrollHeight;
    }

    /* ===== Palette Build ===== */
    function buildPalette() {
      const sel = els.paletteSelect.value;
      let palette;
      if (sel === "Random") {
        const baseHue = Math.floor(rng.rand() * 360);
        const count = clamp(parseInt(els.colorCount.value||8,10),2,16);
        palette = Array.from({length:count},(_,i)=>{
          const h = (baseHue + i*(360/count) + Math.floor(rng.rand()*30))%360;
          const s = 50 + Math.floor(rng.rand()*40);
          const l = 45 + Math.floor(rng.rand()*20);
          return hslToHex(h,s,l);
        });
      } else if (sel === "Custom") {
        const cols = (els.customPalette.value || "")
          .split(",").map(s=>s.trim()).filter(Boolean);
        palette = cols.length ? cols : ["#000","#fff"];
      } else {
        palette = PALETTES[sel].slice();
      }
      const desired = clamp(parseInt(els.colorCount.value || palette.length,10),2,16);
      if (palette.length > desired) {
        const out = [];
        const pool = palette.slice();
        for (let i=0;i<desired && pool.length;i++) {
          const idx = Math.floor(rng.rand()*pool.length);
            out.push(pool.splice(idx,1)[0]);
        }
        palette = out;
      }
      els.palettePreview.innerHTML = "";
      palette.forEach(c=>{
        const sw=document.createElement("div");
        sw.className="swatch";
        sw.style.background=c;
        els.palettePreview.appendChild(sw);
      });
      return palette;
    }

    function hslToHex(h,s,l) {
      s/=100; l/=100;
      const k = n => (n + h/30) % 12;
      const a = s * Math.min(l,1-l);
      const f = n => l - a * Math.max(-1, Math.min(k(n)-3, Math.min(9-k(n),1)));
      const toHex = x => Math.round(255*x).toString(16).padStart(2,"0");
      return `#${toHex(f(0))}${toHex(f(8))}${toHex(f(4))}`;
    }

    function darker(hex, amt=0.25) {
      const n=parseInt(hex.slice(1),16);
      let r=(n>>16)&255,g=(n>>8)&255,b=n&255;
      r=Math.max(0,Math.round(r*(1-amt)));
      g=Math.max(0,Math.round(g*(1-amt)));
      b=Math.max(0,Math.round(b*(1-amt)));
      return "#" + ((1<<24) + (r<<16)+(g<<8)+b).toString(16).slice(1);
    }

    /* ===== Canvas Sizing ===== */
    function ensureCanvasSize() {
      const scalePix = clamp(parseInt(els.previewScale.value||10,10),2,60);
      const W = clamp(parseInt(els.gridW.value||32,10),2,256);
      const H = clamp(parseInt(els.gridH.value||32,10),2,256);
      els.canvas.width = W * scalePix;
      els.canvas.height = H * scalePix;
      ctx.imageSmoothingEnabled = false;
    }
    function clearCanvas() { ctx.clearRect(0,0,els.canvas.width,els.canvas.height); }

    /* ===== Pixel Generation ===== */
    function generatePixels() {
      const W = clamp(parseInt(els.gridW.value||32,10),2,256);
      const H = clamp(parseInt(els.gridH.value||32,10),2,256);
      const emptyChance = clamp(parseFloat(els.emptyChance.value||0),0,1);
      const symV = els.symV.checked;
      const symH = els.symH.checked;
      const jitter = els.jitter.checked;
      const outline = els.outline.checked;
      const palette = buildPalette();

      pixels = Array.from({length:H},()=>Array(W).fill(null));
      const Wmid = Math.ceil(W/2);
      const Hmid = Math.ceil(H/2);
      const minX = symV ? Wmid : W;
      const minY = symH ? Hmid : H;

      for (let y=0;y<minY;y++) {
        for (let x=0;x<minX;x++) {
          if (rng.rand() < emptyChance) {
            setSym(x,y,null);
            continue;
          }
          let color = choice(palette);
          if (jitter) {
            const left = x>0 ? pixels[y][x-1] : null;
            const up = y>0 ? pixels[y-1][x] : null;
            if (left && rng.rand()<0.55) color = left;
            if (up && rng.rand()<0.55) color = rng.rand()<0.5 ? color : up;
          }
          setSym(x,y,color);
        }
      }

      if (outline) {
        const copy = pixels.map(r=>r.slice());
        for (let y=0;y<H;y++) {
          for (let x=0;x<W;x++) {
            if (!copy[y][x]) continue;
            const neigh = [
              [x-1,y],[x+1,y],[x,y-1],[x,y+1]
            ].some(([nx,ny]) => nx<0 || nx>=W || ny<0 || ny>=H || !copy[ny][nx]);
            if (neigh) pixels[y][x] = darker(copy[y][x],0.28);
          }
        }
      }

      function setSym(x,y,val) {
        const set = (xx,yy)=>{ if (yy>=0 && yy<H && xx>=0 && xx<W) pixels[yy][xx] = val; };
        set(x,y);
        if (symV) set(W-1-x,y);
        if (symH) set(x,H-1-y);
        if (symV && symH) set(W-1-x,H-1-y);
      }
    }

    function renderPreview() {
      ensureCanvasSize();
      clearCanvas();
      if (!pixels.length) return;
      const s = clamp(parseInt(els.previewScale.value||10,10),2,60);
      const H = pixels.length;
      const W = pixels[0].length;
      const r = s / 2;
      for (let y=0;y<H;y++) {
        for (let x=0;x<W;x++) {
          const c = pixels[y][x];
            if (!c) continue;
          ctx.fillStyle = c;
          ctx.beginPath();
          ctx.arc(x*s + r, y*s + r, r, 0, Math.PI*2);
          ctx.fill();
        }
      }
    }

    function regenerate(seedOverride) {
      const seedStr = seedOverride !== undefined ? seedOverride : els.seed.value.trim();
      const { rand, seed } = makeRNG(seedStr);
      rng = { rand };
      lastSeed = seed;
      if (!seedStr) els.seed.value = seed;
      generatePixels();
      renderPreview();
      logLine("Generated art with seed " + seed);
    }
    
    function dataURLtoBlob(dataurl) {
        var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
            bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
        while(n--){
            u8arr[n] = bstr.charCodeAt(n);
        }
        return new Blob([u8arr], {type:mime});
    }

    function getPNGDataURL(scale) {
      if (!pixels.length) return null;
      const H = pixels.length;
      const W = pixels[0].length;
      const s = clamp(scale,1,300);
      const off = document.createElement("canvas");
      off.width = W * s;
      off.height = H * s;
      const ox = off.getContext("2d");
      ox.imageSmoothingEnabled = false;
      const r = s / 2;
      for (let y=0;y<H;y++) {
        for (let x=0;x<W;x++) {
          const c = pixels[y][x];
          if (!c) continue;
          ox.fillStyle = c;
          ox.beginPath();
          ox.arc(x*s + r, y*s + r, r, 0, Math.PI*2);
          ox.fill();
        }
      }
      return off.toDataURL("image/png");
    }

    function downloadPNG() {
      const scale = parseInt(els.exportScale.value||16,10);
      const dataURL = getPNGDataURL(scale);
      if (!dataURL) return;
      const W = pixels[0].length;
      const H = pixels.length;
      const a = document.createElement("a");
      a.download = `pixel-art_${W}x${H}_${scale}x_${lastSeed}.png`;
      a.href = dataURL;
      document.body.appendChild(a);
      a.click();
      a.remove();
      logLine("Downloaded PNG.");
    }

    /* ===== Wallet Functions ===== */
    function shortAddr(a) { return a ? `${a.slice(0,6)}...${a.slice(-4)}` : ''; }

    async function switchToPolygon() {
      if (!window.ethereum) return false;
      try {
        await window.ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: POLYGON_PARAMS.chainId }]
        });
        return true;
      } catch (e) {
        if (e.code === 4902) {
          await window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [POLYGON_PARAMS]
          });
          return true;
        }
        return false;
      }
    }

    async function connectWallet() {
      if (!window.ethereum) {
        alert("Install MetaMask to continue.");
        return;
      }
      logLine("Connecting wallet...");
      const ok = await switchToPolygon();
      if (!ok) {
        alert("Switch to Polygon Mainnet.");
        logLine("Network switch failed.");
        return;
      }
      provider = new ethers.providers.Web3Provider(window.ethereum);
      await provider.send('eth_requestAccounts', []);
      signer = provider.getSigner();
      userAddress = await signer.getAddress();
      els.connectBtn.disabled = true;
      els.connectBtn.textContent = "Connected";
      els.walletTag.style.display = "inline-block";
      els.walletTag.textContent = shortAddr(userAddress);
      els.netTag.textContent = "Polygon Mainnet";
      logLine("Wallet connected: " + userAddress);
    }
    
    async function uploadToIPFS(imageDataURL) {
      try {
        // 1. Upload Image
        logLine("Uploading image to Lighthouse...");
        const imageBlob = dataURLtoBlob(imageDataURL);
        const imageFormData = new FormData();
        imageFormData.append('file', imageBlob, 'pixel-art.png');
        
        const imageUploadResponse = await fetch("https://node.lighthouse.storage/api/v0/add", {
            method: 'POST',
            headers: { Authorization: `Bearer ${LIGHTHOUSE_API_KEY}` },
            body: imageFormData
        });
        if (!imageUploadResponse.ok) throw new Error("Image upload failed: " + await imageUploadResponse.text());
        const imageUploadResult = await imageUploadResponse.json();
        if (!imageUploadResult.Hash) throw new Error("Image upload failed: Invalid response");
        
        const imageCID = imageUploadResult.Hash;
        const imageURI = `ipfs://${imageCID}`;
        logLine("Image uploaded. CID: " + imageCID);

        // 2. Build and Upload Metadata
        logLine("Uploading metadata to Lighthouse...");
        const attrs = [
            { trait_type: "Width", value: parseInt(els.gridW.value,10) },
            { trait_type: "Height", value: parseInt(els.gridH.value,10) },
            { trait_type: "Seed", value: lastSeed },
            { trait_type: "Palette Mode", value: els.paletteSelect.value },
            { trait_type: "Colors Used", value: parseInt(els.colorCount.value,10) },
            { trait_type: "Vertical Symmetry", value: els.symV.checked ? "Yes" : "No" },
            { trait_type: "Horizontal Symmetry", value: els.symH.checked ? "Yes" : "No" },
            { trait_type: "Outline", value: els.outline.checked ? "Yes" : "No" },
            { trait_type: "Cluster Jitter", value: els.jitter.checked ? "Yes" : "No" }
        ];

        const metadata = {
            name: "OnChain Pixel Art #" + lastSeed,
            description: "Procedurally generated pixel art minted on Polygon. Seed ensures reproducibility.",
            image: imageURI,
            attributes: attrs
        };
        
        const metadataBlob = new Blob([JSON.stringify(metadata)], { type: "application/json" });
        const metadataFormData = new FormData();
        metadataFormData.append('file', metadataBlob, 'metadata.json');

        const metadataUploadResponse = await fetch("https://node.lighthouse.storage/api/v0/add", {
            method: 'POST',
            headers: { Authorization: `Bearer ${LIGHTHOUSE_API_KEY}` },
            body: metadataFormData
        });
        if (!metadataUploadResponse.ok) throw new Error("Metadata upload failed: " + await metadataUploadResponse.text());
        const metadataUploadResult = await metadataUploadResponse.json();
        if (!metadataUploadResult.Hash) throw new Error("Metadata upload failed: Invalid response");
        
        const metadataCID = metadataUploadResult.Hash;
        logLine("Metadata uploaded. CID: " + metadataCID);
        
        return metadataCID;

      } catch (e) {
          console.error(e);
          logLine("IPFS upload error: " + e.message);
          throw e;
      }
    }


    async function mint() {
      if (!signer) {
        await connectWallet();
        if (!signer) return;
      }
      
      els.mintBtn.disabled = true;
      els.mintBtn.textContent = "Minting...";

      try {
        regenerate();
        const scale = parseInt(els.exportScale.value||16,10);
        const pngDataURL = getPNGDataURL(scale);
        if (!pngDataURL) {
          throw new Error("Nothing to mint. Generate first.");
        }

        const metadataCID = await uploadToIPFS(pngDataURL);
        const tokenURI = "ipfs://" + metadataCID;
        
        logLine("Preparing mint transaction...");
        
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        const price = ethers.utils.parseEther("1");
        const tx = await contract.mintWithURI(tokenURI, { value: price });
        
        logLine("Tx sent: " + tx.hash);
        const receipt = await tx.wait();
        logLine("Confirmed. Block " + receipt.blockNumber);
        
        const ev = receipt.events?.find(e => e.event === 'Transfer');
        const tokenId = ev?.args?.tokenId ? ev.args.tokenId.toString() : "?";
        alert("Mint success! Token ID: " + tokenId);
      
      } catch (e) {
        console.error(e);
        const reason = e?.error?.message || e?.data?.message || e?.reason || e?.message || "Mint failed";
        logLine("Error: " + reason);
        alert(reason);
      } finally {
        els.mintBtn.disabled = false;
        els.mintBtn.textContent = "Mint (1 POL)";
      }
    }

    /* ===== Events ===== */
    els.mintBtn.addEventListener("click", mint);
    els.connectBtn.addEventListener("click", connectWallet);
    els.btnClear.addEventListener("click", () => {
      pixels = [];
      ensureCanvasSize();
      clearCanvas();
      logLine("Cleared canvas.");
    });
    els.btnDownload.addEventListener("click", downloadPNG);
    els.rndSeed.addEventListener("click", () => {
      els.seed.value = "";
      regenerate();
    });

    [
      "previewScale","gridW","gridH","colorCount","emptyChance",
      "symV","symH","jitter","outline","seed"
    ].forEach(id => els[id].addEventListener("change", regenerate));

    els.paletteSelect.addEventListener("change", () => {
      const v = els.paletteSelect.value;
      els.customPaletteWrap.style.display = v === "Custom" ? "" : "none";
      regenerate();
    });
    els.customPalette.addEventListener("input", regenerate);

    window.addEventListener("keydown", e => {
      if (e.key.toLowerCase() === "r") {
        regenerate();
      }
    });

    if (window.ethereum) {
      window.ethereum.on?.('accountsChanged', () => window.location.reload());
      window.ethereum.on?.('chainChanged', () => window.location.reload());
    }

    window.addEventListener("resize", () => renderPreview(), { passive: true });

    /* ===== Init ===== */
    (function init() {
      ensureCanvasSize();
      regenerate();
      logLine("Ready.");
    })();
  </script>
</body>
</html>
