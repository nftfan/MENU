<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
	<!-- Open Graph Meta Tags -->
<meta property="og:title" content="Coin.Fun - Trade Coins as NFTs">
<meta property="og:description" content="The fun way to collect and trade coins as NFTs. Powered by NFTFans Token on Polygon Matic. Start your NFT journey today!">
<meta property="og:image" content="https://i.imgur.com/AKKhfAe.png">
<meta property="og:url" content="https://www.nftfanstoken.com/coinfun/">
<meta property="og:type" content="website">

<!-- Twitter Meta Tags -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="Coin.Fun - Trade Coins as NFTs">
<meta name="twitter:description" content="Collect, trade, and earn with Coin.Fun â€” the NFT coin marketplace powered by NFTFans Token on Polygon. Explore now!">
<meta name="twitter:image" content="https://i.imgur.com/AKKhfAe.png">
<meta name="twitter:url" content="https://www.nftfanstoken.com/coinfun/">

  <title>Coin.Fun</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }
        
        html, body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            background: linear-gradient(145deg, #0a0f1c 0%, #111827 100%);
            color: #fff;
            min-height: 100vh;
            font-size: 10px;
            line-height: 1.4;
        }

        .banner-top {
   width: 100vw;
   max-width: 100%;
   display: flex;
   justify-content: center;
   align-items: center;
   background: linear-gradient(135deg, #0a0a0f 0%, #0d1220 50%, #1a1a2e 100%);
   border-bottom: 1px solid rgba(0, 255, 255, 0.3);
   padding: 0;
   margin: 0;
   position: relative;
   overflow: hidden;
   animation: bannerPulse 4s ease-in-out infinite;
}

@keyframes bannerPulse {
   0%, 100% { 
       background: linear-gradient(135deg, #0a0a0f 0%, #0d1220 50%, #1a1a2e 100%);
   }
   50% { 
       background: linear-gradient(135deg, #0f0f1a 0%, #121829 50%, #1e1e33 100%);
   }
}

.banner-top::before {
   content: '';
   position: absolute;
   top: 0;
   left: 0;
   right: 0;
   bottom: 0;
   background: 
       radial-gradient(circle at 25% 25%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
       radial-gradient(circle at 75% 75%, rgba(255, 0, 255, 0.08) 0%, transparent 50%),
       linear-gradient(45deg, transparent 30%, rgba(0, 255, 255, 0.05) 50%, transparent 70%);
   pointer-events: none;
   animation: backgroundShimmer 6s ease-in-out infinite;
}

@keyframes backgroundShimmer {
   0%, 100% { opacity: 0.7; }
   50% { opacity: 1; }
}

.banner-top::after {
   content: '';
   position: absolute;
   top: -2px;
   left: -100%;
   right: -100%;
   bottom: -2px;
   background: linear-gradient(90deg, 
       transparent,
       #00ffff 20%,
       #ff00ff 40%, 
       #00ff00 60%,
       #ffff00 80%,
       transparent
   );
   animation: topBorderScan 4s linear infinite;
   z-index: 1;
}

@keyframes topBorderScan {
   0% { left: -100%; }
   100% { left: 100%; }
}

.banner-top img {
   width: 100%;
   max-width: 480px;
   object-fit: cover;
   display: block;
   margin: 0 auto;
   border-radius: 0 0 100px 2px;
   position: relative;
   z-index: 2;
   filter: brightness(1.1) contrast(1.1) saturate(1.2);
   transition: all 0.4s ease;
   box-shadow: 
       0 8px 32px rgba(0, 0, 0, 0.4),
       0 4px 16px rgba(0, 255, 255, 0.1);
}

.banner-top img::before {
   content: '';
   position: absolute;
   top: -2px;
   left: -2px;
   right: -2px;
   bottom: -2px;
   background: conic-gradient(
       from 0deg,
       #00ffff,
       #ff00ff,
       #00ff00,
       #ffff00,
       #ff0080,
       #00ffff
   );
   border-radius: 0 0 22px 22px;
   z-index: -1;
   animation: hueBorderRotate 3s linear infinite;
}

@keyframes hueBorderRotate {
   0% { transform: rotate(0deg); }
   100% { transform: rotate(360deg); }
}

.wrapper {
   max-width: 480px;
   margin: 0 auto;
   padding: 12px 0 40px 0;
   position: relative;
   background: linear-gradient(180deg, 
       rgba(0, 255, 255, 0.02) 0%, 
       transparent 50%, 
       rgba(255, 0, 255, 0.02) 100%
   );
   border-radius: 0 0 24px 24px;
   overflow: hidden;
}

.wrapper::before {
   content: '';
   position: absolute;
   top: 0;
   left: 0;
   right: 0;
   bottom: 0;
   background: 
       radial-gradient(circle at 50% 0%, rgba(0, 255, 255, 0.05) 0%, transparent 60%);
   pointer-events: none;
   animation: wrapperGlow 5s ease-in-out infinite;
}

@keyframes wrapperGlow {
   0%, 100% { opacity: 0.5; }
   50% { opacity: 1; }
}

.wrapper::after {
   content: '';
   position: absolute;
   bottom: 0;
   left: 0;
   right: 0;
   height: 2px;
   background: linear-gradient(90deg, 
       transparent,
       #00ffff 25%,
       #ff00ff 50%,
       #00ffff 75%,
       transparent
   );
   animation: bottomGlow 3s ease-in-out infinite;
}

@keyframes bottomGlow {
   0%, 100% { opacity: 0.3; }
   50% { opacity: 1; }
}

/* Image container with animated border */
.image-container {
   position: relative;
   display: inline-block;
   border-radius: 0 0 20px 20px;
   overflow: hidden;
}

.image-container::before {
   content: '';
   position: absolute;
   top: -4px;
   left: -4px;
   right: -4px;
   bottom: -4px;
   background: conic-gradient(
       from 0deg,
       #00ffff 0deg,
       #0080ff 60deg,
       #8000ff 120deg,
       #ff0080 180deg,
       #ff8000 240deg,
       #80ff00 300deg,
       #00ffff 360deg
   );
   border-radius: 0 0 24px 24px;
   z-index: -1;
   animation: hueBorderSpin 4s linear infinite;
}

@keyframes hueBorderSpin {
   0% { transform: rotate(0deg); }
   100% { transform: rotate(360deg); }
}

.image-container::after {
   content: '';
   position: absolute;
   top: -2px;
   left: -2px;
   right: -2px;
   bottom: -2px;
   background: conic-gradient(
       from 180deg,
       transparent 0deg,
       #00ffff 90deg,
       transparent 180deg,
       #ff00ff 270deg,
       transparent 360deg
   );
   border-radius: 0 0 22px 22px;
   z-index: -1;
   animation: hueBorderSpin 2s linear infinite reverse;
   opacity: 0.7;
}

/* Hover effects */
.banner-top:hover img {
   transform: scale(1.02);
   filter: brightness(1.2) contrast(1.2) saturate(1.3);
   box-shadow: 
       0 12px 48px rgba(0, 0, 0, 0.5),
       0 6px 24px rgba(0, 255, 255, 0.2);
}

/* Responsive design */
@media (max-width: 768px) {
   .wrapper {
       padding: 8px 0 32px 0;
   }
   
   .banner-top img {
       border-radius: 0 0 100px 2px;
   }
   
   .image-container::before,
   .image-container::after {
       border-radius: 0 0 100px 2px;
   }
}

       /* Enhanced Web3 Header */
.header {
   background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
   padding: 20px 32px;
   font-weight: 600;
   font-size: 14px;
   border-bottom: 1px solid rgba(0, 255, 255, 0.2);
   letter-spacing: 0.8px;
   color: #e2e8f0;
   display: flex;
   align-items: center;
   justify-content: space-between;
   position: relative;
   box-shadow: 
       0 8px 32px rgba(0, 255, 255, 0.1),
       0 4px 20px rgba(138, 43, 226, 0.1),
       inset 0 1px 0 rgba(255, 255, 255, 0.1);
   backdrop-filter: blur(20px);
   overflow: hidden;
   animation: headerPulse 4s ease-in-out infinite;
}

@keyframes headerPulse {
   0%, 100% { box-shadow: 0 8px 32px rgba(0, 255, 255, 0.1), 0 4px 20px rgba(138, 43, 226, 0.1); }
   50% { box-shadow: 0 12px 40px rgba(0, 255, 255, 0.2), 0 6px 30px rgba(138, 43, 226, 0.2); }
}

.header::before {
   content: '';
   position: absolute;
   top: 0;
   left: -100%;
   right: 0;
   height: 2px;
   background: linear-gradient(90deg, 
       transparent, 
       #00ffff 20%, 
       #ff00ff 40%, 
       #00ff00 60%, 
       #ffff00 80%, 
       transparent
   );
   animation: borderScan 3s linear infinite;
}

@keyframes borderScan {
   0% { left: -100%; }
   100% { left: 100%; }
}

.header::after {
   content: '';
   position: absolute;
   top: 0;
   left: 0;
   right: 0;
   bottom: 0;
   background: 
       radial-gradient(circle at 20% 50%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
       radial-gradient(circle at 80% 50%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
       radial-gradient(circle at 50% 100%, rgba(138, 43, 226, 0.05) 0%, transparent 70%);
   pointer-events: none;
   animation: backgroundShift 6s ease-in-out infinite;
}

@keyframes backgroundShift {
   0%, 100% { opacity: 0.5; }
   50% { opacity: 1; }
}

.header-left {
   display: flex;
   align-items: center;
   gap: 16px;
   z-index: 2;
   position: relative;
}

.header .material-icons {
   font-size: 26px;
   background: linear-gradient(135deg, #00ffff, #ff00ff, #00ff00);
   -webkit-background-clip: text;
   -webkit-text-fill-color: transparent;
   background-clip: text;
   vertical-align: middle;
   filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.6));
   animation: iconGlow 2s ease-in-out infinite alternate;
   cursor: pointer;
   transition: all 0.3s ease;
}

.header .material-icons:hover {
   transform: scale(1.2) rotate(10deg);
   filter: drop-shadow(0 0 25px rgba(0, 255, 255, 0.8));
}

@keyframes iconGlow {
   0% { filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.6)); }
   100% { filter: drop-shadow(0 0 25px rgba(255, 0, 255, 0.8)); }
}

.header-title {
   font-size: 18px;
   font-weight: 800;
   background: linear-gradient(135deg, 
       #00ffff 0%, 
       #ff00ff 25%, 
       #00ff00 50%, 
       #ffff00 75%, 
       #ff0080 100%
   );
   background-size: 300% 300%;
   -webkit-background-clip: text;
   -webkit-text-fill-color: transparent;
   background-clip: text;
   animation: titleShimmer 3s ease-in-out infinite;
   text-transform: uppercase;
   letter-spacing: 2px;
   position: relative;
}

.header-title::after {
   content: '';
   position: absolute;
   bottom: -2px;
   left: 0;
   width: 100%;
   height: 2px;
   background: linear-gradient(90deg, transparent, #00ffff, transparent);
   animation: underlineGlow 2s ease-in-out infinite;
}

@keyframes titleShimmer {
   0%, 100% { background-position: 0% 50%; }
   50% { background-position: 100% 50%; }
}

@keyframes underlineGlow {
   0%, 100% { opacity: 0.3; transform: scaleX(0.5); }
   50% { opacity: 1; transform: scaleX(1); }
}

/* Floating particles effect */
.header-particles {
   position: absolute;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   pointer-events: none;
   overflow: hidden;
}

.particle {
   position: absolute;
   width: 2px;
   height: 2px;
   background: #00ffff;
   border-radius: 50%;
   opacity: 0;
   animation: floatParticle 8s linear infinite;
}

.particle:nth-child(2) { animation-delay: -2s; background: #ff00ff; }
.particle:nth-child(3) { animation-delay: -4s; background: #00ff00; }
.particle:nth-child(4) { animation-delay: -6s; background: #ffff00; }

@keyframes floatParticle {
   0% {
       transform: translateY(100%) translateX(0) scale(0);
       opacity: 0;
   }
   10% {
       opacity: 1;
       transform: translateY(90%) translateX(10px) scale(1);
   }
   90% {
       opacity: 1;
       transform: translateY(10%) translateX(-10px) scale(1);
   }
   100% {
       transform: translateY(0%) translateX(0) scale(0);
       opacity: 0;
   }
}

/* Hover effects for the entire header */
.header:hover {
   transform: translateY(-2px);
   box-shadow: 
       0 16px 48px rgba(0, 255, 255, 0.2),
       0 8px 32px rgba(138, 43, 226, 0.2),
       inset 0 1px 0 rgba(255, 255, 255, 0.2);
   transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
}

/* Responsive design */
@media (max-width: 768px) {
   .header {
       padding: 16px 20px;
   }
   
   .header-title {
       font-size: 16px;
       letter-spacing: 1px;
   }
   
   .header .material-icons {
       font-size: 22px;
   }
}

        /* Animated Wallet Button */
        .wallet-container {
            position: relative;
        }

        .connect-btn {
            padding: 10px 18px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            color: #e2e8f0;
            font-size: 12px;
            min-width: 120px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            max-width: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            z-index: 2;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Animated Rainbow Border */
        .connect-btn::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, 
                #ff0000, #ff7300, #fffb00, #48ff00, 
                #00ffd5, #002bff, #7a00ff, #ff00c8, #ff0000);
            background-size: 400% 400%;
            border-radius: 14px;
            z-index: -1;
            animation: rainbow 3s ease-in-out infinite;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .connect-btn:hover::before {
            opacity: 1;
        }

        /* Subtle Inner Glow Effect */
        .connect-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s ease;
            z-index: 1;
        }
        
        .connect-btn:hover::after {
            left: 100%;
        }
        
        .connect-btn .material-icons {
            font-size: 16px;
            color: #60a5fa;
            text-shadow: 0 0 8px rgba(96, 165, 250, 0.3);
        }
        
        .connect-btn:hover, .connect-btn:focus {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            color: #ffffff;
            outline: none;
            transform: translateY(-1px) scale(1.02);
            box-shadow: 0 12px 32px rgba(59, 130, 246, 0.25);
        }

        .connect-btn:active {
            transform: translateY(0) scale(0.98);
        }

        /* Rainbow Animation */
        @keyframes rainbow {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        /* Amazing Web3 Notification Bar */
.status-bar {
   padding: 16px 20px;
   background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
   border-radius: 16px;
   margin: 16px 12px 20px 12px;
   font-size: 12px;
   min-height: 28px;
   text-align: left;
   font-weight: 600;
   border: 1px solid rgba(0, 255, 255, 0.2);
   letter-spacing: 0.5px;
   box-shadow: 
       0 8px 32px rgba(0, 0, 0, 0.3),
       0 4px 16px rgba(0, 255, 255, 0.1),
       inset 0 1px 0 rgba(255, 255, 255, 0.1);
   word-break: break-word;
   display: flex;
   align-items: center;
   gap: 12px;
   transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
   position: relative;
   overflow: hidden;
   backdrop-filter: blur(20px);
   animation: statusPulse 3s ease-in-out infinite;
}

@keyframes statusPulse {
   0%, 100% { 
       box-shadow: 
           0 8px 32px rgba(0, 0, 0, 0.3),
           0 4px 16px rgba(0, 255, 255, 0.1);
   }
   50% { 
       box-shadow: 
           0 12px 40px rgba(0, 0, 0, 0.4),
           0 6px 24px rgba(0, 255, 255, 0.2);
   }
}

.status-bar::before {
   content: '';
   position: absolute;
   top: 0;
   left: 0;
   width: 6px;
   height: 100%;
   background: linear-gradient(180deg, currentColor, transparent, currentColor);
   opacity: 0.8;
   animation: leftBorderGlow 2s ease-in-out infinite alternate;
}

@keyframes leftBorderGlow {
   0% { opacity: 0.5; filter: blur(0px); }
   100% { opacity: 1; filter: blur(1px); }
}

.status-bar::after {
   content: '';
   position: absolute;
   top: -50%;
   right: -50%;
   bottom: -50%;
   left: -50%;
   background: conic-gradient(from 0deg, transparent, currentColor, transparent);
   opacity: 0.1;
   animation: backgroundRotate 6s linear infinite;
   pointer-events: none;
}

@keyframes backgroundRotate {
   0% { transform: rotate(0deg); }
   100% { transform: rotate(360deg); }
}

.status-bar .material-icons {
   font-size: 20px;
   vertical-align: middle;
   padding-right: 4px;
   transition: all 0.3s ease;
   filter: drop-shadow(0 0 12px currentColor);
   animation: iconFloat 3s ease-in-out infinite;
   z-index: 2;
   position: relative;
}

@keyframes iconFloat {
   0%, 100% { transform: translateY(0px) scale(1); }
   50% { transform: translateY(-3px) scale(1.1); }
}

.status-bar:hover {
   transform: translateY(-4px) scale(1.02);
   box-shadow: 
       0 16px 48px rgba(0, 0, 0, 0.4),
       0 8px 24px rgba(0, 255, 255, 0.2),
       inset 0 2px 0 rgba(255, 255, 255, 0.2);
}

.status-bar:hover .material-icons {
   transform: scale(1.3) rotate(15deg);
   filter: drop-shadow(0 0 20px currentColor);
}

/* Enhanced status types with Web3 aesthetics */
.status-info { 
   background: linear-gradient(135deg, #0f1419 0%, #1e3a8a 50%, #312e81 100%); 
   color: #00d4ff; 
   border-color: rgba(0, 212, 255, 0.4);
   box-shadow: 
       0 8px 32px rgba(0, 0, 0, 0.3),
       0 4px 16px rgba(0, 212, 255, 0.15),
       inset 0 1px 0 rgba(0, 212, 255, 0.2);
}

.status-success { 
   background: linear-gradient(135deg, #0a1f0a 0%, #064e3b 50%, #14532d 100%); 
   color: #00ff88; 
   border-color: rgba(0, 255, 136, 0.4);
   box-shadow: 
       0 8px 32px rgba(0, 0, 0, 0.3),
       0 4px 16px rgba(0, 255, 136, 0.15),
       inset 0 1px 0 rgba(0, 255, 136, 0.2);
}

.status-error { 
   background: linear-gradient(135deg, #1f0a0a 0%, #7f1d1d 50%, #991b1b 100%); 
   color: #ff0066; 
   border-color: rgba(255, 0, 102, 0.4);
   box-shadow: 
       0 8px 32px rgba(0, 0, 0, 0.3),
       0 4px 16px rgba(255, 0, 102, 0.15),
       inset 0 1px 0 rgba(255, 0, 102, 0.2);
}

.status-warn { 
   background: linear-gradient(135deg, #1f1a0a 0%, #92400e 50%, #b45309 100%); 
   color: #ffaa00; 
   border-color: rgba(255, 170, 0, 0.4);
   box-shadow: 
       0 8px 32px rgba(0, 0, 0, 0.3),
       0 4px 16px rgba(255, 170, 0, 0.15),
       inset 0 1px 0 rgba(255, 170, 0, 0.2);
}

/* Enhanced icon colors with glow effects */
.status-bar.status-success .material-icons { 
   color: #00ff88; 
   filter: drop-shadow(0 0 15px #00ff88);
}

.status-bar.status-error .material-icons { 
   color: #ff0066; 
   filter: drop-shadow(0 0 15px #ff0066);
}

.status-bar.status-warn .material-icons { 
   color: #ffaa00; 
   filter: drop-shadow(0 0 15px #ffaa00);
}

.status-bar.status-info .material-icons { 
   color: #00d4ff; 
   filter: drop-shadow(0 0 15px #00d4ff);
}

/* Particle effects for status bars */
.status-bar-particles {
   position: absolute;
   top: 0;
   left: 0;
   width: 100%;
   height: 100%;
   pointer-events: none;
   overflow: hidden;
   z-index: 1;
}

.status-particle {
   position: absolute;
   width: 1px;
   height: 1px;
   background: currentColor;
   border-radius: 50%;
   opacity: 0;
   animation: statusParticleFloat 4s linear infinite;
}

.status-particle:nth-child(2) { animation-delay: -1s; }
.status-particle:nth-child(3) { animation-delay: -2s; }
.status-particle:nth-child(4) { animation-delay: -3s; }

@keyframes statusParticleFloat {
   0% {
       transform: translateX(0) translateY(0) scale(0);
       opacity: 0;
   }
   20% {
       opacity: 1;
       transform: translateX(20px) translateY(-5px) scale(1);
   }
   80% {
       opacity: 1;
       transform: translateX(80px) translateY(-10px) scale(1);
   }
   100% {
       transform: translateX(100px) translateY(-15px) scale(0);
       opacity: 0;
   }
}

/* Responsive design */
@media (max-width: 768px) {
   .status-bar {
       padding: 12px 16px;
       margin: 12px 8px 16px 8px;
       font-size: 11px;
       gap: 8px;
   }
   
   .status-bar .material-icons {
       font-size: 18px;
   }
}

/* Text content styling */
.status-bar-text {
   flex: 1;
   z-index: 2;
   position: relative;
   text-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
}

        /* Enhanced Tab Bar */
        .tab-bar {
            display: flex;
            gap: 6px;
            margin: 0 8px 12px 8px;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border-radius: 12px;
            overflow: hidden;
            padding: 4px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
        }
        
        .tab-btn {
            flex: 1;
            padding: 10px 8px;
            background: transparent;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            color: #94a3b8;
            font-size: 9px;
            letter-spacing: 0.02em;
            transition: all 0.3s ease;
            outline: none;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            position: relative;
        }
        
        .tab-btn .material-icons {
            font-size: 14px;
            margin-bottom: 1px;
            transition: all 0.3s ease;
        }
        
        .tab-btn.active {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: #fff;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
            transform: translateY(-1px);
        }
        
        .tab-btn:hover:not(.active) {
            background: rgba(59, 130, 246, 0.1);
            color: #e2e8f0;
            transform: translateY(-1px);
        }

        /* NFT List Enhancements */
        .nft-list {
            list-style: none;
            padding: 0;
            margin: 12px 0 0 0;
        }
        
        .nft-post {
            display: flex;
            align-items: stretch;
            justify-content: space-between;
            padding: 14px 0;
            background: transparent;
            position: relative;
            font-size: 10px;
            gap: 16px;
            border: none;
            transition: all 0.3s ease;
        }
        
        .nft-post:hover {
            background: rgba(59, 130, 246, 0.02);
            transform: translateX(2px);
        }
        
        .nft-post:not(:last-child)::after {
            content: "";
            display: block;
            position: absolute;
            left: 60px;
            right: 8px;
            bottom: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(59, 130, 246, 0.2), transparent);
            opacity: 1;
            z-index: 1;
        }

        .nft-post-left {
            display: flex;
            align-items: center;
            gap: 14px;
            flex: 1;
            min-width: 0;
        }

        .serial-number {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 42px;
            min-width: 24px;
            font-size: 12px;
            color: #64748b;
            font-family: inherit;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-align: center;
            margin-right: 0;
            
            
        }

        .nft-avatar {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            background-color: #fff;
            object-fit: cover;
            border: 2px solid rgba(59, 130, 246, 0.2);
            flex-shrink: 0;
            display: block;
            
            transition: all 0.3s ease;
        }
        
        .nft-avatar:hover {
            transform: scale(1.05);
            border-color: rgba(59, 130, 246, 0.4);
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.15);
        }

        .nft-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .nft-title {
            font-weight: 700;
            font-size: 11px;
            color: #e2e8f0;
            line-height: 1.3;
            margin-bottom: 2px;
            white-space: normal;
            word-break: break-word;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nft-supply {
            color: #64748b;
            font-size: 9px;
            font-weight: 500;
            margin-left: 6px;
        }

        .nft-description {
            font-size: 9px;
            color: #94a3b8;
            margin-top: 2px;
            max-width: 240px;
            white-space: normal;
            word-break: break-word;
            line-height: 1.4;
        }

        .nft-actions {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            margin-left: 12px;
            min-width: 100px;
            justify-content: center;
        }

        /* Enhanced Status Labels */
        .nft-status-label {
            
            align-items: center;
            gap: 4px;
            font-size: 8px;
            font-weight: 700;
            padding: 4px 8px;
            margin-left: 8px;
            margin-top: 2px;
            
            
            color: #d1fae5;
           
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
       

        .price-tab {
            background: linear-gradient(135deg, #1e40af 0%, #1d4ed8 100%);
            color: #dbeafe;
            font-size: 10px;
            font-weight: 700;
            border-radius: 16px;
            padding: 8px 12px;
            border: 1px solid rgba(59, 130, 246, 0.3);
            margin: 0;
            min-width: 80px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(30, 64, 175, 0.2);
            display: flex;
            align-items: center;
            gap: 4px;
            letter-spacing: 0.2px;
            transition: all 0.3s ease;
        }
        
        .price-tab:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 24px rgba(30, 64, 175, 0.3);
        }
        
        .price-tab .material-icons {
            font-size: 14px;
            color: #93c5fd;
            margin-right: 2px;
        }

        /* Enhanced Buttons */
        .buy-btn, .sell-btn, .delist-btn {
            font-size: 10px;
            padding: 8px 16px;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            letter-spacing: 0.1px;
            display: flex;
            align-items: center;
            gap: 5px;
            position: relative;
            overflow: hidden;
        }
        
        .buy-btn {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }
        
        .sell-btn {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
        }
        
        .delist-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }
        
        .buy-btn .material-icons, 
        .sell-btn .material-icons, 
        .delist-btn .material-icons {
            font-size: 14px;
            margin-bottom: 1px;
        }
        
        .buy-btn:disabled, 
        .sell-btn:disabled, 
        .delist-btn:disabled {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%);
            color: #6b7280;
            cursor: not-allowed;
        }
        
        .buy-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(16, 185, 129, 0.3);
        }
        
        .sell-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.3);
        }
        
        .delist-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(239, 68, 68, 0.3);
        }

        .sold-out {
            font-size: 10px;
            color: #f87171;
            font-weight: 700;
            margin-left: 0;
            display: flex;
            align-items: center;
            gap: 4px;
            background: linear-gradient(135deg, #7f1d1d 0%, #991b1b 100%);
            padding: 6px 10px;
            border-radius: 12px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        .sold-out .material-icons {
            font-size: 14px;
            color: #ef4444;
        }

        /* Mobile Responsiveness */
        @media (max-width: 600px) {
            .wrapper { 
                max-width: 100vw; 
                padding: 0; 
            }
            .nft-avatar { 
                width: 32px; 
                height: 32px; 
                border-radius: 50%;
            }
            .serial-number { 
                height: 32px; 
                min-width: 16px; 
                font-size: 10px;
            }
            .nft-title { 
                font-size: 10px; 
            }
            .buy-btn, .sell-btn, .delist-btn { 
                font-size: 9px; 
                padding: 6px 12px; 
            }
            .nft-description { 
                font-size: 8px; 
                max-width: 120px; 
            }
            .nft-post { 
                padding: 10px 0; 
            }
            .price-tab { 
                font-size: 9px; 
                padding: 6px 10px; 
                min-width: 60px;
            }
            .nft-actions { 
                gap: 6px; 
                margin-left: 8px;
                min-width: 80px;
            }
            .nft-post:not(:last-child)::after { 
                left: 50px; 
            }
            .banner-top img { 
                max-width: 100vw; 
                border-radius: 0 0 12px 12px;
            }
            .status-bar {
                margin: 10px 6px 12px 6px;
                padding: 10px 12px;
                font-size: 10px;
				z-index: 9999;
            }
            .tab-bar {
                margin: 0 6px 10px 6px;
            }
            .header {
                font-size: 12px;
                padding: 10px 6px;
            }
            .top-bar {
                padding: 8px 6px 4px 6px;
            }
        }

        /* Enhanced Modal */
        #sellModal {
            display: none;
            position: fixed;
            z-index: 999;
            left: 0; 
            top: 0;
            width: 100vw; 
            height: 100vh;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(8px);
            justify-content: center;
            align-items: center;
        }
        
        #sellModalContent {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            padding: 20px 16px 16px 16px;
            border-radius: 16px;
            box-shadow: 0 20px 64px rgba(0, 0, 0, 0.3);
            min-width: 240px;
            max-width: 96vw;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            font-size: 10px;
            color: #fff;
            border: 1px solid rgba(59, 130, 246, 0.3);
            gap: 10px;
            position: relative;
        }
        
        #sellModalContent h3 {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            margin: 0 0 10px 0;
            color: #e2e8f0;
            font-weight: 700;
        }
        
        #sellModalContent input {
            margin: 4px 0 8px 0;
            padding: 8px 10px;
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 8px;
            width: 97%;
            font-size: 16px;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #fff;
            outline: none;
            transition: all 0.3s ease;
        }
        
        #sellModalContent input:focus {
            border: 2px solid #3b82f6;
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        #sellModalContent button {
            padding: 8px 16px;
            border-radius: 8px;
            border: none;
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: #fff;
            font-weight: 700;
            cursor: pointer;
            font-size: 10px;
            margin-top: 6px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2);
        }
        
        #sellModalContent button .material-icons {
            font-size: 14px;
            margin-bottom: 1px;
        }
        
        #sellModalContent button:hover { 
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 8px 24px rgba(59, 130, 246, 0.3);
        }
        
        #sellModalContent .cancel-btn {
            background: linear-gradient(135deg, #374151 0%, #1f2937 100%);
            color: #fff;
            margin-left: 8px;
            border: 1px solid #4b5563;
        }
        
        #sellModalError {
            color: #f87171;
            margin-top: 8px;
            font-size: 9px;
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(127, 29, 29, 0.2);
            padding: 6px 10px;
            border-radius: 6px;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }
        
        #sellModalClose {
            position: absolute;
            top: 12px;
            right: 12px;
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 20px;
            cursor: pointer;
            z-index: 2;
            display: flex;
            align-items: center;
            padding: 4px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        #sellModalClose:hover { 
            color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }
    </style>

</head>
<body>
  <div class="banner-top">
    <img src="https://pbs.twimg.com/media/GtAPA6qXEAA4du1?format=jpg&name=large" alt="Banner">
  </div>
  <div class="wrapper">
    <div class="header">
      <span class="material-icons">currency_bitcoin</span>
      Coin Fun
    </div>
    <div class="top-bar">
      <div class="nftfan-balance-bar" id="nftfanBalanceBar" style="display:none;">
        <img class="nftfan-token-icon" src="https://i.imgur.com/ODP45iQ.png" alt="NFTFAN Token">
        <span id="nftfanBalance">--</span>
        <span style="font-size:7px;font-weight:400;color:#888;margin-left:2px;">NFTFAN</span>
      </div>
      <button class="connect-btn" id="connect-btn" onclick="connectWallet()">
        <span class="material-icons">link</span>
        Connect Wallet
      </button>
    </div>
    <div class="status-bar status-info" id="statusBar">
      <span class="material-icons" id="statusBarIcon">info</span>
      Status: Initializing...
    </div>
    <div class="tab-bar">
      <button class="tab-btn" id="tab-listings" onclick="showTab('listings')">
        <span class="material-icons">list_alt</span>User Listings
      </button>
      <button class="tab-btn active" id="tab-shop" onclick="showTab('shop')">
        <span class="material-icons">storefront</span>Coin Shop
      </button>
      <button class="tab-btn" id="tab-mynfts" onclick="showTab('mynfts')">
        <span class="material-icons">account_balance_wallet</span>My Coins
      </button>
    </div>
    <!-- Shop Tab -->
    <div class="tab-content" id="tab-content-shop">
      <div id="shop-loading" class="loading" style="color:#60a5fa;text-align:center;padding:18px 0;font-size:10px;">Loading NFTs...</div>
      <div id="shop-error" class="error" style="display: none;background:#fee2e2;color:#e53e3e;padding:7px;border-radius:4px;margin-bottom:7px;font-size:9px;text-align:left;border:1px solid #fecaca;"></div>
      <ul class="nft-list" id="shopGrid" style="display: none;"></ul>
    </div>
    <!-- My NFTs Tab -->
    <div class="tab-content" id="tab-content-mynfts" style="display:none;">
      <div id="my-loading" class="loading" style="color:#60a5fa;text-align:center;padding:18px 0;font-size:10px;">Loading Your NFTs...</div>
      <div id="my-error" class="error" style="display: none;background:#fee2e2;color:#e53e3e;padding:7px;border-radius:4px;margin-bottom:7px;font-size:9px;text-align:left;border:1px solid #fecaca;"></div>
      <ul class="nft-list" id="myGrid" style="display: none;"></ul>
    </div>
    <!-- User Listings Tab -->
    <div class="tab-content" id="tab-content-listings" style="display:none;">
      <div id="listings-loading" class="loading" style="color:#60a5fa;text-align:center;padding:18px 0;font-size:10px;">Loading User Listings...</div>
      <div id="listings-error" class="error" style="display: none;background:#fee2e2;color:#e53e3e;padding:7px;border-radius:4px;margin-bottom:7px;font-size:9px;text-align:left;border:1px solid #fecaca;"></div>
      <ul class="nft-list" id="listingsGrid" style="display: none;"></ul>
    </div>
  </div>
  <!-- Sell Modal -->
  <div id="sellModal">
    <div id="sellModalContent">
      <button id="sellModalClose" onclick="closeSellModal()" title="Close"><span class="material-icons">close</span></button>
      <h3>
        <span class="material-icons">sell</span>
        Sell Your NFT
      </h3>
      <div>
        <span class="material-icons" style="font-size:12px;vertical-align:middle;">confirmation_number</span>
        Token ID: <span id="sellTokenId"></span>
      </div>
      <div>
        <span class="material-icons" style="font-size:12px;vertical-align:middle;">inventory_2</span>
        You own: <span id="sellMaxAmount"></span>
      </div>
      <input type="number" id="sellAmountInput" min="1" placeholder="Amount to sell">
      <input type="number" id="sellPriceInput" step="0.000000000000000001" placeholder="Price per NFT (MATIC)">
      <div style="display:flex;gap:7px;width:100%;justify-content:flex-start;">
        <button onclick="confirmSellNFT()">
          <span class="material-icons">check_circle</span>Sell
        </button>
        <button onclick="closeSellModal()" class="cancel-btn">
          <span class="material-icons">cancel</span>Cancel
        </button>
      </div>
      <div id="sellModalError"></div>
    </div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.8.0/web3.min.js"></script>
<script>
  // --- CONFIG ---
  const POLYGON_PARAMS = {
    chainId: "0x89",
    chainName: "Polygon Mainnet",
    nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
    rpcUrls: [
      "https://polygon-rpc.com/",
      "https://rpc.polygon.technology/",
      "https://rpc-mainnet.matic.network/",
    ],
    blockExplorerUrls: ["https://polygonscan.com/"],
  };
  const NFTFAN_SHOP_CA = "0x582E752646c6df16a14247994f1848C7Cd208211";
    const NFTFAN_SHOP_ABI = [
  {
    inputs: [],
    stateMutability: "nonpayable",
    type: "constructor",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "creator",
        type: "address",
      },
      {
        indexed: false,
        internalType: "string",
        name: "tokenURI",
        type: "string",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NFTMinted",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "buyer",
        type: "address",
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NFTBought",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "NFTListed",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "NFTUnlisted",
    type: "event",
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "address",
        name: "seller",
        type: "address",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "listingIndex",
        type: "uint256",
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "ListingCancelled",
    type: "event",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256",
      },
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
    ],
    name: "buyNFT",
    outputs: [],
    stateMutability: "payable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "listingIndex",
        type: "uint256",
      },
    ],
    name: "cancelListing",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "exists",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "getListings",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "seller",
            type: "address",
          },
          {
            internalType: "uint256",
            name: "amount",
            type: "uint256",
          },
          {
            internalType: "uint256",
            name: "price",
            type: "uint256",
          },
        ],
        internalType: "struct NFTFansShop.Listing[]",
        name: "",
        type: "tuple[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "getShopInventory",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [],
    name: "getShopNFTs",
    outputs: [
      {
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]",
      },
      {
        internalType: "string[]",
        name: "uris",
        type: "string[]",
      },
      {
        internalType: "uint256[]",
        name: "prices",
        type: "uint256[]",
      },
      {
        internalType: "bool[]",
        name: "isForSale",
        type: "bool[]",
      },
      {
        internalType: "uint256[]",
        name: "shopAmounts",
        type: "uint256[]",
      },
      {
        internalType: "uint256[]",
        name: "maxSupplies",
        type: "uint256[]",
      },
      {
        internalType: "uint256[]",
        name: "currentSupplies",
        type: "uint256[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "_tokenURI",
        type: "string",
      },
      {
        internalType: "uint256",
        name: "_price",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_maxSupply",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "mintNFT",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_amount",
        type: "uint256",
      },
    ],
    name: "mintAdditional",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [],
    name: "nextTokenId",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "nftInfo",
    outputs: [
      {
        internalType: "string",
        name: "tokenURI",
        type: "string",
      },
      {
        internalType: "uint256",
        name: "price",
        type: "uint256",
      },
      {
        internalType: "bool",
        name: "forSale",
        type: "bool",
      },
      {
        internalType: "address",
        name: "originalCreator",
        type: "address",
      },
      {
        internalType: "uint256",
        name: "maxSupply",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "currentSupply",
        type: "uint256",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256",
      },
      {
        internalType: "uint256",
        name: "_price",
        type: "uint256",
      },
    ],
    name: "sellNFT",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "user",
        type: "address",
      },
    ],
    name: "tokensOfOwner",
    outputs: [
      {
        internalType: "uint256[]",
        name: "tokenIds",
        type: "uint256[]",
      },
      {
        internalType: "uint256[]",
        name: "amounts",
        type: "uint256[]",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "unlistNFT",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256",
      },
    ],
    name: "uri",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string",
      },
    ],
    stateMutability: "view",
    type: "function",
  },
];

  let userAccount = null,
    web3,
    nftfanShop = null,
    lastError = null,
    statusTimeout = null;
  let sellModalTokenId = null,
    sellModalMaxAmount = null;

 function setStatusBar(type, message) {
  const statusBar = document.getElementById("statusBar");
  const iconSpan = document.getElementById("statusBarIcon");
  statusBar.className = `status-bar status-${type}`;
  if (iconSpan) {
    if (type === "success") iconSpan.textContent = "check_circle";
    else if (type === "error") iconSpan.textContent = "error";
    else if (type === "warn") iconSpan.textContent = "warning";
    else iconSpan.textContent = "info";
  }
  statusBar.style.display = "flex";
  statusBar.textContent = "";
  statusBar.appendChild(iconSpan);
  statusBar.appendChild(document.createTextNode(message));
}

function updateStatus(message, type = "info") {
  setStatusBar(type, message);
  // Status bar stays on screen; no timeout to hide it.
}

function logError(error, context = "") {
  lastError = `${context}: ${error.message || error}`;
}

function showError(elementId, message) {
  const errorEl = document.getElementById(elementId);
  errorEl.textContent = message;
  errorEl.style.display = "block";
  updateStatus(message, "error");
}

function hideError(elementId) {
  document.getElementById(elementId).style.display = "none";
}

  async function connectWallet() {
    try {
      updateStatus("Connecting wallet...", "info");
      if (!window.ethereum) throw new Error("Please install MetaMask or a compatible wallet!");
      const chainId = await window.ethereum.request({ method: "eth_chainId" });
      if (chainId !== POLYGON_PARAMS.chainId) {
        updateStatus("Switching to Polygon network...", "info");
        try {
          await window.ethereum.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: POLYGON_PARAMS.chainId }],
          });
        } catch (switchError) {
          if (switchError.code === 4902) {
            await window.ethereum.request({
              method: "wallet_addEthereumChain",
              params: [POLYGON_PARAMS],
            });
          } else {
            throw switchError;
          }
        }
      }
      const accounts = await window.ethereum.request({ method: "eth_requestAccounts" });
      userAccount = accounts[0];
      document.getElementById("connect-btn").textContent = formatAddress(userAccount);
      await setupContracts();
      updateStatus("Connected successfully", "success");
      loadShopNFTs();
      loadUserNFTs();
      loadUserListings();
    } catch (error) {
      console.error("connectWallet failed:", error);
      logError(error, "Wallet Connection");
      updateStatus("Connection failed: " + error.message, "error");
    }
  }

  async function setupContracts() {
    try {
      updateStatus("Setting up contracts...", "info");
      const rpcUrls = POLYGON_PARAMS.rpcUrls;
      let provider = null;
      if (window.ethereum) {
        provider = window.ethereum;
        console.log("Using MetaMask provider");
      } else {
        for (const rpcUrl of rpcUrls) {
          try {
            const testWeb3 = new Web3(rpcUrl);
            const blockNumber = await testWeb3.eth.getBlockNumber();
            console.log(`Connected to RPC ${rpcUrl}, block number: ${blockNumber}`);
            provider = rpcUrl;
            break;
          } catch (e) {
            console.error(`Failed to connect to RPC ${rpcUrl}:`, e);
          }
        }
      }
      if (!provider) throw new Error("No working RPC provider found");
      web3 = new Web3(provider);
      nftfanShop = new web3.eth.Contract(NFTFAN_SHOP_ABI, NFTFAN_SHOP_CA);
      console.log("Contract initialized at address:", NFTFAN_SHOP_CA);
      updateStatus("Contracts initialized", "success");
    } catch (error) {
      console.error("Contract setup failed:", error);
      logError(error, "Contract Setup");
      updateStatus("Contract setup failed: " + error.message, "error");
      throw error;
    }
  }

  async function fetchOpenSeaMeta(uri) {
    if (!uri) return null;
    try {
      if (uri.startsWith("ipfs://")) uri = "https://ipfs.io/ipfs/" + uri.slice(7);
      if (uri.startsWith("ar://")) uri = "https://arweave.net/" + uri.slice(5);
      const res = await fetch(uri, { mode: "cors" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      console.error("fetchOpenSeaMeta failed for URI", uri, ":", e);
      updateStatus("Metadata fetch failed: " + (uri || "unknown"), "warn");
      return null;
    }
  }

  let permanentlySoldOutIds = JSON.parse(localStorage.getItem("nftfans_permanently_sold_out_ids") || "[]");

  function markPermanentlySoldOut(tokenId) {
    if (!permanentlySoldOutIds.includes(tokenId)) {
      permanentlySoldOutIds.push(tokenId);
      localStorage.setItem("nftfans_permanently_sold_out_ids", JSON.stringify(permanentlySoldOutIds));
    }
  }

  async function loadShopNFTs() {
    const shopGrid = document.getElementById("shopGrid");
    const loading = document.getElementById("shop-loading");
    shopGrid.innerHTML = "";
    loading.style.display = "block";
    shopGrid.style.display = "none";
    hideError("shop-error");
    try {
      updateStatus("Loading shop NFTs...", "info");
      if (!nftfanShop) await setupContracts();
      const result = await nftfanShop.methods.getShopNFTs().call();
      console.log("getShopNFTs result:", result);
      const { ids, uris, prices, isForSale, shopAmounts, maxSupplies } = result;
      if (!ids.length) {
        loading.textContent = "No NFTs in Shop";
        updateStatus("No NFTs in shop", "info");
        return;
      }
      updateStatus(`Loading metadata for ${ids.length} NFTs...`, "info");
      const metaArr = await Promise.all(
        uris.map(async (uri, i) => {
          try {
            const meta = await fetchOpenSeaMeta(uri);
            console.log(`Metadata for URI ${uri}:`, meta);
            return meta;
          } catch (e) {
            console.error(`Failed to fetch metadata for URI ${uri}:`, e);
            return null;
          }
        })
      );
      let html = "";
      let visibleCount = 0;
      for (let i = 0; i < ids.length; i++) {
        const id = ids[i],
          meta = metaArr[i],
          name = meta?.name || `NFTFAN #${id}`,
          img = meta?.image || uris[i] || "https://via.placeholder.com/92x92?text=NFT",
          desc = meta?.description || "",
          price = web3.utils.fromWei(prices[i], "ether"),
          forSale = isForSale[i],
          available = shopAmounts[i],
          maxSupply = maxSupplies ? maxSupplies[i] : "";
        let statusBadge = "";
        if (forSale && available > 0) {
          statusBadge = `<span class="nft-status-label nft-status-listed">Listed</span>`;
        } else {
          statusBadge = `<span class="nft-status-label nft-status-notlisted">Not listed</span>`;
        }
        html += `<li class="nft-post">
          <div class="nft-post-left">
            <span class="serial-number">${++visibleCount}</span>
            <img class="nft-avatar" src="${img}" alt="NFT ${name}" onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
            <div class="nft-content">
              <div class="nft-title">${name}
                ${maxSupply ? `<span class="nft-supply">Â· Max: ${maxSupply}</span>` : ""}
              </div>
              <div class="nft-description">${
                desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
              }</div>
              ${statusBadge}
            </div>
          </div>
          <div class="nft-actions">
            <div class="price-tab">${price} POL</div>
            ${
              forSale && available != "0"
                ? `<button class="buy-btn" onclick="buyNFT(${id}, '${prices[i]}', ${available})" ${
                    !userAccount ? "disabled" : ""
                  }><span class="material-icons">shopping_cart</span>Buy</button>`
                : `<div class="sold-out"><span class="material-icons">block</span>Sold Out</div>`
            }
          </div>
        </li>`;
      }
      shopGrid.innerHTML = html;
      loading.style.display = "none";
      shopGrid.style.display = visibleCount > 0 ? "block" : "none";
      if (visibleCount === 0) {
        loading.textContent = "No NFTs available in shop.";
        loading.style.display = "block";
      }
      updateStatus("Shop loaded", "success");
    } catch (error) {
      console.error("loadShopNFTs failed:", error);
      logError(error, "Shop Loading");
      showError("shop-error", "Failed to load NFTs: " + error.message);
    }
  }

  async function loadUserNFTs() {
  const myGrid = document.getElementById("myGrid");
  const loading = document.getElementById("my-loading");
  myGrid.innerHTML = "";
  loading.style.display = "block";
  myGrid.style.display = "none";
  hideError("my-error");
  if (!userAccount) {
    loading.textContent = "Connect wallet to view your NFTs.";
    updateStatus("Connect wallet to view your NFTs", "info");
    return;
  }
  try {
    updateStatus("Loading your NFTs...", "info");
    if (!nftfanShop) await setupContracts();
    const tokens = await nftfanShop.methods.tokensOfOwner(userAccount).call();
    console.log("tokensOfOwner result:", tokens);
    const { tokenIds, amounts } = tokens;
    let metaArr = await Promise.all(
      tokenIds.map(async (id, idx) => {
        try {
          let meta = await nftfanShop.methods.nftInfo(id).call();
          console.log(`nftInfo for token ${id}:`, meta);
          let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
          console.log(`Metadata for token ${id}:`, metaJson);
          let listings = await nftfanShop.methods.getListings(id).call();
          console.log(`Listings for token ${id}:`, listings);
          let userListings = listings
            .map((l, index) => ({ ...l, listingIndex: index }))
            .filter((l) => l.seller.toLowerCase() === userAccount.toLowerCase() && Number(l.amount) > 0);
          console.log(`User listings for token ${id}:`, userListings);
          return { id, amount: amounts[idx], meta, metaJson, userListings };
        } catch (e) {
          console.error(`Failed to load data for token ${id}:`, e);
          return { id, amount: amounts[idx], meta: null, metaJson: null, userListings: [] };
        }
      })
    );
    // Include NFTs with listings even if amount is 0
    let additionalListings = [];
    const allShopNFTs = await nftfanShop.methods.getShopNFTs().call();
    for (let i = 0; i < allShopNFTs.ids.length; i++) {
      const id = allShopNFTs.ids[i];
      if (!tokenIds.includes(id)) {
        try {
          let listings = await nftfanShop.methods.getListings(id).call();
          let userListings = listings
            .map((l, index) => ({ ...l, listingIndex: index }))
            .filter((l) => l.seller.toLowerCase() === userAccount.toLowerCase() && Number(l.amount) > 0);
          if (userListings.length > 0) {
            let meta = await nftfanShop.methods.nftInfo(id).call();
            let metaJson = await fetchOpenSeaMeta(meta.tokenURI);
            additionalListings.push({
              id,
              amount: 0,
              meta,
              metaJson,
              userListings
            });
            console.log(`Added token ${id} with listings but no ownership`);
          }
        } catch (e) {
          console.error(`Failed to check listings for token ${id}:`, e);
        }
      }
    }
    metaArr = metaArr.concat(additionalListings);
    if (!metaArr.length) {
      loading.textContent = "You own no NFTs and have no active listings.";
      updateStatus("No NFTs or listings found", "info");
      return;
    }
    let html = "";
    for (let i = 0; i < metaArr.length; i++) {
      const item = metaArr[i];
      const { id, amount, meta, metaJson, userListings } = item;
      const name = metaJson?.name || `NFTFAN #${id}`;
      const img =
        metaJson?.image || (meta?.tokenURI || "https://via.placeholder.com/92x92?text=NFT");
      const desc = metaJson?.description || "";
      const maxSupply = meta?.maxSupply || "";
      let listingsHtml = "";
      if (userListings.length > 0) {
        listingsHtml = `<div class="nft-listings" style="margin-top:5px;font-size:8px;color:#93c5fd;">Your Listings:</div>`;
        listingsHtml += userListings
          .map(
            (l, idx) => `
              <div style="display:flex;gap:5px;align-items:center;margin-top:3px;">
                <span>Price: ${web3.utils.fromWei(l.price, "ether")} MATIC</span>
                <span>Amount: ${l.amount}</span>
                <button class="delist-btn" onclick="cancelListing(${id}, ${l.listingIndex})">
                  <span class="material-icons">cancel</span>Delist
                </button>
              </div>`
          )
          .join("");
      }
      html += `<li class="nft-post">
        <div class="nft-post-left">
          <span class="serial-number">${i + 1}</span>
          <img class="nft-avatar" src="${img}" alt="NFT ${name}" 
               onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
          <div class="nft-content">
            <div class="nft-title">${name}
              ${maxSupply ? `<span class="nft-supply">Â· Max: ${maxSupply}</span>` : ""}
            </div>
            <div class="nft-description">${
              desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
            }</div>
            <div class="nft-supply" style="margin-top:3px;color:#60a5fa;">You own: ${amount}</div>
            <button class="sell-btn" style="margin-top:5px;width:90px;" 
                    onclick="openSellModal(${id}, ${amount})" 
                    ${amount == 0 ? "disabled" : ""}>
              <span class="material-icons">sell</span>Sell
            </button>
            ${listingsHtml}
          </div>
        </div>
      </li>`;
    }
    myGrid.innerHTML = html;
    loading.style.display = "none";
    myGrid.style.display = "block";
    updateStatus("Your NFTs loaded", "success");
  } catch (error) {
    console.error("loadUserNFTs failed:", error);
    logError(error, "User NFTs Loading");
    showError("my-error", "Failed to load your NFTs: " + error.message);
  }
}
  async function loadUserListings() {
    const listingsGrid = document.getElementById("listingsGrid");
    const loading = document.getElementById("listings-loading");
    listingsGrid.innerHTML = "";
    loading.style.display = "block";
    listingsGrid.style.display = "none";
    hideError("listings-error");
    try {
      updateStatus("Loading user listings...", "info");
      if (!nftfanShop) await setupContracts();
      const result = await nftfanShop.methods.getShopNFTs().call();
      console.log("getShopNFTs for listings:", result);
      const { ids, uris } = result;
      if (!ids.length) {
        loading.textContent = "No NFTs in Shop";
        updateStatus("No NFTs in shop", "info");
        return;
      }
      let allListings = [];
      for (let i = 0; i < ids.length; i++) {
        try {
          const id = ids[i];
          const uri = uris[i];
          const listings = await nftfanShop.methods.getListings(id).call();
          console.log(`Listings for token ${id}:`, listings);
          const meta = await nftfanShop.methods.nftInfo(id).call();
          console.log(`nftInfo for token ${id}:`, meta);
          const originalCreator = meta.originalCreator;
          const filtered = listings
            .map((l, index) => ({ ...l, id, uri, meta, listingIndex: index }))
            .filter(
              (l) =>
                l.seller.toLowerCase() !== originalCreator.toLowerCase() &&
                Number(l.amount) > 0
            );
          allListings = allListings.concat(filtered);
        } catch (e) {
          console.error(`Failed to load listings for token ${ids[i]}:`, e);
        }
      }
      if (!allListings.length) {
        loading.textContent = "No other user listings yet.";
        updateStatus("No user listings", "info");
        return;
      }
      updateStatus(`Loading metadata for ${allListings.length} listings...`, "info");
      let html = "";
      for (let i = 0; i < allListings.length; i++) {
        const l = allListings[i];
        let metaJson = await fetchOpenSeaMeta(l.meta.tokenURI);
        console.log(`Metadata for listing ${l.id}:`, metaJson);
        let name = metaJson?.name || `NFTFAN #${l.id}`;
        let img =
          metaJson?.image || l.meta.tokenURI || "https://via.placeholder.com/92x92?text=NFT";
        let desc = metaJson?.description || "";
        let price = web3.utils.fromWei(l.price, "ether");
        html += `<li class="nft-post">
          <div class="nft-post-left">
            <span class="serial-number">${i + 1}</span>
            <img class="nft-avatar" src="${img}" alt="NFT ${name}" 
                 onerror="this.src='https://via.placeholder.com/92x92?text=NFT'">
            <div class="nft-content">
              <div class="nft-title">${name}
                ${l.meta.maxSupply ? `<span class="nft-supply">Â· Max: ${l.meta.maxSupply}</span>` : ""}
              </div>
              <div class="nft-description">${
                desc ? desc.substring(0, 60) + (desc.length > 60 ? "..." : "") : ""
              }</div>
              <div class="nft-supply" style="margin-top:3px;color:#60a5fa;">Seller: ${formatAddress(
                l.seller
              )}</div>
            </div>
          </div>
          <div class="nft-actions">
            <div class="price-tab">${price} MATIC</div>
            <button class="buy-btn" onclick="buyUserListing('${l.id}', '${l.seller}', '${
              l.price
            }', '${l.amount}')" ${!userAccount ? "disabled" : ""}>
              <span class="material-icons">shopping_cart</span>Buy
            </button>
          </div>
        </li>`;
      }
      listingsGrid.innerHTML = html;
      loading.style.display = "none";
      listingsGrid.style.display = "block";
      updateStatus("User listings loaded", "success");
    } catch (error) {
      console.error("loadUserListings failed:", error);
      logError(error, "User Listings Loading");
      showError("listings-error", "Failed to load user listings: " + error.message);
    }
  }

  window.buyNFT = async function (tokenId, priceWei, availableAmount) {
    if (!userAccount) return updateStatus("Connect your wallet first!", "error");
    let amount = 1;
    if (availableAmount > 1) {
      let input = prompt(`How many would you like to buy? (max ${availableAmount})`, "1");
      if (!input) return;
      amount = parseInt(input);
      if (isNaN(amount) || amount < 1 || amount > availableAmount)
        return updateStatus("Invalid amount", "error");
    }
    try {
      updateStatus("Processing purchase...", "info");
      await nftfanShop.methods.buyNFT(tokenId, amount).send({
        from: userAccount,
        value: (BigInt(priceWei) * BigInt(amount)).toString(),
      });
      updateStatus("NFT bought successfully!", "success");
      await loadShopNFTs();
      await loadUserNFTs();
      await loadUserListings();
    } catch (error) {
      console.error("buyNFT failed:", error);
      logError(error, "NFT Purchase");
      updateStatus("Purchase failed: " + error.message, "error");
    }
  };

  window.buyUserListing = async function (tokenId, seller, priceWei, availableAmount) {
    if (!userAccount) return updateStatus("Connect your wallet first!", "error");
    let amount = 1;
    if (availableAmount > 1) {
      let input = prompt(`How many would you like to buy from user? (max ${availableAmount})`, "1");
      if (!input) return;
      amount = parseInt(input);
      if (isNaN(amount) || amount < 1 || amount > availableAmount)
        return updateStatus("Invalid amount", "error");
    }
    try {
      updateStatus("Processing purchase...", "info");
      await nftfanShop.methods.buyNFT(tokenId, amount).send({
        from: userAccount,
        value: (BigInt(priceWei) * BigInt(amount)).toString(),
      });
      updateStatus("NFT bought successfully!", "success");
      await loadShopNFTs();
      await loadUserNFTs();
      await loadUserListings();
    } catch (error) {
      console.error("buyUserListing failed:", error);
      logError(error, "NFT User Listing Purchase");
      updateStatus("Purchase failed: " + error.message, "error");
    }
  };

 window.cancelListing = async function (tokenId, listingIndex) {
  if (!userAccount) return updateStatus("Connect your wallet first!", "error");
  if (!confirm("Are you sure you want to delist this NFT?")) return;
  try {
    updateStatus("Delisting NFT...", "info");
    await nftfanShop.methods
      .cancelListing(tokenId, listingIndex)
      .send({ from: userAccount });
    updateStatus("NFT delisted successfully!", "success");
    await loadShopNFTs();
    await loadUserNFTs();
    await loadUserListings();
  } catch (error) {
    console.error("cancelListing failed:", error);
    logError(error, "Delist NFT");
    updateStatus("Delist failed: " + error.message, "error");
  }
};

  window.openSellModal = function (tokenId, maxAmount) {
    sellModalTokenId = tokenId;
    sellModalMaxAmount = maxAmount;
    document.getElementById("sellModal").style.display = "flex";
    document.getElementById("sellTokenId").textContent = tokenId;
    document.getElementById("sellMaxAmount").textContent = maxAmount;
    document.getElementById("sellAmountInput").value = "";
    document.getElementById("sellAmountInput").max = maxAmount;
    document.getElementById("sellPriceInput").value = "";
    document.getElementById("sellModalError").textContent = "";
  };

  window.closeSellModal = function () {
    document.getElementById("sellModal").style.display = "none";
    sellModalTokenId = null;
    sellModalMaxAmount = null;
  };

  window.confirmSellNFT = async function () {
    const amount = parseInt(document.getElementById("sellAmountInput").value);
    const price = document.getElementById("sellPriceInput").value;
    document.getElementById("sellModalError").textContent = "";
    if (!userAccount) return document.getElementById("sellModalError").textContent = "Connect your wallet first!";
    if (!amount || isNaN(amount) || amount < 1 || amount > sellModalMaxAmount)
      return document.getElementById("sellModalError").textContent = "Invalid amount!";
    if (!price || isNaN(price) || Number(price) <= 0)
      return document.getElementById("sellModalError").textContent = "Invalid price!";
    let priceWei = "0";
    try {
      priceWei = web3.utils.toWei(price, "ether");
    } catch {
      return document.getElementById("sellModalError").textContent = "Invalid price.";
    }
    try {
      updateStatus("Processing sale...", "info");
      await nftfanShop.methods.sellNFT(sellModalTokenId, amount, priceWei).send({ from: userAccount });
      updateStatus("NFT listed for sale!", "success");
      closeSellModal();
      await loadShopNFTs();
      await loadUserNFTs();
      await loadUserListings();
    } catch (error) {
      console.error("confirmSellNFT failed:", error);
      logError(error, "NFT Sale");
      updateStatus("Sale listing failed: " + error.message, "error");
      document.getElementById("sellModalError").textContent = "Sale failed: " + error.message;
    }
  };

  window.onclick = function (event) {
    const modal = document.getElementById("sellModal");
    if (event.target === modal) closeSellModal();
  };

  function formatAddress(address) {
    if (!address) return "";
    return `${address.slice(0, 5)}...${address.slice(-4)}`;
  }

  if (window.ethereum) {
    window.ethereum.on("accountsChanged", function (accounts) {
      userAccount = accounts[0] || null;
      const connectBtn = document.getElementById("connect-btn");
      connectBtn.textContent = userAccount ? formatAddress(userAccount) : "ðŸ”— Connect Wallet";
      if (userAccount) {
        setupContracts().then(() => {
          loadShopNFTs();
          loadUserNFTs();
          loadUserListings();
          updateStatus("Account changed", "success");
        });
      } else {
        updateStatus("Wallet disconnected", "info");
      }
    });
    window.ethereum.on("chainChanged", function (chainId) {
      updateStatus("Network changed - reconnecting...", "info");
      setupContracts().then(() => {
        loadShopNFTs();
        loadUserNFTs();
        loadUserListings();
        updateStatus("Network changed", "success");
      });
    });
    nftfanShop.events
      .ListingCancelled({})
      .on("data", async (event) => {
        updateStatus(`Listing for NFT #${event.returnValues.tokenId} cancelled`, "success");
        await loadShopNFTs();
        await loadUserNFTs();
        await loadUserListings();
      })
      .on("error", (error) => {
        console.error("ListingCancelled event error:", error);
        updateStatus("Failed to process listing cancellation event", "error");
      });
  }

window.addEventListener("DOMContentLoaded", async () => {
  try {
    console.log('Initializing app...');
    updateStatus("Initializing...", "info");
    await setupContracts();
    console.log('Contracts set up successfully');
    await loadShopNFTs();
    console.log('Shop NFTs loaded');
    await loadUserListings();
    console.log('User listings loaded');
    await loadUserNFTs();
    console.log('User NFTs loaded');
    updateStatus("Ready", "success");
    // Bind tab button events
    const tabButtons = {
      'listings': document.getElementById('tab-listings'),
      'shop': document.getElementById('tab-shop'),
      'mynfts': document.getElementById('tab-mynfts')
    };
    Object.keys(tabButtons).forEach(tab => {
      if (tabButtons[tab]) {
        tabButtons[tab].addEventListener('click', () => {
          console.log(`Tab button clicked: ${tab}`);
          showTab(tab);
        });
      } else {
        console.error(`Tab button not found: tab-${tab}`);
      }
    });
  } catch (error) {
    console.error("Initialization failed:", error);
    logError(error, "Initialization");
    updateStatus("Initialization failed: " + error.message, "error");
    showError("shop-error", "Failed to initialize the application. Please refresh.");
  }
});
  
function showTab(tab) {
  try {
    console.log(`Switching to tab: ${tab}`);
    const tabContents = ['shop', 'mynfts', 'listings'];
    tabContents.forEach((t) => {
      const content = document.getElementById(`tab-content-${t}`);
      if (content) {
        content.style.display = 'none';
      } else {
        console.error(`Tab content element not found: tab-content-${t}`);
      }
    });
    const selectedContent = document.getElementById(`tab-content-${tab}`);
    if (selectedContent) {
      selectedContent.style.display = 'block';
    } else {
      throw new Error(`Invalid tab content ID: tab-content-${tab}`);
    }
    tabContents.forEach((t) => {
      const btn = document.getElementById(`tab-${t}`);
      if (btn) {
        btn.classList.remove('active');
      } else {
        console.error(`Tab button element not found: tab-${t}`);
      }
    });
    const selectedBtn = document.getElementById(`tab-${tab}`);
    if (selectedBtn) {
      selectedBtn.classList.add('active');
    } else {
      throw new Error(`Invalid tab button ID: tab-${tab}`);
    }
    if (tab === 'shop') {
      loadShopNFTs().catch((e) => {
        console.error('loadShopNFTs failed in showTab:', e);
        updateStatus('Failed to load shop NFTs', 'error');
      });
    } else if (tab === 'mynfts') {
      loadUserNFTs().catch((e) => {
        console.error('loadUserNFTs failed in showTab:', e);
        updateStatus('Failed to load your NFTs', 'error');
      });
    } else if (tab === 'listings') {
      loadUserListings().catch((e) => {
        console.error('loadUserListings failed in showTab:', e);
        updateStatus('Failed to load user listings', 'error');
      });
    } else {
      throw new Error(`Invalid tab: ${tab}`);
    }
    console.log(`Tab switched successfully: ${tab}`);
  } catch (error) {
    console.error('showTab failed:', error);
    updateStatus(`Failed to switch to ${tab} tab: ${error.message}`, 'error');
  }
}

</script>

</body>
</html>
