
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>NFT Road — Mint your digital road</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
<link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
<!-- Leaflet -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Leaflet.draw -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<!-- Ethers -->
<script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
<!-- Firebase (compat SDK) -->
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>
<style>
:root {
--primary: #00f9ff;
--primary-glow: rgba(0, 249, 255, 0.5);
--primary-dark: #00b2ff;
--accent: #ff2cf0;
--accent-glow: rgba(255, 44, 240, 0.5);
--success: #12ff9b;
--success-glow: rgba(18, 255, 155, 0.4);
--error: #ff3860;
--error-glow: rgba(255, 56, 96, 0.4);
--bg: #0c0b1d;
--bg-dark: #07061a;
--card: #12122a;
--text: #eef2ff;
--muted: #8f9cce;
--border: #3e3f82;
--border-glow: rgba(0, 249, 255, 0.2);
--radius: 12px;
--shadow: rgba(0, 0, 0, 0.4);
--neon-shadow: 0 0 10px var(--primary-glow);
--accent-shadow: 0 0 10px var(--accent-glow);
}
* {
box-sizing: border-box;
}
html, body {
height: 100%;
scroll-behavior: smooth;
overscroll-behavior: none;
-webkit-tap-highlight-color: transparent;
}
body {
margin: 0;
font-family: 'Rajdhani', sans-serif;
background: var(--bg-dark);
color: var(--text);
line-height: 1.4;
overflow-x: hidden;
letter-spacing: 0.2px;
font-weight: 500;
}
#app-container {
display: flex;
flex-direction: column;
min-height: 100vh;
background: radial-gradient(800px at 15% 15%, rgba(0, 249, 255, 0.08), transparent 70%), radial-gradient(600px at 85% 20%, rgba(255, 44, 240, 0.08), transparent 70%), linear-gradient(180deg, var(--bg-dark), var(--bg));
}
/* Cyberpunk animated background grid with scanlines */
.cyber-grid {
position: fixed;
top: 0;
left: 0;
right: 0;
bottom: 0;
z-index: -1;
background-image: linear-gradient(rgba(0, 249, 255, 0.05) 1px, transparent 1px), linear-gradient(90deg, rgba(0, 249, 255, 0.05) 1px, transparent 1px);
background-size: 40px 40px;
animation: gridPulse 15s infinite linear;
perspective: 1000px;
transform-style: preserve-3d;
}
.cyber-grid::after {
content: '';
position: absolute;
top: 0;
left: 0;
right: 0;
bottom: 0;
background: linear-gradient(to bottom, transparent 0%, var(--bg-dark) 100%);
animation: scanline 8s infinite linear;
opacity: 0.5;
}
@keyframes gridPulse {
0%, 100% { background-size: 40px 40px; opacity: 1; }
50% { background-size: 42px 42px; opacity: 0.8; }
}
@keyframes scanline {
0% { transform: translateY(-100%); }
100% { transform: translateY(100%); }
}
/* Header */
header {
display: flex;
align-items: center;
justify-content: space-between;
padding: 16px;
position: relative;
z-index: 10;
}
.brand {
display: flex;
align-items: center;
gap: 12px;
}
.logo {
width: 40px;
height: 40px;
border-radius: 8px;
background: linear-gradient(135deg, var(--primary), var(--accent));
display: grid;
place-items: center;
box-shadow: 0 0 15px rgba(0, 249, 255, 0.4);
position: relative;
overflow: hidden;
}
.logo::before {
content: '';
position: absolute;
top: -50%;
left: -50%;
width: 200%;
height: 200%;
background: conic-gradient(transparent, var(--primary), transparent 30%);
animation: rotate 4s linear infinite;
}
.logo::after {
content: '';
position: absolute;
inset: 3px;
border-radius: 6px;
background: var(--bg-dark);
}
.logo .material-icons {
font-size: 22px;
color: var(--primary);
position: relative;
z-index: 2;
text-shadow: 0 0 8px var(--primary-glow);
}
@keyframes rotate {
from { transform: rotate(0deg); }
to { transform: rotate(360deg); }
}
.title h1 {
margin: 0;
font-size: 24px;
font-weight: 700;
font-family: 'Orbitron', sans-serif;
text-transform: uppercase;
letter-spacing: 1px;
background: linear-gradient(90deg, var(--primary), var(--accent));
-webkit-background-clip: text;
-webkit-text-fill-color: transparent;
background-clip: text;
text-shadow: 0 0 5px rgba(0, 249, 255, 0.3);
}
.title p {
margin: 0;
font-size: 14px;
color: var(--muted);
}
.actions {
display: flex;
gap: 10px;
flex-wrap: wrap;
align-items: center;
}
/* Buttons */
button {
appearance: none;
border: 1px solid transparent;
border-radius: 8px;
padding: 10px 14px;
font-size: 14px;
font-weight: 600;
font-family: 'Rajdhani', sans-serif;
color: var(--text);
cursor: pointer;
display: inline-flex;
align-items: center;
gap: 8px;
background: rgba(32, 33, 77, 0.6);
border-color: var(--border);
transition: all 0.2s ease;
position: relative;
overflow: hidden;
backdrop-filter: blur(10px);
text-transform: uppercase;
letter-spacing: 0.5px;
}
button::after {
content: '';
position: absolute;
top: 0;
left: -100%;
width: 100%;
height: 100%;
background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
transition: 0.5s;
}
button:hover::after {
left: 100%;
}
button .material-icons {
font-size: 18px;
}
button.primary {
background: linear-gradient(135deg, var(--primary-dark), var(--primary));
border-color: var(--primary);
box-shadow: 0 0 10px var(--primary-glow);
text-shadow: 0 0 5px var(--primary);
}
button.success {
background: linear-gradient(135deg, var(--success), #00ddb9);
border-color: var(--success);
box-shadow: 0 0 10px var(--success-glow);
color: #07172c;
font-weight: 700;
text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
}
button.accent {
background: linear-gradient(135deg, var(--accent), #ff6afc);
border-color: var(--accent);
box-shadow: 0 0 10px var(--accent-glow);
color: #07172c;
font-weight: 700;
text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
}
button:disabled {
opacity: 0.5;
cursor: not-allowed;
transform: none !important;
box-shadow: none;
}
button:not(:disabled):active {
transform: translateY(1px) scale(0.98);
}
.wallet {
color: var(--primary);
font-size: 14px;
font-weight: 700;
text-shadow: 0 0 5px var(--primary-glow);
background: rgba(0, 249, 255, 0.1);
padding: 4px 10px;
border-radius: 8px;
border: 1px solid rgba(0, 249, 255, 0.3);
}
.pill {
display: inline-flex;
align-items: center;
gap: 8px;
font-size: 13px;
padding: 6px 10px;
border-radius: 8px;
border: 1px solid var(--border);
background: rgba(15, 16, 40, 0.7);
color: var(--muted);
backdrop-filter: blur(5px);
}
.pill .material-icons {
font-size: 16px;
color: var(--primary);
}
/* Main content */
main {
display: grid;
grid-template-columns: 1fr;
gap: 16px;
padding: 0 16px 16px;
flex: 1;
}
@media (min-width: 980px) {
main {
grid-template-columns: 1.6fr 1fr;
max-width: 1440px;
margin: 0 auto;
width: 100%;
}
}
/* Map container with neon border glow */
.map-container {
position: relative;
width: 100%;
height: 70vh;
border-radius: var(--radius);
grid-column: 1 / -1;
overflow: hidden;
background: var(--card);
padding: 2px;
background: linear-gradient(135deg, var(--primary), var(--accent));
box-shadow: 0 0 25px rgba(0, 0, 0, 0.5), 0 0 15px var(--primary-glow);
}
#map {
height: 100%;
width: 100%;
border-radius: calc(var(--radius) - 2px);
overflow: hidden;
background: #070814;
}
/* Custom map attribution style */
.leaflet-control-attribution {
background: rgba(7, 8, 30, 0.7) !important;
color: var(--muted) !important;
font-family: 'Rajdhani', sans-serif;
font-size: 10px;
backdrop-filter: blur(5px);
border-radius: 4px !important;
padding: 2px 5px !important;
}
.leaflet-control-attribution a {
color: var(--primary) !important;
}
/* Custom zoom control style */
.leaflet-control-zoom {
border: none !important;
border-radius: 8px !important;
overflow: hidden;
}
.leaflet-control-zoom a {
background: rgba(15, 16, 40, 0.9) !important;
color: var(--primary) !important;
border: 1px solid var(--border) !important;
transition: all 0.2s ease !important;
}
.leaflet-control-zoom a:hover {
background: rgba(30, 31, 70, 0.9) !important;
color: var(--text) !important;
}
/* Map popup style */
.leaflet-popup-content-wrapper {
background: rgba(15, 16, 40, 0.95) !important;
border-radius: 10px !important;
border: 1px solid var(--border) !important;
backdrop-filter: blur(10px) !important;
box-shadow: 0 0 15px rgba(0, 0, 0, 0.5) !important;
}
.leaflet-popup-content {
color: var(--text) !important;
font-family: 'Rajdhani', sans-serif !important;
margin: 12px 16px !important;
}
.leaflet-popup-tip {
background: rgba(15, 16, 40, 0.95) !important;
}
.leaflet-popup-close-button {
color: var(--primary) !important;
text-shadow: 0 0 5px var(--primary-glow);
}
.popup-action-btn {
width: 100%;
margin-top: 12px;
padding: 8px 12px;
font-size: 13px;
background: rgba(0, 249, 255, 0.1);
border-color: rgba(0, 249, 255, 0.3);
color: var(--primary);
}
.popup-action-btn:hover {
background: rgba(0, 249, 255, 0.2);
box-shadow: 0 0 8px var(--primary-glow);
}
/* Info panel */
.panel {
background: rgba(18, 18, 42, 0.75);
border: 1px solid var(--border);
border-radius: var(--radius);
padding: 16px;
display: grid;
gap: 16px;
backdrop-filter: blur(10px);
box-shadow: 0 0 25px var(--shadow);
position: relative;
overflow: hidden;
z-index: 1;
}
.panel::after {
content: '';
position: absolute;
top: -1px;
left: -1px;
right: -1px;
height: 2px;
background: linear-gradient(90deg, transparent, var(--primary), var(--accent), transparent);
z-index: 2;
box-shadow: 0 0 15px var(--primary-glow);
}
.row {
display: grid;
gap: 12px;
}
.row.inline {
display: flex;
gap: 10px;
flex-wrap: wrap;
align-items: center;
}
.panel-header {
display: flex;
justify-content: space-between;
align-items: center;
padding-bottom: 8px;
border-bottom: 1px solid rgba(62, 63, 130, 0.3);
}
.panel-header h2 {
margin: 0;
font-family: 'Orbitron', sans-serif;
font-size: 18px;
color: var(--primary);
text-transform: uppercase;
letter-spacing: 1px;
text-shadow: 0 0 5px var(--primary-glow);
}
/* Legend */
.legend {
display: flex;
gap: 14px;
flex-wrap: wrap;
align-items: center;
font-size: 14px;
color: var(--muted);
}
.legend .key {
display: inline-flex;
align-items: center;
gap: 6px;
}
.legend .box {
width: 16px;
height: 16px;
border-radius: 3px;
border: 1px solid rgba(255, 255, 255, 0.2);
box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
}
/* Status indicator */
.status {
min-height: 46px;
display: grid;
place-items: center;
text-align: center;
font-size: 14px;
border-radius: 8px;
padding: 12px;
background: rgba(8, 9, 33, 0.5);
border: 1px solid rgba(62, 63, 130, 0.3);
color: var(--muted);
transition: all 0.3s ease;
}
.status.success {
background: rgba(18, 255, 155, 0.07);
color: var(--success);
border-color: rgba(18, 255, 155, 0.25);
box-shadow: 0 0 10px rgba(18, 255, 155, 0.1);
}
.status.error {
background: rgba(255, 56, 96, 0.07);
color: var(--error);
border-color: rgba(255, 56, 96, 0.25);
box-shadow: 0 0 10px rgba(255, 56, 96, 0.1);
}
.status.loading {
display: inline-flex;
align-items: center;
gap: 10px;
justify-content: center;
}
.spinner {
width: 18px;
height: 18px;
border-radius: 50%;
border: 2px solid rgba(255, 255, 255, 0.1);
border-left-color: var(--primary);
animation: spin 1s linear infinite;
box-shadow: 0 0 10px var(--primary-glow);
}
@keyframes spin {
to { transform: rotate(360deg); }
}
/* Toast notifications */
.toast {
position: fixed;
top: 20px;
left: 50%;
transform: translateX(-50%);
display: none;
align-items: center;
gap: 10px;
padding: 12px 16px;
background: rgba(12, 13, 38, 0.9);
color: var(--text);
border-left: 3px solid var(--primary);
border-radius: 8px;
box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3), 0 0 10px var(--primary-glow);
z-index: 9999;
font-size: 14px;
backdrop-filter: blur(10px);
animation: fadeIn 0.3s ease;
}
@keyframes fadeIn {
from { opacity: 0; transform: translate(-50%, -10px); }
to { opacity: 1; transform: translate(-50%, 0); }
}
.toast .spinner {
width: 18px;
height: 18px;
border-width: 2px;
}
.toast .material-icons {
font-size: 20px;
color: var(--primary);
text-shadow: 0 0 5px var(--primary-glow);
}
/* Form inputs */
.form-group {
display: grid;
gap: 6px;
}
.form-group label {
font-size: 14px;
font-weight: 600;
color: var(--muted);
text-transform: uppercase;
letter-spacing: 0.5px;
}
.form-group input[type="text"],
.form-group input[type="color"] {
font-family: 'Rajdhani', sans-serif;
font-size: 16px;
color: var(--text);
background: rgba(8, 9, 33, 0.5);
border: 1px solid var(--border);
border-radius: 6px;
padding: 8px 12px;
transition: all 0.2s ease;
}
.form-group input[type="text"]:focus {
outline: none;
border-color: var(--primary);
box-shadow: 0 0 8px var(--primary-glow);
}
.form-group input[type="color"] {
padding: 4px 8px;
height: 40px;
cursor: pointer;
}
/* Leaderboard */
.leaderboard-panel {
grid-column: 1 / -1;
max-height: 300px;
overflow-y: auto;
}
.leaderboard-table {
width: 100%;
border-collapse: collapse;
font-size: 7px;
text-transform: uppercase;
letter-spacing: 0.5px;
}
.leaderboard-table th,
.leaderboard-table td {
padding: 8px 10px;
text-align: left;
border-bottom: 1px solid rgba(62, 63, 130, 0.3);
}
.leaderboard-table th {
color: var(--primary);
font-family: 'Orbitron', sans-serif;
font-weight: 300;
font-size: 7px;
}
.leaderboard-table td {
color: var(--muted);
}
.leaderboard-table tr:last-child td {
border-bottom: none;
}
.leaderboard-table tr:hover {
background: rgba(0, 249, 255, 0.05);
}
.leaderboard-table .rank {
width: 40px;
text-align: center;
color: var(--accent);
font-weight: 700;
font-size: 6px;
}
.leaderboard-table .owner {
width: 150px;
font-weight: 600;
}
.leaderboard-table .value {
text-align: right;
color: var(--success);
font-weight: 700;
}
.leaderboard-table .length {
text-align: right;
color: var(--primary);
font-weight: 700;
}
.leaderboard-table .rewards {
text-align: right;
color: var(--accent);
font-weight: 700;
}
/* Mobile optimizations */
@media (max-width: 640px) {
header {
flex-direction: column;
align-items: flex-start;
gap: 12px;
}
.actions {
width: 100%;
justify-content: space-between;
}
main {
padding: 0 12px 12px;
gap: 12px;
}
.map-container {
height: 60vh;
}
button {
padding: 8px 12px;
font-size: 13px;
}
.panel {
padding: 12px;
}
.legend {
font-size: 12px;
gap: 10px;
}
.status {
font-size: 13px;
padding: 10px;
min-height: 42px;
}
}
/* Cyberpunk glitch effect for headings */
@keyframes glitch {
0% { transform: translate(0); }
20% { transform: translate(-2px, 1px); }
40% { transform: translate(-2px, -1px); }
60% { transform: translate(2px, 1px); }
80% { transform: translate(2px, -1px); }
100% { transform: translate(0); }
}
.glitch-text {
position: relative;
display: inline-block;
}
.glitch-text:hover::before,
.glitch-text:hover::after {
content: attr(data-text);
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
background: var(--bg);
}
.glitch-text:hover::before {
animation: glitch 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) both infinite;
color: var(--primary);
text-shadow: 0 0 5px var(--primary-glow);
clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
transform: translate(-2px, -2px);
}
.glitch-text:hover::after {
animation: glitch 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) reverse both infinite;
color: var(--accent);
text-shadow: 0 0 5px var(--accent-glow);
clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
transform: translate(2px, 2px);
}
/* Initial Loading Overlay */
#initial-loader {
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 100vh;
background: var(--bg-dark);
z-index: 10000;
display: flex;
align-items: center;
justify-content: center;
transition: opacity 0.5s ease, visibility 0.5s ease;
}
#initial-loader .loader-content {
text-align: center;
color: var(--primary);
}
#initial-loader .spinner {
width: 50px;
height: 50px;
border-width: 4px;
margin: 0 auto 20px;
}
#initial-loader .loader-text {
font-family: 'Orbitron', sans-serif;
font-size: 18px;
letter-spacing: 1px;
text-shadow: 0 0 10px var(--primary-glow);
}
#initial-loader.hidden {
opacity: 0;
visibility: hidden;
}
</style>
</head>
<body>
<!-- Initial Loading Overlay -->
<div id="initial-loader">
<div class="loader-content">
<div class="spinner"></div>
<div class="loader-text">Initializing NFT Road...</div>
</div>
</div>
<div id="app-container">
<div class="cyber-grid"></div>
<header>
<div class="brand">
<div class="logo"><span class="material-icons">straighten</span></div>
<div class="title">
<h1 class="glitch-text" data-text="NFT Road">NFT Road</h1>
<p>Mint your digital road in the metaverse</p>
</div>
</div>
<div class="actions">
<span class="pill">
<span class="material-icons">paid</span>
<span>Mint Price: <strong style="margin-left:4px;color:var(--primary);">1 POL per 10000km</strong></span>
</span>
<button id="connectBtn" class="primary">
<span class="material-icons">account_balance_wallet</span>Connect
</button>
<span id="wallet" class="wallet" style="display:none;"></span>
</div>
</header>
<main>
<div class="map-container">
<div id="map" aria-label="Map"></div>
</div>
<div class="panel">
<div class="panel-header">
<h2 class="glitch-text" data-text="Road Control">Road Control</h2>
</div>
<div class="row">
<div class="legend">
<div class="key"><span class="box" style="background:#191d3b;box-shadow:0 0 3px rgba(0,249,255,0.2);"></span> Not selected</div>
<div class="key"><span class="box" style="background:#0055ff;box-shadow:0 0 5px #0055ff;"></span> Selected</div>
<div class="key"><span class="box" style="background:#ff2cf0;box-shadow:0 0 5px rgba(255,44,240,0.5);"></span> Minted (Other)</div>
<div class="key"><span class="box" style="background:#12ff9b;box-shadow:0 0 5px rgba(18,255,155,0.5);"></span> Minted (You)</div>
</div>
</div>
<div class="row" style="grid-template-columns: 1fr 100px; gap: 10px;">
<div class="form-group">
<label for="roadNameInput">Road Name</label>
<input type="text" id="roadNameInput" placeholder="e.g. The Neon Highway" maxlength="32" />
</div>
<div class="form-group">
<label for="roadColorInput">Road Color</label>
<input type="color" id="roadColorInput" value="#00f9ff" />
</div>
</div>
<div class="row inline">
<span id="selectionPill" class="pill" style="display:none;"></span>
<span id="ownedCountPill" class="pill" style="display:none;"></span>
<span id="mintedCountPill" class="pill" style="display:none;"></span>
</div>
<div class="row inline">
<button id="saveBtn" class="accent" disabled>
<span class="material-icons">save</span>Save Road
</button>
<button id="mintBtn" class="success" disabled>
<span class="material-icons">rocket_launch</span>Mint Road
</button>
<button id="clearBtn" class="accent">
<span class="material-icons">delete_sweep</span>Clear
</button>
<button id="refreshBtn">
<span class="material-icons">refresh</span>Refresh
</button>
</div>
<div id="status" class="status">Use the draw tool to create a road on the map</div>
</div>
<div id="leaderboard" class="panel leaderboard-panel">
<div class="panel-header">
<h2 class="glitch-text" data-text="Richest Owners">Richest Owners</h2>
</div>
<table class="leaderboard-table">
<thead>
<tr>
<th class="rank">#</th>
<th class="owner">Owner</th>
<th class="value">Total Value</th>
<th class="length">Total Length (km)</th>
<th class="rewards">NFTFAN Rewards</th>
</tr>
</thead>
<tbody id="leaderboard-body">
<!-- Rows will be dynamically inserted here -->
</tbody>
</table>
</div>
</main>
</div>
<!-- Loading toast -->
<div id="cityLoading" class="toast" role="status" aria-live="assertive" aria-atomic="true">
<span class="spinner" aria-hidden="true"></span>
<span class="material-icons" aria-hidden="true">location_city</span>
<span class="text">Loading road data...</span>
</div>
<script>
// Polygon Mainnet
const POLYGON_PARAMS = {
chainId: '0x89',
chainName: 'Polygon Mainnet',
nativeCurrency: { name: 'POL', symbol: 'POL', decimals: 18 },
rpcUrls: ['https://polygon-rpc.com/'],
blockExplorerUrls: ['https://polygonscan.com/']
};
// Contract
const CONTRACT_ADDRESS = "0xb7d9E197905A0Fe7A59d82029eEFCBfDa631E2CC";
const CONTRACT_ABI = [
"function mintWithURI(string tokenURI) external payable returns (uint256)",
"function mintPrice() view returns (uint256)",
"function tokenURI(uint256 tokenId) view returns (string)",
"function ownerOf(uint256 tokenId) view returns (address)",
"event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"
];
const START_BLOCK = 0;
// Firebase configuration
const firebaseConfig = {
apiKey: "AIzaSyC6wYBu-KOXkDmB-84_7OPtY71zBX4FzRY",
authDomain: "newnft-47bd7.firebaseapp.com",
databaseURL: "https://newnft-47bd7-default-rtdb.firebaseio.com",
projectId: "newnft-47bd7",
storageBucket: "newnft-47bd7.firebasestorage.app",
messagingSenderId: "172043823738",
appId: "1:172043823738:web:daf1fcfb7862d7d8f029c3",
measurementId: "G-8VB3DYRNXR"
};
// Map / state
let map;
let selectionLayer;
let selected = null;
let drawnItems;
let drawControl;
let isLoading = false;
let currentMintPrice = 0;
let selectedLengthKm = 0;
// Layers for minted roads on map
let roadLayerGroup;
const roadLayersById = new Map();
const roadDataById = new Map();
// Ethers
let web3Provider, readProvider, signer, userAddress;
let roadName = '', roadColor = '#00f9ff';
// Firebase
let fbApp, fbDb;
let allRoadsRef = null;
// UI
const initialLoader = document.getElementById('initial-loader');
const connectBtn = document.getElementById('connectBtn');
const walletEl = document.getElementById('wallet');
const saveBtn = document.getElementById('saveBtn');
const mintBtn = document.getElementById('mintBtn');
const clearBtn = document.getElementById('clearBtn');
const refreshBtn = document.getElementById('refreshBtn');
const statusEl = document.getElementById('status');
const selectionPill = document.getElementById('selectionPill');
const ownedCountPill = document.getElementById('ownedCountPill');
const mintedCountPill = document.getElementById('mintedCountPill');
const cityLoadingEl = document.getElementById('cityLoading');
const roadNameInput = document.getElementById('roadNameInput');
const roadColorInput = document.getElementById('roadColorInput');
const leaderboardBody = document.getElementById('leaderboard-body');
function showLoading(text = 'Loading road data...') {
cityLoadingEl.querySelector('.text').textContent = text;
cityLoadingEl.style.display = 'inline-flex';
setTimeout(() => { if (cityLoadingEl.style.display !== 'none') hideLoading(); }, 20000);
}
function hideLoading() {
cityLoadingEl.style.display = 'none';
}
function setStatus(msg, type = '') {
if (!msg) {
statusEl.textContent = '';
statusEl.className = 'status';
return;
}
statusEl.className = 'status';
if (type === 'success') statusEl.classList.add('success');
if (type === 'error') statusEl.classList.add('error');
if (type === 'loading') {
statusEl.classList.add('loading');
statusEl.innerHTML = `<span class="spinner"></span><span>${msg}</span>`;
} else {
statusEl.textContent = msg;
}
}
function toFixed5(n) {
return (Math.round(n * 100000) / 100000).toFixed(5);
}
function escapeHTML(s) {
return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;');
}
function shortAddr(a) {
return a ? `${a.slice(0,6)}...${a.slice(-4)}` : '';
}
function radians(deg) {
return deg * Math.PI / 180;
}
function haversine(lon1, lat1, lon2, lat2) {
const R = 6371; // km
const dLat = radians(lat2 - lat1);
const dLon = radians(lon2 - lon1);
const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
Math.cos(radians(lat1)) * Math.cos(radians(lat2)) *
Math.sin(dLon / 2) * Math.sin(dLon / 2);
const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
return R * c;
}
function calculateLengthInKm(geojson) {
if (!geojson || geojson.type !== 'LineString' || !geojson.coordinates) return 0;
const coords = geojson.coordinates;
let dist = 0;
for (let i = 0; i < coords.length - 1; i++) {
dist += haversine(coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
}
return dist;
}
function initMap() {
if (!window.L) {
setStatus('Leaflet map library failed to load.', 'error');
return;
}
map = L.map('map', {
center: [20, 0],
zoom: 3,
zoomControl: true,
worldCopyJump: false,
maxBounds: [[-90, -180], [90, 180]],
minZoom: 2,
maxBoundsViscosity: 1.0
});
L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
maxZoom: 19,
attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
subdomains: 'abcd',
}).addTo(map);
roadLayerGroup = L.layerGroup().addTo(map);
drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);
drawControl = new L.Control.Draw({
draw: {
polyline: {
shapeOptions: {
color: '#0055ff',
weight: 5
}
},
polygon: false,
circle: false,
rectangle: false,
marker: false,
circlemarker: false
},
edit: {
featureGroup: drawnItems
}
});
map.addControl(drawControl);
map.on('draw:created', onDrawCreated);
map.on('draw:edited', onDrawEdited);
map.on('popupopen', onPopupOpen);
setTimeout(() => map.invalidateSize(), 300);
setStatus('Connect your wallet or draw a road on the map.');
}
function onDrawCreated(e) {
const layer = e.layer;
drawnItems.addLayer(layer);
selectRoad(layer.toGeoJSON().geometry, null);
}
function onDrawEdited(e) {
const layers = e.layers;
layers.eachLayer(function(layer) {
if (layer === selectionLayer) {
selected.geojson = layer.toGeoJSON().geometry;
selectRoad(selected.geojson, selected.fbKey);
}
});
}
async function switchToPolygon() {
if (!window.ethereum) return false;
try {
await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: POLYGON_PARAMS.chainId }] });
return true;
} catch (e) {
if (e.code === 4902) {
try {
await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [POLYGON_PARAMS] });
return true;
} catch {
setStatus('Failed to add Polygon network', 'error');
return false;
}
}
setStatus('Failed to switch network', 'error');
return false;
}
}
async function connectWallet() {
if (!window.ethereum) {
setStatus('Please install MetaMask to continue', 'error');
return;
}
try {
setStatus('Connecting wallet...', 'loading');
if (!await switchToPolygon()) return;
web3Provider = new ethers.providers.Web3Provider(window.ethereum);
await web3Provider.send('eth_requestAccounts', []);
signer = web3Provider.getSigner();
userAddress = await signer.getAddress();
connectBtn.disabled = true;
connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
walletEl.textContent = shortAddr(userAddress);
walletEl.style.display = 'inline-block';
await loadRoadSettings();
setStatus('Wallet connected.', 'success');
restyleAllRoads();
updateButtonsState();
if (window.ethereum?.on) {
window.ethereum.removeListener?.('accountsChanged', onAccountsChanged);
window.ethereum.on('accountsChanged', onAccountsChanged);
}
} catch (e) {
console.error(e);
setStatus('Wallet connection failed', 'error');
}
}
async function onAccountsChanged(accounts) {
userAddress = (accounts && accounts[0]) ? accounts[0] : null;
if (userAddress) {
walletEl.textContent = shortAddr(userAddress);
walletEl.style.display = 'inline-block';
connectBtn.disabled = true;
connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
await loadRoadSettings();
} else {
walletEl.style.display = 'none';
connectBtn.disabled = false;
connectBtn.innerHTML = '<span class="material-icons">account_balance_wallet</span>Connect';
}
restyleAllRoads();
updateButtonsState();
}
function buildRoadTokenURI(road, roadName, roadColor) {
const image = buildRoadSVG(road, roadName, roadColor);
const lengthKm = calculateLengthInKm(road);
const metadata = {
name: `Road: ${shortenName(roadName)}`,
description: `Digital road NFT. Type: LineString`,
image,
attributes: [
{ trait_type: "Length (km)", value: lengthKm.toFixed(2) },
{ trait_type: "Road Name", value: roadName },
{ trait_type: "Road Color", value: roadColor }
]
};
const json = JSON.stringify(metadata);
return "data:application/json;base64," + btoa(unescape(encodeURIComponent(json)));
}
function buildRoadSVG(road, roadName, roadColor) {
const name = escapeHTML(shortenName(roadName));
const length = calculateLengthInKm(road).toFixed(2);
const svg = `
<svg xmlns="http://www.w3.org/2000/svg" width="800" height="420" viewBox="0 0 800 420">
<defs>
<linearGradient id="bgGrad" x1="0%" y1="0%" x2="100%" y2="100%">
<stop offset="0%" stop-color="#070814" />
<stop offset="100%" stop-color="#12122a" />
</linearGradient>
<linearGradient id="titleGrad" x1="0%" y1="0%" x2="100%" y2="0%">
<stop offset="0%" stop-color="${roadColor}" />
<stop offset="100%" stop-color="#eef2ff" />
</linearGradient>
<filter id="glow">
<feGaussianBlur stdDeviation="3.5" result="blur" />
<feFlood flood-color="${roadColor}" flood-opacity="0.4" result="color" />
<feComposite in="color" in2="blur" operator="in" result="glow" />
<feMerge>
<feMergeNode in="glow" />
<feMergeNode in="SourceGraphic" />
</feMerge>
</filter>
<pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
<path d="M 40 0 L 0 0 0 40" fill="none" stroke="${roadColor}" stroke-width="0.5" opacity="0.2" />
</pattern>
</defs>
<rect width="800" height="420" fill="url(#bgGrad)" />
<rect width="800" height="420" fill="url(#grid)" />
<rect x="10" y="10" width="780" height="400" rx="15" fill="none" stroke="${roadColor}" stroke-width="2" filter="url(#glow)" />
<g font-family="'Orbitron', sans-serif">
<text x="40" y="80" font-size="28" font-weight="700" fill="url(#titleGrad)" filter="url(#glow)">
${name.toUpperCase()}
</text>
<text x="40" y="130" font-size="40" font-weight="900" fill="#eef2ff">${name}</text>
<text x="40" y="175" font-size="20" fill="#8f9cce">Length: ${length} km</text>
<g transform="translate(40,270)">
<rect width="280" height="60" rx="10" fill="none" stroke="${roadColor}" stroke-width="2" />
<rect x="1" y="1" width="278" height="58" rx="9" fill="${roadColor}1A" />
<text x="30" y="38" font-size="22" font-weight="700" fill="${roadColor}" filter="url(#glow)">DIGITAL ROAD</text>
</g>
</g>
</svg>`;
return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
}
async function mintSelectedRoad() {
try {
if (!userAddress) {
setStatus('Please connect your wallet first', 'error');
return;
}
if (!selected) {
setStatus('Draw a road on the map first', 'error');
return;
}
if (!selected.fbKey) {
setStatus('Please save the road first', 'error');
return;
}
if (roadDataById.get(selected.fbKey)?.tokenId) {
setStatus('This road is already minted', 'error');
return;
}
if (!roadName) {
setStatus('Please enter a Road Name before minting', 'error');
return;
}
setStatus('Submitting mint transaction...', 'loading');
const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
const tokenURI = buildRoadTokenURI(selected.geojson, roadName, roadColor);
const priceWei = ethers.utils.parseEther(currentMintPrice.toString());
const tx = await contract.mintWithURI(tokenURI, { value: priceWei });
setStatus('Transaction sent! Waiting for confirmation...', 'loading');
const receipt = await tx.wait();
const ev = receipt.events?.find(e => e.event === 'Transfer');
const mintedTokenId = ev?.args?.tokenId?.toString() || `temp-${Date.now()}`;
const fullRoadData = {
owner: userAddress,
meta: {
name: `Road: ${shortenName(roadName)}`,
description: `Digital road NFT. Length: ${selectedLengthKm.toFixed(2)} km`,
geojson: selected.geojson,
length_km: selectedLengthKm,
road_name: roadName,
road_color: roadColor,
demoPrice: calculateDemoPrice(selectedLengthKm),
tokenId: mintedTokenId
}
};
await fbDb.ref(`roads/${selected.fbKey}`).update({ owner: userAddress.toLowerCase(), 'meta/tokenId': mintedTokenId });
await saveRoadSettings();
if (selectionLayer) {
selectionLayer.bindPopup(`
<div style="min-width:250px;text-align:center;">
<div style="font-weight:800;margin:8px 0;color:${roadColor};font-family:'Orbitron',sans-serif;font-size:16px;text-shadow:0 0 8px ${roadColor}90;">ROAD MINTED!</div>
<div style="font-size:14px;margin:15px 0;color:#eef2ff;">${escapeHTML(shortenName(roadName))}</div>
<a href="https://opensea.io/assets/matic/$$ {CONTRACT_ADDRESS}/ $${mintedTokenId}" target="_blank" rel="noopener noreferrer" style="display:inline-block;background:${roadColor};color:#07061a;text-decoration:none;padding:8px 15px;border-radius:6px;font-weight:700;font-family:'Rajdhani',sans-serif;">View on OpenSea →</a>
</div>
`).openPopup();
}
setStatus('Success! Your road has been minted.', 'success');
updateButtonsState();
} catch (e) {
console.error("Minting failed:", e);
const msg = e?.data?.message || e?.reason || e?.message || 'Unknown transaction error.';
setStatus(`Minting failed: ${msg}`, 'error');
}
}
async function saveSelectedRoad() {
try {
if (!selected) {
setStatus('Draw a road on the map first', 'error');
return;
}
if (!roadName) {
setStatus('Please enter a Road Name before saving', 'error');
return;
}
setStatus('Saving road...', 'loading');
const roadData = {
owner: userAddress ? userAddress.toLowerCase() : null,
meta: {
name: `Road: ${shortenName(roadName)}`,
description: `Digital road. Length: ${selectedLengthKm.toFixed(2)} km`,
geojson: selected.geojson,
length_km: selectedLengthKm,
road_name: roadName,
road_color: roadColor,
demoPrice: calculateDemoPrice(selectedLengthKm)
}
};
let fbKey;
if (selected.fbKey) {
fbKey = selected.fbKey;
await fbDb.ref(`roads/${fbKey}`).set(roadData);
} else {
const ref = fbDb.ref('roads').push();
fbKey = ref.key;
await ref.set(roadData);
selected.fbKey = fbKey;
}
await saveRoadSettings();
setStatus('Road saved successfully.', 'success');
updateButtonsState();
} catch (e) {
console.error("Saving failed:", e);
setStatus('Saving failed.', 'error');
}
}
function initFirebase() {
try {
if (!window.firebase) throw new Error("Firebase script not loaded");
fbApp = firebase.initializeApp(firebaseConfig);
fbDb = firebase.database();
subscribeRoadsOnFirebase();
} catch (e) {
console.error('Firebase init failed', e);
setStatus("Could not connect to the database.", "error");
initialLoader.classList.add('hidden');
}
}
function subscribeRoadsOnFirebase() {
if (!fbDb) return;
allRoadsRef = fbDb.ref('roads');
allRoadsRef.once('value', (snapshot) => {
snapshot.forEach((childSnapshot) => {
upsertRoadOnMap(childSnapshot.key, childSnapshot.val());
});
initialLoader.classList.add('hidden');
}, (err) => {
console.error("Firebase initial read failed:", err);
setStatus("Cannot read road data. Check DB rules.", "error");
initialLoader.classList.add('hidden');
});
allRoadsRef.on('child_added', (snap) => upsertRoadOnMap(snap.key, snap.val()));
allRoadsRef.on('child_changed', (snap) => upsertRoadOnMap(snap.key, snap.val()));
allRoadsRef.on('child_removed', (snap) => removeRoadFromMap(snap.key, snap.val()));
}
function upsertRoadOnMap(roadId, data) {
if (!data || !data.meta) return;
const ownerLower = (data.owner || '').toLowerCase();
const isMine = userAddress && ownerLower === userAddress.toLowerCase();
const isMinted = !!data.meta.tokenId;
const lengthKm = data.meta.length_km || calculateLengthInKm(data.meta.geojson);
const fullRoadData = {
owner: ownerLower,
roadName: data.meta.road_name,
roadColor: data.meta.road_color,
geojson: data.meta.geojson,
name: data.meta.name,
demoPrice: data.meta.demoPrice || calculateDemoPrice(lengthKm),
lengthKm: lengthKm,
tokenId: data.meta.tokenId
};
roadDataById.set(roadId, fullRoadData);
const geojson = fullRoadData.geojson;
if (!geojson) return;
const prevLayer = roadLayersById.get(roadId);
if (prevLayer) {
roadLayerGroup.removeLayer(prevLayer);
}
try {
const geoLayer = L.geoJSON(geojson, {
style: () => roadStyle(isMinted, isMine, false, fullRoadData)
});
const rewards = lengthKm * 10000;
let popupHTML = `
<div style="min-width:220px;">
<div style="font-weight:800;margin-bottom:8px;font-family:'Orbitron',sans-serif;color:${fullRoadData.roadColor || '#ff2cf0'};font-size:15px;">
${escapeHTML(shortenName(fullRoadData.name))}
</div>
<div style="font-size:13px;color:#8f9cce;margin:4px 0;">Value: <span style="color:var(--success);font-weight:700;">${formatCurrency(fullRoadData.demoPrice)}</span></div>
<div style="font-size:13px;color:#8f9cce;margin:4px 0;">Length: <span style="color:var(--primary);font-weight:700;">${lengthKm.toFixed(2)} km</span></div>
<div style="font-size:13px;color:#8f9cce;margin:4px 0;">NFTFAN Rewards: <span style="color:var(--accent);font-weight:700;">${rewards.toLocaleString()} $NFTFAN</span></div>
<div style="font-size:13px;color:#8f9cce;margin:8px 0;">Road: <span style="color:#eef2ff;font-weight:bold;">${escapeHTML(fullRoadData.roadName)}</span></div>
<div style="font-size:12px;color:#8f9cce;margin:8px 0;">$$ {isMinted ? 'Minted by' : 'Saved by'}: <span style="color:#eef2ff"> $${shortAddr(data.owner)}</span></div>
<div style="font-size:11px;color:#5a5f8a;margin-top:10px;">ID: ${escapeHTML(roadId)}</div>
</div>`;
geoLayer.bindPopup(popupHTML);
geoLayer.addTo(roadLayerGroup);
roadLayersById.set(roadId, geoLayer);
} catch (e) {
console.error(`[upsert] Leaflet failed to draw geojson for ${roadId}.`, e, geojson);
}
updateCountsAndLeaderboard();
if (selected && selected.fbKey === roadId) {
selectRoad(selected.geojson, roadId);
}
}
function removeRoadFromMap(roadId, data) {
const prevLayer = roadLayersById.get(roadId);
if (prevLayer) roadLayerGroup.removeLayer(prevLayer);
roadLayersById.delete(roadId);
roadDataById.delete(roadId);
updateCountsAndLeaderboard();
}
function updateCountsAndLeaderboard() {
let myOwnedCount = 0;
const ownerValues = {};
const ownerLengths = {};
const ownerRewards = {};
if (userAddress) {
const userAddrLower = userAddress.toLowerCase();
for (const data of roadDataById.values()) {
if (data.owner === userAddrLower && data.tokenId) {
myOwnedCount++;
}
}
}
ownedCountPill.style.display = myOwnedCount > 0 ? 'inline-flex' : 'none';
ownedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;color:var(--success);">verified</span> You own: <strong style="margin-left:4px;color:var(--success);">${myOwnedCount}</strong>`;
const totalMinted = Array.from(roadDataById.values()).filter(d => d.tokenId).length;
mintedCountPill.style.display = 'inline-flex';
mintedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;">public</span> Total minted: <strong style="margin-left:4px;color:var(--primary);">${totalMinted}</strong>`;
for (const data of roadDataById.values()) {
if (data.owner && data.tokenId) {
ownerValues[data.owner] = (ownerValues[data.owner] || 0) + (data.demoPrice || 0);
ownerLengths[data.owner] = (ownerLengths[data.owner] || 0) + (data.lengthKm || 0);
ownerRewards[data.owner] = (ownerRewards[data.owner] || 0) + (data.lengthKm || 0) * 10000;
}
}
const sortedOwners = Object.entries(ownerValues)
.map(([owner, value]) => ({ owner, value, length: ownerLengths[owner], rewards: ownerRewards[owner] }))
.sort((a, b) => b.value - a.value);
renderLeaderboard(sortedOwners.slice(0, 10));
}
function clearSelection() {
selected = null;
drawnItems.clearLayers();
selectionLayer = null;
selectedLengthKm = 0;
currentMintPrice = 0;
selectionPill.style.display = 'none';
mintBtn.innerHTML = `<span class="material-icons">rocket_launch</span>Mint Road`;
updateButtonsState();
setStatus('Selection cleared. Draw a new road.', 'success');
}
function restyleAllRoads() {
for (const [roadId, geoLayer] of roadLayersById.entries()) {
const data = roadDataById.get(roadId) || {};
const isMine = userAddress && data.owner === userAddress.toLowerCase();
const isMinted = !!data.tokenId;
geoLayer.setStyle(roadStyle(isMinted, isMine, false, data));
}
updateCountsAndLeaderboard();
}
async function saveRoadSettings() {
if (!fbDb || !userAddress) return;
await fbDb.ref(`settings/${userAddress.toLowerCase()}`).set({ name: roadName, color: roadColor });
}
async function loadRoadSettings() {
if (!fbDb || !userAddress) return;
const snapshot = await fbDb.ref(`settings/${userAddress.toLowerCase()}`).get();
if (snapshot.exists()) {
const data = snapshot.val();
roadNameInput.value = data.name || '';
roadColorInput.value = data.color || '#00f9ff';
}
updateRoadState();
}
function updateRoadState() {
roadName = roadNameInput.value.trim();
roadColor = roadColorInput.value;
if (selectionLayer) {
selectionLayer.setStyle(roadStyle(false, false, true, { roadColor }));
}
updateButtonsState();
}
function updateButtonsState() {
const hasSelected = !!selected;
const isSaved = !!selected?.fbKey;
const data = isSaved ? roadDataById.get(selected.fbKey) : null;
const isMinted = data ? !!data.tokenId : false;
saveBtn.disabled = !hasSelected || !roadName;
mintBtn.disabled = !userAddress || !hasSelected || !isSaved || isMinted || !roadName;
}
function roadStyle(isMinted, isMine, isSelected, ownerData = {}) {
let color = '#3a3f6d';
let weight = 3;
let opacity = 0.7;
let dashArray = '3';
if (isMinted) {
color = ownerData.roadColor || '#ff2cf0';
weight = 4;
dashArray = undefined;
}
if (isMine) {
color = ownerData.roadColor || '#12ff9b';
}
if (isSelected && !isMinted) {
color = ownerData.roadColor || '#0055ff';
weight = 5;
opacity = 1;
dashArray = undefined;
}
return { color, weight, opacity, dashArray };
}
function shortenName(name) {
const n = String(name || '');
if (n.length <= 60) return n;
const firstComma = n.indexOf(',');
return (firstComma > 0) ? n.slice(0, firstComma) + '…' : n.slice(0, 57) + '…';
}
function selectRoad(geojson, fbKey) {
clearSelection();
selected = { geojson, fbKey };
const data = fbKey ? roadDataById.get(fbKey) : null;
const isMinted = data ? !!data.tokenId : false;
const ownerData = data || {};
const isMine = userAddress && ownerData.owner === userAddress.toLowerCase();
selectedLengthKm = calculateLengthInKm(geojson);
currentMintPrice = (selectedLengthKm / 10000).toFixed(4);
selectionLayer = L.geoJSON(geojson, { style: () => roadStyle(isMinted, isMine, true, ownerData) }).addTo(map);
const bounds = selectionLayer.getBounds();
if (bounds.isValid()) {
map.fitBounds(bounds, { padding: [50, 50], maxZoom: 14 });
}
const popupColor = isMine ? (ownerData.roadColor || '#12ff9b') : isMinted ? (ownerData.roadColor || '#ff2cf0') : '#00f9ff';
const statusText = isMine ? '✓ You own this road' : isMinted ? `⚠ Minted by ${ownerData.roadName || 'another user'}` : '✦ Available for minting';
const rewards = selectedLengthKm * 10000;
let popupHTML = `
<div style="min-width:250px;">
<div style="font-weight:800;margin-bottom:8px;font-family:'Orbitron',sans-serif;color:${popupColor};text-shadow:0 0 5px $$ {popupColor}80;font-size:15px;"> $${escapeHTML(shortenName(roadName))}</div>
<div style="font-size:13px;color:#8f9cce;margin:4px 0;">Value: <span style="color:var(--success);font-weight:700;">${formatCurrency(calculateDemoPrice(selectedLengthKm))}</span></div>
<div style="font-size:13px;color:#8f9cce;margin:4px 0;">Length: <span style="color:var(--primary);font-weight:700;">${selectedLengthKm.toFixed(2)} km</span></div>
<div style="font-size:13px;color:#8f9cce;margin:4px 0;">NFTFAN Rewards: <span style="color:var(--accent);font-weight:700;">${rewards.toLocaleString()} $NFTFAN</span></div>
<div style="font-size:13px;color:#eef2ff;margin-top:10px;padding:6px 10px;border-radius:6px;background:rgba(0,0,0,0.2);border-left:3px solid $$ {popupColor}"> $${statusText}</div>
`;
if (!isMinted && !isMine) {
popupHTML += `<div style="font-size:13px;color:#8f9cce;margin:4px 0;">Mint Cost: <span style="color:var(--success);font-weight:700;">${currentMintPrice} POL</span></div>`;
}
popupHTML += `
<div style="font-size:11px;color:#5a5f8a;margin-top:10px;">ID: ${escapeHTML(fbKey || 'unsaved')}</div>
</div>
`;
selectionLayer.bindPopup(popupHTML).openPopup();
selectionPill.style.display = 'inline-flex';
selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">${isMine ? 'verified' : isMinted ? 'gavel' : 'timeline'}</span> ${escapeHTML(shortenName(roadName))} · ${selectedLengthKm.toFixed(2)} km · <span style="color:${popupColor};">${isMine ? 'You own' : isMinted ? 'Minted' : 'Available'}</span>`;
updateButtonsState();
if (!isMinted) {
mintBtn.innerHTML = `<span class="material-icons">rocket_launch</span>Mint for ${currentMintPrice} POL`;
setStatus(`Road selected. Mint price: ${currentMintPrice} POL. Rewards: ${rewards.toLocaleString()} $NFTFAN tokens.`, 'success');
}
}
function onPopupOpen(e) {
// No mint inside, so no button
}
// --- Pricing and Leaderboard ---
function calculateDemoPrice(length) {
const logLength = Math.log10(Math.max(1e-3, length));
const minLogLength = -1; // 0.1 km
const maxLogLength = 4; // 10000 km
const normalized = Math.max(0, Math.min(1, (logLength - minLogLength) / (maxLogLength - minLogLength)));
const minPrice = 1_000_000;
const maxPrice = 1_000_000_000_000_000;
const price = minPrice * Math.pow(maxPrice / minPrice, 1 - Math.pow(1 - normalized, 3));
return Math.round(price);
}
function formatCurrency(num) {
if (num >= 1e15) return `$${(num / 1e15).toFixed(2)}Q`;
if (num >= 1e12) return `$${(num / 1e12).toFixed(2)}T`;
if (num >= 1e9) return `$${(num / 1e9).toFixed(2)}B`;
if (num >= 1e6) return `$${(num / 1e6).toFixed(2)}M`;
if (num >= 1e3) return `$${(num / 1e3).toFixed(2)}K`;
return `$${num.toLocaleString()}`;
}
function renderLeaderboard(sortedOwners) {
leaderboardBody.innerHTML = '';
if (sortedOwners.length === 0) {
leaderboardBody.innerHTML = '<tr><td colspan="5" style="text-align:center;color:var(--muted);padding:20px;">No roads minted yet.</td></tr>';
return;
}
sortedOwners.forEach((entry, index) => {
const row = document.createElement('tr');
row.innerHTML = `
<td class="rank">${index + 1}</td>
<td class="owner">${shortAddr(entry.owner)}</td>
<td class="value">${formatCurrency(entry.value)}</td>
<td class="length">${entry.length.toFixed(2)}</td>
<td class="rewards">${entry.rewards.toLocaleString()} $NFTFAN</td>
`;
leaderboardBody.appendChild(row);
});
}
// Event listeners
connectBtn.addEventListener('click', connectWallet);
saveBtn.addEventListener('click', saveSelectedRoad);
mintBtn.addEventListener('click', mintSelectedRoad);
clearBtn.addEventListener('click', clearSelection);
refreshBtn.addEventListener('click', () => {
setStatus("Refreshing data is now automatic. Manual refresh disabled.", "error");
});
roadNameInput.addEventListener('input', updateRoadState);
roadColorInput.addEventListener('input', updateRoadState);
window.addEventListener('DOMContentLoaded', () => {
initMap();
initFirebase();
});
</script>
</body>
</html>
