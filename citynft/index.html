<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CyberTerritories â€” Mint your digital land</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Firebase (compat SDK) -->
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>
  <style>
    :root {
      --primary: #00f9ff;
      --primary-glow: rgba(0, 249, 255, 0.5);
      --primary-dark: #00b2ff;
      --accent: #ff2cf0;
      --accent-glow: rgba(255, 44, 240, 0.5);
      --success: #12ff9b;
      --success-glow: rgba(18, 255, 155, 0.4);
      --error: #ff3860;
      --error-glow: rgba(255, 56, 96, 0.4);
      --bg: #0c0b1d;
      --bg-dark: #07061a;
      --card: #12122a;
      --text: #eef2ff;
      --muted: #8f9cce;
      --border: #3e3f82;
      --border-glow: rgba(0, 249, 255, 0.2);
      --radius: 12px;
      --shadow: rgba(0, 0, 0, 0.4);
      --neon-shadow: 0 0 10px var(--primary-glow);
      --accent-shadow: 0 0 10px var(--accent-glow);
    }

    * { box-sizing: border-box; }
    
    html, body { 
      height: 100%; 
      scroll-behavior: smooth; 
      overscroll-behavior: none; 
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      margin: 0;
      font-family: 'Rajdhani', sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      line-height: 1.4;
      overflow-x: hidden;
      letter-spacing: 0.2px;
      font-weight: 500;
    }

    #app-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      background: radial-gradient(800px at 15% 15%, rgba(0, 249, 255, 0.08), transparent 70%),
                  radial-gradient(600px at 85% 20%, rgba(255, 44, 240, 0.08), transparent 70%),
                  linear-gradient(180deg, var(--bg-dark), var(--bg));
    }

    /* Cyberpunk animated background grid */
    .cyber-grid {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -1;
      background-image: 
        linear-gradient(rgba(0, 249, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 249, 255, 0.03) 1px, transparent 1px);
      background-size: 40px 40px;
      background-position: center center;
      perspective: 1000px;
      transform-style: preserve-3d;
      animation: gridPulse 20s infinite linear;
    }
    
    @keyframes gridPulse {
      0% { background-size: 40px 40px; }
      50% { background-size: 42px 42px; }
      100% { background-size: 40px 40px; }
    }

    /* Header */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      position: relative;
      z-index: 10;
    }

    .brand { 
      display: flex; 
      align-items: center; 
      gap: 12px; 
    }
    
    .logo {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      display: grid;
      place-items: center;
      box-shadow: 0 0 15px rgba(0, 249, 255, 0.4);
      position: relative;
      overflow: hidden;
    }
    
    .logo::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(transparent, var(--primary), transparent 30%);
      animation: rotate 4s linear infinite;
    }
    
    .logo::after {
      content: '';
      position: absolute;
      inset: 3px;
      border-radius: 6px;
      background: var(--bg-dark);
    }
    
    .logo .material-icons { 
      font-size: 22px;
      color: var(--primary);
      position: relative;
      z-index: 2;
      text-shadow: 0 0 8px var(--primary-glow);
    }

    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .title h1 { 
      margin: 0;
      font-size: 24px;
      font-weight: 700;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 5px rgba(0, 249, 255, 0.3);
    }
    
    .title p { 
      margin: 0;
      font-size: 14px;
      color: var(--muted);
    }

    .actions { 
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    /* Buttons */
    button {
      appearance: none;
      border: 1px solid transparent;
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 14px;
      font-weight: 600;
      font-family: 'Rajdhani', sans-serif;
      color: var(--text);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(32, 33, 77, 0.6);
      border-color: var(--border);
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    button::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: 0.5s;
    }
    
    button:hover::after {
      left: 100%;
    }
    
    button .material-icons { font-size: 18px; }
    
    button.primary { 
      background: linear-gradient(135deg, var(--primary-dark), var(--primary));
      border-color: var(--primary);
      box-shadow: 0 0 10px var(--primary-glow);
      text-shadow: 0 0 5px var(--primary);
    }
    
    button.success { 
      background: linear-gradient(135deg, var(--success), #00ddb9);
      border-color: var(--success);
      box-shadow: 0 0 10px var(--success-glow);
      color: #07172c;
      font-weight: 700;
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
    }
    
    button.accent { 
      background: linear-gradient(135deg, var(--accent), #ff6afc);
      border-color: var(--accent);
      box-shadow: 0 0 10px var(--accent-glow);
      color: #07172c;
      font-weight: 700;
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
    }
    
    button:disabled { 
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none;
    }
    
    button:not(:disabled):active { 
      transform: translateY(1px) scale(0.98);
    }

    .wallet { 
      color: var(--primary);
      font-size: 14px;
      font-weight: 700;
      text-shadow: 0 0 5px var(--primary-glow);
      background: rgba(0, 249, 255, 0.1);
      padding: 4px 10px;
      border-radius: 8px;
      border: 1px solid rgba(0, 249, 255, 0.3);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(15, 16, 40, 0.7);
      color: var(--muted);
      backdrop-filter: blur(5px);
    }
    
    .pill .material-icons {
      font-size: 16px;
      color: var(--primary);
    }

    /* Main content */
    main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      padding: 0 16px 16px;
      flex: 1;
    }
    
    @media (min-width: 980px) {
      main {
        grid-template-columns: 1.6fr 1fr;
        max-width: 1440px;
        margin: 0 auto;
        width: 100%;
      }
    }

    /* Map container with neon border glow */
    .map-container {
      position: relative;
      width: 100%;
      height: 70vh;
      border-radius: var(--radius);
      grid-column: 1 / -1;
      overflow: hidden;
      background: var(--card);
      padding: 2px;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      box-shadow: 0 0 25px rgba(0, 0, 0, 0.5),
                 0 0 15px var(--primary-glow);
    }
    
    #map {
      height: 100%;
      width: 100%;
      border-radius: calc(var(--radius) - 2px);
      overflow: hidden;
      background: #070814;
    }
    
    /* Custom map attribution style */
    .leaflet-control-attribution {
      background: rgba(7, 8, 30, 0.7) !important;
      color: var(--muted) !important;
      font-family: 'Rajdhani', sans-serif;
      font-size: 10px;
      backdrop-filter: blur(5px);
      border-radius: 4px !important;
      padding: 2px 5px !important;
    }
    
    .leaflet-control-attribution a {
      color: var(--primary) !important;
    }
    
    /* Custom zoom control style */
    .leaflet-control-zoom {
      border: none !important;
      border-radius: 8px !important;
      overflow: hidden;
    }
    
    .leaflet-control-zoom a {
      background: rgba(15, 16, 40, 0.9) !important;
      color: var(--primary) !important;
      border: 1px solid var(--border) !important;
      transition: all 0.2s ease !important;
    }
    
    .leaflet-control-zoom a:hover {
      background: rgba(30, 31, 70, 0.9) !important;
      color: var(--text) !important;
    }

    /* Map popup style */
    .leaflet-popup-content-wrapper {
      background: rgba(15, 16, 40, 0.95) !important;
      border-radius: 10px !important;
      border: 1px solid var(--border) !important;
      backdrop-filter: blur(10px) !important;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.5) !important;
    }
    
    .leaflet-popup-content {
      color: var(--text) !important;
      font-family: 'Rajdhani', sans-serif !important;
      margin: 12px 16px !important;
    }
    
    .leaflet-popup-tip {
      background: rgba(15, 16, 40, 0.95) !important;
      border: 1px solid var(--border) !important;
    }
    
    .leaflet-popup-close-button {
      color: var(--primary) !important;
    }

    /* Info panel */
    .panel {
      background: rgba(18, 18, 42, 0.75);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      display: grid;
      gap: 16px;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 25px var(--shadow);
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .panel::after {
      content: '';
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--primary), var(--accent), transparent);
      z-index: 2;
      box-shadow: 0 0 15px var(--primary-glow);
    }
    
    .row { 
      display: grid;
      gap: 12px;
    }
    
    .row.inline { 
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(62, 63, 130, 0.3);
    }
    
    .panel-header h2 {
      margin: 0;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      color: var(--primary);
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 5px var(--primary-glow);
    }

    /* Legend */
    .legend {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 14px;
      color: var(--muted);
    }
    
    .legend .key { 
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    
    .legend .box { 
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
    }
    
    /* Status indicator */
    .status {
      min-height: 46px;
      display: grid;
      place-items: center;
      text-align: center;
      font-size: 14px;
      border-radius: 8px;
      padding: 12px;
      background: rgba(8, 9, 33, 0.5);
      border: 1px solid rgba(62, 63, 130, 0.3);
      color: var(--muted);
    }
    
    .status.success { 
      background: rgba(18, 255, 155, 0.07);
      color: var(--success);
      border-color: rgba(18, 255, 155, 0.25);
      box-shadow: 0 0 10px rgba(18, 255, 155, 0.1);
    }
    
    .status.error { 
      background: rgba(255, 56, 96, 0.07);
      color: var(--error);
      border-color: rgba(255, 56, 96, 0.25);
      box-shadow: 0 0 10px rgba(255, 56, 96, 0.1);
    }
    
    .status.loading { 
      display: inline-flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
    }
    
    .spinner {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-left-color: var(--primary);
      animation: spin 1s linear infinite;
      box-shadow: 0 0 10px var(--primary-glow);
    }
    
    @keyframes spin { 
      to { transform: rotate(360deg); }
    }

    /* Toast notifications */
    .toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      background: rgba(12, 13, 38, 0.9);
      color: var(--text);
      border-left: 3px solid var(--primary);
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3),
                 0 0 10px var(--primary-glow);
      z-index: 9999;
      font-size: 14px;
      backdrop-filter: blur(10px);
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -10px); }
      to { opacity: 1; transform: translate(-50%, 0); }
    }
    
    .toast .spinner { 
      width: 18px;
      height: 18px;
      border-width: 2px;
    }
    
    .toast .material-icons { 
      font-size: 20px;
      color: var(--primary);
      text-shadow: 0 0 5px var(--primary-glow);
    }

    /* Form inputs */
    .form-group {
      display: grid;
      gap: 6px;
    }

    .form-group label {
      font-size: 14px;
      font-weight: 600;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .form-group input[type="text"],
    .form-group input[type="color"] {
      font-family: 'Rajdhani', sans-serif;
      font-size: 16px;
      color: var(--text);
      background: rgba(8, 9, 33, 0.5);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 12px;
      transition: all 0.2s ease;
    }

    .form-group input[type="text"]:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 8px var(--primary-glow);
    }
    
    .form-group input[type="color"] {
      padding: 4px 8px;
      height: 40px;
      cursor: pointer;
    }

    /* Mobile optimizations */
    @media (max-width: 640px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
      
      .actions {
        width: 100%;
        justify-content: space-between;
      }
      
      main {
        padding: 0 12px 12px;
        gap: 12px;
      }
      
      .map-container {
        height: 60vh;
      }
      
      button {
        padding: 8px 12px;
        font-size: 13px;
      }
      
      .panel {
        padding: 12px;
      }
      
      .legend {
        font-size: 12px;
        gap: 10px;
      }
      
      .status {
        font-size: 13px;
        padding: 10px;
        min-height: 42px;
      }
    }

    /* Cyberpunk glitch effect for headings */
    @keyframes glitch {
      0% { transform: translate(0); }
      20% { transform: translate(-2px, 1px); }
      40% { transform: translate(-2px, -1px); }
      60% { transform: translate(2px, 1px); }
      80% { transform: translate(2px, -1px); }
      100% { transform: translate(0); }
    }
    
    .glitch-text {
      position: relative;
      display: inline-block;
    }
    
    .glitch-text:hover::before,
    .glitch-text:hover::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .glitch-text:hover::before {
      animation: glitch 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) both infinite;
      text-shadow: 0 0 5px var(--primary-glow);
      clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
      transform: translate(-2px, -2px);
    }
    
    .glitch-text:hover::after {
      animation: glitch 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) reverse both infinite;
      text-shadow: 0 0 5px var(--accent-glow);
      clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
      transform: translate(2px, 2px);
    }
  </style>
</head>
<body>
  <div id="app-container">
    <div class="cyber-grid"></div>
    <header>
      <div class="brand">
        <div class="logo"><span class="material-icons">language</span></div>
        <div class="title">
          <h1 class="glitch-text" data-text="CyberTerritories">CyberTerritories</h1>
          <p>Mint your digital land in the metaverse</p>
        </div>
      </div>
      <div class="actions">
        <span class="pill">
          <span class="material-icons">paid</span> 
          <span>Mint Price: <strong style="margin-left:4px;color:var(--primary);">1 MATIC</strong></span>
        </span>
        <button id="connectBtn" class="primary">
          <span class="material-icons">account_balance_wallet</span>Connect
        </button>
        <span id="wallet" class="wallet"></span>
      </div>
    </header>

    <main>
      <div class="map-container">
        <div id="map" aria-label="Map"></div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <h2>Territory Control</h2>
        </div>
        
        <div class="row">
          <div class="legend">
            <div class="key"><span class="box" style="background:#191d3b;box-shadow:0 0 3px rgba(0,249,255,0.2);"></span> Not selected</div>
            <div class="key"><span class="box" style="background:#0055ff;box-shadow:0 0 5px #0055ff;"></span> Selected</div>
            <div class="key"><span class="box" style="background:#ff2cf0;box-shadow:0 0 5px rgba(255,44,240,0.5);"></span> Minted (by other)</div>
            <div class="key"><span class="box" style="background:#12ff9b;box-shadow:0 0 5px rgba(18,255,155,0.5);"></span> Minted (by you)</div>
          </div>
        </div>

        <div class="row" style="grid-template-columns: 1fr 100px; gap: 10px;">
            <div class="form-group">
                <label for="empireNameInput">Empire Name</label>
                <input type="text" id="empireNameInput" placeholder="e.g. The Void Syndicate" maxlength="32" />
            </div>
            <div class="form-group">
                <label for="empireColorInput">Empire Color</label>
                <input type="color" id="empireColorInput" value="#00f9ff" />
            </div>
        </div>

        <div class="row inline">
          <span id="selectionPill" class="pill" style="display:none;"></span>
          <span id="ownedCountPill" class="pill" style="display:none;"></span>
          <span id="mintedCountPill" class="pill" style="display:none;"></span>
        </div>

        <div class="row inline">
          <button id="mintBtn" class="success" disabled>
            <span class="material-icons">rocket_launch</span>Mint Territory
          </button>
          <button id="clearBtn" class="accent">
            <span class="material-icons">delete_sweep</span>Clear
          </button>
          <button id="refreshBtn">
            <span class="material-icons">refresh</span>Refresh
          </button>
        </div>

        <div id="status" class="status">Select a territory on the map to claim it</div>
      </div>
    </main>
  </div>

  <!-- Loading toast -->
  <div id="cityLoading" class="toast" role="status" aria-live="assertive" aria-atomic="true">
    <span class="spinner" aria-hidden="true"></span>
    <span class="material-icons" aria-hidden="true">location_city</span>
    <span class="text">Loading territory data...</span>
  </div>

  <script>
    // Polygon Mainnet
    const POLYGON_PARAMS = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com/'],
      blockExplorerUrls: ['https://polygonscan.com/']
    };

    // Contract
    const CONTRACT_ADDRESS = "0xb7d9E197905A0Fe7A59d82029eEFCBfDa631E2CC";
    const CONTRACT_ABI = [
      "function mintWithURI(string tokenURI) external payable returns (uint256)",
      "function mintPrice() view returns (uint256)",
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"
    ];
    const START_BLOCK = 0;

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyC6wYBu-KOXkDmB-84_7OPtY71zBX4FzRY",
      authDomain: "newnft-47bd7.firebaseapp.com",
      databaseURL: "https://newnft-47bd7-default-rtdb.firebaseio.com",
      projectId: "newnft-47bd7",
      storageBucket: "newnft-47bd7.firebasestorage.app",
      messagingSenderId: "172043823738",
      appId: "1:172043823738:web:daf1fcfb7862d7d8f029c3",
      measurementId: "G-8VB3DYRNXR"
    };

    // Map / state
    let map;
    let selectionLayer; // L.GeoJSON for selected area
    let selected = null; // { id, name, type, center, geojson }
    let mintedAreaIds = new Set(); // all minted area ids
    let myOwnedAreaIds = new Set(); // area ids I own
    let isCityLoading = false;

    // Layers for minted NFTs on map
    let mintedLayerGroup; // L.LayerGroup
    const mintedLayersByAreaId = new Map(); // areaId -> L.GeoJSON
    const areaDataByAreaId = new Map(); // areaId -> { owner, empireName, empireColor }

    // Ethers
    let web3Provider, readProvider, signer, userAddress;
    let empireName = '', empireColor = '#00f9ff';

    // Firebase
    let fbApp, fbDb;
    let allNftsRef = null;

    // UI
    const connectBtn = document.getElementById('connectBtn');
    const walletEl = document.getElementById('wallet');
    const mintBtn = document.getElementById('mintBtn');
    const clearBtn = document.getElementById('clearBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const statusEl = document.getElementById('status');
    const selectionPill = document.getElementById('selectionPill');
    const ownedCountPill = document.getElementById('ownedCountPill');
    const mintedCountPill = document.getElementById('mintedCountPill');
    const cityLoadingEl = document.getElementById('cityLoading');
    const empireNameInput = document.getElementById('empireNameInput');
    const empireColorInput = document.getElementById('empireColorInput');

    function showCityLoading(text = 'Loading territory data...') {
      cityLoadingEl.querySelector('.text').textContent = text;
      cityLoadingEl.style.display = 'inline-flex';
      setTimeout(() => {
        if (cityLoadingEl.style.display !== 'none') {
          hideCityLoading();
        }
      }, 20000); // Safety timeout to hide toast if loading takes too long
    }
    
    function hideCityLoading() {
      cityLoadingEl.style.display = 'none';
    }

    function setStatus(msg, type = '') {
      if (!msg) {
        statusEl.textContent = '';
        statusEl.className = 'status';
        return;
      }
      statusEl.className = 'status';
      if (type === 'success') statusEl.classList.add('success');
      if (type === 'error') statusEl.classList.add('error');
      if (type === 'loading') {
        statusEl.classList.add('loading');
        statusEl.innerHTML = `<span class="spinner"></span><span>${msg}</span>`;
      } else {
        statusEl.textContent = msg;
      }
    }
    
    function toFixed5(n) { return (Math.round(n * 100000) / 100000).toFixed(5); }
    function escapeHTML(s) { return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }
    function shortAddr(a) { return a ? `${a.slice(0,6)}...${a.slice(-4)}` : ''; }

    function initMap() {
      if (!window.L) { 
        setStatus('Leaflet map library failed to load.', 'error');
        return;
      }
      
      map = L.map('map', {
        center: [20, 0],
        zoom: 3,
        zoomControl: true,
        worldCopyJump: false,
        maxBounds: [[-90, -180], [90, 180]],
        minZoom: 2,
        maxBoundsViscosity: 1.0
      });

      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        subdomains: 'abcd',
      }).addTo(map);

      mintedLayerGroup = L.layerGroup().addTo(map);
      map.on('click', onMapClick);
      setTimeout(() => map.invalidateSize(), 300);
      setStatus('Click on the map to select a territory', 'success');
    }

    async function onMapClick(e) {
      if (isCityLoading) return;
      
      const { lat, lng } = e.latlng;
      try {
        isCityLoading = true;
        showCityLoading('Loading territory data...');
        setStatus('Looking up territory for this location...', 'loading');

        const area = await reverseGeocodeWithPolygon(lat, lng);

        if (!area) {
          setStatus('No polygon found here. Try clicking closer to a city center or administrative area.', 'error');
          return;
        }
        
        selectArea(area);
        setStatus('Territory selected. You can mint it now.', 'success');
      } catch (err) {
        console.error(err);
        setStatus('Territory lookup failed. Please try again.', 'error');
      } finally {
        isCityLoading = false;
        hideCityLoading();
      }
    }

    async function reverseGeocodeWithPolygon(lat, lng) {
      const z = map.getZoom();
      let zoomParam = (z >= 14) ? 14 : (z >= 12) ? 12 : (z >= 10) ? 10 : (z >= 7) ? 8 : 5;

      const url = new URL('https://nominatim.openstreetmap.org/reverse');
      url.searchParams.set('format', 'jsonv2');
      url.searchParams.set('lat', lat);
      url.searchParams.set('lon', lng);
      url.searchParams.set('zoom', zoomParam);
      url.searchParams.set('polygon_geojson', '1');
      url.searchParams.set('addressdetails', '1');

      const res = await fetch(url.toString(), { 
        headers: { 'Accept-Language': 'en', 'User-Agent': 'CyberTerritories/1.0' } 
      });
      
      if (!res.ok) throw new Error('Nominatim reverse geocoding failed');
      const data = await res.json();

      const geojson = data.geojson || data.geometry;
      if (!geojson || !geojson.type || !geojson.coordinates) return null;

      const { osm_id, osm_type, display_name, class: cls, type: typ, lat: data_lat, lon: data_lon } = data;
      const center = { lat: Number(data_lat), lng: Number(data_lon) };
      const id = makeAreaId(osm_type, osm_id);
      
      return { id, name: display_name || 'Unknown area', type: `${cls}:${typ}`, center, geojson };
    }

    function makeAreaId(osmType, osmId) {
      return `osm:${(osmType || '').toLowerCase()}:${osmId}`;
    }

    function areaStyle(isMinted, isMine, isSelected, ownerData = {}) {
      let fill = '#191d3b';
      let weight = 1.5;
      let opacity = 0.7;
      let fillOpacity = 0.5;
      
      if (isMinted) {
        fill = ownerData.empireColor || '#ff2cf0'; // Use empire color, fallback to pink
        weight = 2;
      }
      
      if (isMine) {
        fill = ownerData.empireColor || '#12ff9b'; // Use empire color, fallback to green
        weight = 2;
      }
      
      if (isSelected && !isMinted && !isMine) {
        fill = '#0055ff'; // bright blue
        weight = 2.5;
        opacity = 1;
        fillOpacity = 0.6;
      }
      
      return { 
        color: '#3a3f6d', weight, opacity, fillColor: fill, fillOpacity,
        dashArray: isSelected ? undefined : '3',
      };
    }

    function shortenName(name) {
      const n = String(name || '');
      if (n.length <= 60) return n;
      const firstComma = n.indexOf(',');
      return (firstComma > 0) ? n.slice(0, firstComma) + 'â€¦' : n.slice(0, 57) + 'â€¦';
    }

    function selectArea(area) {
      selected = area;
      if (selectionLayer) selectionLayer.remove();
      
      const isMinted = mintedAreaIds.has(area.id);
      const isMine = myOwnedAreaIds.has(area.id);
      const ownerData = areaDataByAreaId.get(area.id) || {};

      selectionLayer = L.geoJSON(area.geojson, { 
        style: () => areaStyle(isMinted, isMine, true, ownerData) 
      }).addTo(map);

      const bounds = selectionLayer.getBounds();
      map.fitBounds(bounds.isValid() ? bounds : map.getBounds(), { padding: [16, 16], maxZoom: 14 });

      const popupColor = isMine ? (ownerData.empireColor || '#12ff9b') : isMinted ? (ownerData.empireColor || '#ff2cf0') : '#00f9ff';
      const statusText = isMine ? 'âœ“ You own this territory' : isMinted ? `âš  Minted by ${ownerData.empireName || 'another user'}` : 'âœ¦ Available for minting';
      
      selectionLayer.bindPopup(`
        <div style="min-width:250px;">
          <div style="font-weight:800;margin-bottom:8px;font-family:'Orbitron',sans-serif;color:${popupColor};text-shadow:0 0 5px ${popupColor}80;font-size:15px;">${escapeHTML(shortenName(area.name))}</div>
          <div style="font-size:13px;color:#8f9cce;margin:8px 0;">Center: <span style="color:#eef2ff">${toFixed5(area.center.lat)}, ${toFixed5(area.center.lng)}</span></div>
          <div style="font-size:13px;color:#eef2ff;margin-top:10px;padding:6px 10px;border-radius:6px;background:rgba(0,0,0,0.2);border-left:3px solid ${popupColor}">${statusText}</div>
          <div style="font-size:11px;color:#5a5f8a;margin-top:10px;">ID: ${escapeHTML(area.id)}</div>
        </div>
      `).openPopup();

      selectionPill.style.display = 'inline-flex';
      selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">${isMine ? 'verified' : isMinted ? 'gavel' : 'place'}</span> ${escapeHTML(shortenName(area.name))} Â· <span style="color:${popupColor};">${isMine ? 'You own' : isMinted ? 'Minted' : 'Available'}</span>`;
      
      updateMintButtonState();
    }

    async function switchToPolygon() {
      if (!window.ethereum) return false;
      try {
        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: POLYGON_PARAMS.chainId }] });
        return true;
      } catch (e) {
        if (e.code === 4902) {
          try {
            await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [POLYGON_PARAMS] });
            return true;
          } catch { setStatus('Failed to add Polygon network', 'error'); return false; }
        }
        setStatus('Failed to switch network', 'error');
        return false;
      }
    }

    async function connectWallet() {
      if (!window.ethereum) { setStatus('Please install MetaMask to continue', 'error'); return; }
      
      try {
        setStatus('Connecting wallet...', 'loading');
        if (!await switchToPolygon()) return;

        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        await web3Provider.send('eth_requestAccounts', []);
        signer = web3Provider.getSigner();
        userAddress = await signer.getAddress();

        connectBtn.disabled = true;
        connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
        walletEl.textContent = shortAddr(userAddress);

        readProvider = new ethers.providers.JsonRpcProvider(POLYGON_PARAMS.rpcUrls[0]);
        
        await loadEmpireSettings();
        setStatus('Wallet connected. Loading minted territories...', 'loading');
        await refreshMinted(true);

        restyleAllMintedPolygons();
        updateMintButtonState();

        if (window.ethereum?.on) {
          window.ethereum.removeListener?.('accountsChanged', onAccountsChanged);
          window.ethereum.on('accountsChanged', onAccountsChanged);
        }
      } catch (e) {
        console.error(e);
        setStatus('Wallet connection failed', 'error');
      }
    }

    async function onAccountsChanged(accounts) {
      userAddress = (accounts && accounts[0]) ? accounts[0] : null;
      if (userAddress) {
        walletEl.textContent = shortAddr(userAddress);
        connectBtn.disabled = true;
        connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
        await loadEmpireSettings();
        recomputeMyOwnershipFromData();
        restyleAllMintedPolygons();
      } else {
        walletEl.textContent = '';
        connectBtn.disabled = false;
        connectBtn.innerHTML = '<span class="material-icons">account_balance_wallet</span>Connect';
        myOwnedAreaIds.clear();
        restyleAllMintedPolygons();
      }
      updateMintButtonState();
    }

    function buildAreaTokenURI(area, empireName, empireColor) {
      const image = buildAreaSVG(area, empireName, empireColor);
      const metadata = {
        name: `Territory: ${shortenName(area.name)}`,
        description: `Digital territory NFT from the ${empireName} empire. OSM Type: ${area.type}`,
        image,
        attributes: [
          { trait_type: "Area ID", value: area.id },
          { trait_type: "Area Type", value: area.type },
          { trait_type: "Center Latitude", value: Number(area.center.lat.toFixed(6)) },
          { trait_type: "Center Longitude", value: Number(area.center.lng.toFixed(6)) },
          { trait_type: "Empire Name", value: empireName },
          { trait_type: "Empire Color", value: empireColor }
        ],
        area_id: area.id,
        empire_name: empireName,
        empire_color: empireColor
      };
      const json = JSON.stringify(metadata);
      return "data:application/json;base64," + btoa(unescape(encodeURIComponent(json)));
    }

    function buildAreaSVG(area, empireName, empireColor) {
        const name = escapeHTML(shortenName(area.name));
        const type = escapeHTML(area.type || '');
        const lat = toFixed5(area.center.lat);
        const lng = toFixed5(area.center.lng);
        const empName = escapeHTML(empireName);

        const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="800" height="420" viewBox="0 0 800 420">
          <defs>
            <linearGradient id="bgGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#070814" />
              <stop offset="100%" stop-color="#12122a" />
            </linearGradient>
            <linearGradient id="titleGrad" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="${empireColor}" />
              <stop offset="100%" stop-color="#eef2ff" />
            </linearGradient>
            <filter id="glow">
              <feGaussianBlur stdDeviation="3.5" result="blur" />
              <feFlood flood-color="${empireColor}" flood-opacity="0.4" result="color" />
              <feComposite in="color" in2="blur" operator="in" result="glow" />
              <feMerge>
                <feMergeNode in="glow" />
                <feMergeNode in="SourceGraphic" />
              </feMerge>
            </filter>
            <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
              <path d="M 40 0 L 0 0 0 40" fill="none" stroke="${empireColor}" stroke-width="0.5" opacity="0.2" />
            </pattern>
          </defs>
          
          <rect width="800" height="420" fill="url(#bgGrad)" />
          <rect width="800" height="420" fill="url(#grid)" />
          
          <rect x="10" y="10" width="780" height="400" rx="15" fill="none" 
                stroke="${empireColor}" stroke-width="2" filter="url(#glow)" />
          
          <g font-family="'Orbitron', sans-serif">
            <text x="40" y="80" font-size="28" font-weight="700" fill="url(#titleGrad)" filter="url(#glow)">
              ${empName.toUpperCase()}
            </text>
            <text x="40" y="130" font-size="40" font-weight="900" fill="#eef2ff">${name}</text>
            <text x="40" y="175" font-size="20" fill="#8f9cce">${type}</text>
            <text x="40" y="220" font-size="18" fill="#8f9cce">Location: ${lat}, ${lng}</text>
            
            <g transform="translate(40,270)">
              <rect width="280" height="60" rx="10" fill="none" stroke="${empireColor}" stroke-width="2" />
              <rect x="1" y="1" width="278" height="58" rx="9" fill="${empireColor}1A" />
              <text x="30" y="38" font-size="22" font-weight="700" fill="${empireColor}" filter="url(#glow)">DIGITAL TERRITORY</text>
            </g>
          </g>
        </svg>`;
      
      return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
    }

    async function mintSelectedArea() {
      try {
        if (!userAddress) { setStatus('Please connect your wallet first', 'error'); return; }
        if (!selected) { setStatus('Select a territory on the map first', 'error'); return; }
        if (mintedAreaIds.has(selected.id)) { setStatus('This territory is already minted', 'error'); return; }
        if (!empireName) { setStatus('Please enter an Empire Name before minting', 'error'); return; }

        setStatus('Submitting mint transaction...', 'loading');
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        const price = await contract.mintPrice().catch(() => ethers.utils.parseUnits('1', 18));
        const tokenURI = buildAreaTokenURI(selected, empireName, empireColor);
        const tx = await contract.mintWithURI(tokenURI, { value: price });
        
        setStatus('Transaction sent! Waiting for confirmation...', 'loading');
        const receipt = await tx.wait();

        const ev = receipt.events?.find(e => e.event === 'Transfer');
        const mintedTokenId = ev?.args?.tokenId?.toString() || null;

        mintedAreaIds.add(selected.id);
        myOwnedAreaIds.add(selected.id);
        updateCountsPills();

        if (selectionLayer) {
          selectionLayer.setStyle(() => areaStyle(true, true, true, { empireColor }));
          selectionLayer.bindPopup(`
            <div style="min-width:250px;text-align:center;">
              <div style="font-weight:800;margin:8px 0;color:${empireColor};font-family:'Orbitron',sans-serif;font-size:16px;text-shadow:0 0 8px ${empireColor}90;">TERRITORY MINTED!</div>
              <div style="font-size:14px;margin:15px 0;color:#eef2ff;">${escapeHTML(shortenName(selected.name))}</div>
              <a href="https://opensea.io/assets/matic/${CONTRACT_ADDRESS}/${mintedTokenId}" target="_blank" rel="noopener noreferrer" style="display:inline-block;background:${empireColor};color:#07061a;text-decoration:none;padding:8px 15px;border-radius:6px;font-weight:700;font-family:'Rajdhani',sans-serif;">View on OpenSea â†’</a>
            </div>
          `).openPopup();
        }

        selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;color:${empireColor};">verified</span> ${escapeHTML(shortenName(selected.name))} Â· <span style="color:${empireColor};">You own</span>`;
        
        updateMintButtonState();
        setStatus('Success! Your territory has been minted.', 'success');

        await saveEmpireSettings();
        const meta = await resolveTokenMetadata(tokenURI);
        if (meta) {
          await writeNftToFirebase(mintedTokenId || `temp-${Date.now()}`, userAddress, meta);
        }

        await refreshMinted(true);
      } catch (e) {
        console.error(e);
        const msg = e?.data?.message || e?.message || 'Unknown error';
        setStatus('Minting failed: ' + msg, 'error');
      }
    }

    async function refreshMinted(showToast = false) {
      try {
        if (!readProvider) readProvider = new ethers.providers.JsonRpcProvider(POLYGON_PARAMS.rpcUrls[0]);
        
        const contractRead = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, readProvider);
        if(showToast) setStatus('Fetching minted territories...', 'loading');

        const filter = contractRead.filters.Transfer('0x0000000000000000000000000000000000000000', null);
        const logs = await contractRead.queryFilter(filter, START_BLOCK, 'latest');
        const tokenIds = [...new Set(logs.map(l => l.args?.tokenId?.toString()).filter(Boolean))];

        const batch = async (items, size, cb) => {
          const out = [];
          for (let i = 0; i < items.length; i += size) {
            out.push(...await Promise.all(items.slice(i, i + size).map(cb)));
            await new Promise(r => setTimeout(r, 100));
          }
          return out;
        };

        const tokenMetaById = new Map();
        await batch(tokenIds, 20, async (tid) => {
          try {
            const uri = await contractRead.tokenURI(tid);
            const meta = await resolveTokenMetadata(uri);
            if(meta) tokenMetaById.set(tid, { uri, meta });
          } catch {}
        });

        const ownerByToken = new Map();
        await batch(tokenIds, 20, async (tid) => {
          try {
            const owner = await contractRead.ownerOf(tid);
            if(owner) ownerByToken.set(tid, owner);
          } catch {}
        });

        await syncAllToFirebase(tokenIds, ownerByToken, tokenMetaById);

        if (showToast) setStatus('Minted territories updated.', 'success');
        else setStatus('', '');
      } catch (e) {
        console.error(e);
        if(showToast) setStatus('Failed to refresh minted territories.', 'error');
      }
    }

    async function resolveTokenMetadata(uri) {
      if (!uri) return null;
      if (uri.startsWith('data:application/json')) {
        try { return JSON.parse(atob(uri.split(',')[1] || '')); } catch { return null; }
      }
      const url = uri.startsWith('ipfs://') ? 'https://ipfs.io/ipfs/' + uri.slice(7) : uri;
      try { const res = await fetch(url); return await res.json(); } catch { return null; }
    }
    
    function extractAreaId(meta) { return meta?.area_id ? String(meta.area_id) : null; }
    
    function updateCountsPills() {
      ownedCountPill.style.display = myOwnedAreaIds.size > 0 ? 'inline-flex' : 'none';
      ownedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;color:var(--success);">verified</span> You own: <strong style="margin-left:4px;color:var(--success);">${myOwnedAreaIds.size}</strong>`;
      
      mintedCountPill.style.display = 'inline-flex';
      mintedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;">public</span> Total minted: <strong style="margin-left:4px;color:var(--primary);">${mintedAreaIds.size}</strong>`;
    }

    function clearSelection() {
      selected = null;
      if (selectionLayer) selectionLayer.remove();
      selectionPill.style.display = 'none';
      updateMintButtonState();
      setStatus('Selection cleared. Click another area to select it.', 'success');
    }

    function initFirebase() {
      try {
        fbApp = firebase.initializeApp(firebaseConfig);
        fbDb = firebase.database();
        subscribeMintedOnFirebase();
      } catch (e) { console.error('Firebase init failed', e); }
    }

    function subscribeMintedOnFirebase() {
      if (!fbDb) return;
      if (allNftsRef) allNftsRef.off();
      
      allNftsRef = fbDb.ref('nfts');
      allNftsRef.on('child_added', snap => upsertMintedAreaOnMap(snap.key, snap.val()));
      allNftsRef.on('child_changed', snap => upsertMintedAreaOnMap(snap.key, snap.val()));
      allNftsRef.on('child_removed', snap => removeMintedAreaFromMap(snap.key, snap.val()));
    }

    function upsertMintedAreaOnMap(tokenId, data) {
      const areaId = extractAreaId(data.meta);
      if (!areaId || !data || !data.meta) return;

      const ownerLower = (data.owner || '').toLowerCase();
      const isMine = userAddress && ownerLower === userAddress.toLowerCase();
      const ownerData = {
          owner: ownerLower,
          empireName: data.meta.empire_name,
          empireColor: data.meta.empire_color
      };

      areaDataByAreaId.set(areaId, ownerData);
      mintedAreaIds.add(areaId);
      if (isMine) myOwnedAreaIds.add(areaId);

      const geojson = data.meta.geojson || { type: "Point", coordinates: [data.meta.center.lng, data.meta.center.lat] };
      if (!geojson) return;

      const prevLayer = mintedLayersByAreaId.get(areaId);
      if (prevLayer) mintedLayerGroup.removeLayer(prevLayer);
      
      const geoLayer = L.geoJSON(geojson, { style: () => areaStyle(true, isMine, false, ownerData) });

      geoLayer.bindPopup(`
        <div style="min-width:220px;">
          <div style="font-weight:800;margin-bottom:8px;font-family:'Orbitron',sans-serif;color:${ownerData.empireColor || '#ff2cf0'};font-size:15px;">
            ${escapeHTML(shortenName(data.meta.name))}
          </div>
          <div style="font-size:13px;color:#8f9cce;margin:8px 0;">Empire: <span style="color:#eef2ff;font-weight:bold;">${escapeHTML(ownerData.empireName)}</span></div>
          <div style="font-size:12px;color:#8f9cce;margin:8px 0;">Minted by: <span style="color:#eef2ff">${shortAddr(data.owner)}</span></div>
          <div style="font-size:11px;color:#5a5f8a;margin-top:10px;">ID: ${escapeHTML(areaId)}</div>
        </div>
      `);

      geoLayer.addTo(mintedLayerGroup);
      mintedLayersByAreaId.set(areaId, geoLayer);
      updateCountsPills();
    }

    function removeMintedAreaFromMap(tokenId, data) {
        const areaId = extractAreaId(data.meta);
        if(!areaId) return;

        const prevLayer = mintedLayersByAreaId.get(areaId);
        if (prevLayer) mintedLayerGroup.removeLayer(prevLayer);
        
        mintedLayersByAreaId.delete(areaId);
        areaDataByAreaId.delete(areaId);
        mintedAreaIds.delete(areaId);
        myOwnedAreaIds.delete(areaId);
        updateCountsPills();
    }

    async function syncAllToFirebase(tokenIds, ownerByToken, tokenMetaById) {
      if (!fbDb) return;
      const updates = {};
      for (const tid of tokenIds) {
        const metaData = tokenMetaById.get(tid);
        const owner = ownerByToken.get(tid) || '';
        if (metaData && metaData.meta) {
          updates[`nfts/${tid}`] = { owner, meta: metaData.meta };
        }
      }
      await fbDb.ref().update(updates);
    }

    async function writeNftToFirebase(tokenId, owner, meta) {
      if (!fbDb) return;
      await fbDb.ref(`nfts/${tokenId}`).set({ owner, meta });
    }

    function recomputeMyOwnershipFromData() {
      myOwnedAreaIds.clear();
      for (const [areaId, data] of areaDataByAreaId.entries()) {
        if (data.owner && data.owner === userAddress?.toLowerCase()) {
          myOwnedAreaIds.add(areaId);
        }
      }
      updateCountsPills();
    }

    function restyleAllMintedPolygons() {
      for (const [areaId, geoLayer] of mintedLayersByAreaId.entries()) {
        const data = areaDataByAreaId.get(areaId) || {};
        const isMine = userAddress && data.owner === userAddress.toLowerCase();
        geoLayer.setStyle(areaStyle(true, isMine, false, data));
      }
      updateCountsPills();
    }

    async function saveEmpireSettings() {
        if (!fbDb || !userAddress) return;
        await fbDb.ref(`empires/${userAddress.toLowerCase()}`).set({
            name: empireName,
            color: empireColor
        });
    }

    async function loadEmpireSettings() {
        if (!fbDb || !userAddress) return;
        const snapshot = await fbDb.ref(`empires/${userAddress.toLowerCase()}`).get();
        if (snapshot.exists()) {
            const data = snapshot.val();
            empireNameInput.value = data.name || '';
            empireColorInput.value = data.color || '#00f9ff';
            updateEmpireState();
        }
    }
    
    function updateEmpireState() {
        empireName = empireNameInput.value.trim();
        empireColor = empireColorInput.value;
        updateMintButtonState();
    }
    
    function updateMintButtonState() {
        const isMinted = selected && mintedAreaIds.has(selected.id);
        mintBtn.disabled = !userAddress || !selected || isMinted || !empireName;
    }

    // Event listeners
    connectBtn.addEventListener('click', connectWallet);
    mintBtn.addEventListener('click', mintSelectedArea);
    clearBtn.addEventListener('click', clearSelection);
    refreshBtn.addEventListener('click', () => refreshMinted(true));
    empireNameInput.addEventListener('input', updateEmpireState);
    empireColorInput.addEventListener('input', updateEmpireState);

    window.addEventListener('DOMContentLoaded', () => {
      initMap();
      initFirebase();
      setStatus('Select a territory on the map to claim it');
    });
  </script>
</body>
</html>
