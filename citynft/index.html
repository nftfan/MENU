<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>NFT Cities — Click a city to mint it</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@600;700&display=swap" rel="stylesheet" />
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Ethers (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --accent: #f59e0b;
      --success: #10b981;
      --error: #ef4444;
      --bg: #0f1020;
      --card: #14162b;
      --text: #f8fafc;
      --muted: #94a3b8;
      --border: #253357;
      --radius: 12px;
      --shadow: rgba(0,0,0,0.25);
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 0% 0%, rgba(99,102,241,0.12), transparent 60%),
                  radial-gradient(1200px 600px at 100% 0%, rgba(245,158,11,0.1), transparent 60%),
                  linear-gradient(180deg, #0b0c1a, #0f1020);
      color: var(--text);
    }
    header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px; gap: 10px;
    }
    .brand { display: flex; align-items: center; gap: 10px; }
    .logo {
      width: 28px; height: 28px; border-radius: 50%;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      display: grid; place-items: center; box-shadow: 0 4px 12px var(--shadow);
    }
    .logo .material-icons { font-size: 16px; color: #fff; }
    .title h1 { margin: 0; font-size: 16px; font-weight: 700; }
    .title p { margin: 0; font-size: 11px; color: var(--muted); }

    .actions { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    button {
      appearance: none; border: 1px solid transparent; border-radius: 10px;
      padding: 8px 10px; font-size: 12px; font-weight: 700; color: #fff; cursor: pointer;
      display: inline-flex; align-items: center; gap: 6px;
      background: #1a1d36; border-color: #2a3560; transition: transform .15s ease, opacity .2s ease;
    }
    button .material-icons { font-size: 16px; }
    button.primary { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); border-color: transparent; }
    button.success { background: linear-gradient(135deg, var(--success), #34d399); border-color: transparent; color: #052318; }
    button.accent { background: linear-gradient(135deg, var(--accent), #fb923c); border-color: transparent; color: #1a1305; }
    button:disabled { opacity: .6; cursor: not-allowed; transform: none !important; }
    button:not(:disabled):active { transform: translateY(1px); }
    .wallet { color: #a7f3d0; font-size: 12px; font-weight: 700; }
    .pill {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 11px; padding: 6px 8px; border-radius: 999px; border: 1px solid var(--border);
      background: #0f1329; color: #cbd5e1;
    }

    main { display: grid; grid-template-columns: 1fr; gap: 10px; padding: 0 12px 12px; }
    @media (min-width: 980px) { main { grid-template-columns: 1.6fr 1fr; } }

    #map {
      height: 64vh; width: 100%;
      border-radius: var(--radius); border: 1px solid var(--border);
      overflow: hidden; background: #0e1023; box-shadow: 0 8px 20px var(--shadow);
      position: relative;
    }

    .panel {
      background: var(--card); border: 1px solid var(--border); border-radius: var(--radius);
      padding: 12px; display: grid; gap: 10px;
    }
    .row { display: grid; gap: 8px; }
    .row.inline { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }

    .legend {
      display: flex; gap: 10px; flex-wrap: wrap; align-items: center;
      font-size: 12px; color: #cbd5e1;
    }
    .legend .key { display: inline-flex; align-items: center; gap: 6px; }
    .legend .box { width: 14px; height: 14px; border-radius: 3px; border: 1px solid #334155; }
    .legend .box.unselected { background:#28314f; }
    .legend .box.selected   { background:#4f46e5; }
    .legend .box.minted     { background:#d97706; }
    .legend .box.owned      { background:#059669; }

    .status {
      min-height: 38px; display: grid; place-items: center; text-align: center;
      font-size: 12px; border-radius: 10px; padding: 8px;
      border: 1px solid #22345a; color: var(--muted);
    }
    .status.success { background: rgba(16,185,129,.12); color: var(--success); border-color: rgba(16,185,129,.35); }
    .status.error { background: rgba(239,68,68,.12); color: var(--error); border-color: rgba(239,68,68,.35); }
    .status.loading { display: inline-flex; align-items: center; gap: 8px; justify-content: center; }
    .spinner {
      width: 14px; height: 14px; border-radius: 50%;
      border: 2px solid rgba(255,255,255,.25); border-top-color: var(--primary);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Loading toast for city lookup */
    .toast {
      position: fixed;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: #111327;
      color: #e5e7eb;
      border: 1px solid #2a3560;
      border-radius: 12px;
      box-shadow: 0 8px 24px rgba(0,0,0,.35);
      z-index: 9999;
      font-size: 13px;
    }
    .toast .spinner { width: 16px; height: 16px; border-width: 2px; }
    .toast .material-icons { font-size: 18px; color: #60a5fa; }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo"><span class="material-icons">location_city</span></div>
      <div class="title">
        <h1>NFT Cities</h1>
        <p>Click a city to highlight and mint it</p>
      </div>
    </div>
    <div class="actions">
      <span class="pill"><span class="material-icons" style="font-size:16px;">paid</span> Mint Price: <strong style="margin-left:4px;">1 $POL</strong></span>
      <button id="connectBtn" class="primary"><span class="material-icons">account_balance_wallet</span>Connect</button>
      <span id="wallet" class="wallet"></span>
    </div>
  </header>

  <main>
    <div id="map" aria-label="Map"></div>

    <div class="panel">
      <div class="row">
        <div class="legend">
          <div class="key"><span class="box unselected"></span> Not selected</div>
          <div class="key"><span class="box selected"></span> Selected (unminted)</div>
          <div class="key"><span class="box minted"></span> Minted (anyone)</div>
          <div class="key"><span class="box owned"></span> You own</div>
        </div>
      </div>

      <div class="row inline">
        <span id="selectionPill" class="pill" style="display:none;"></span>
        <span id="ownedCountPill" class="pill" style="display:none;"></span>
        <span id="mintedCountPill" class="pill" style="display:none;"></span>
      </div>

      <div class="row inline">
        <button id="mintBtn" class="success" disabled><span class="material-icons">rocket_launch</span>Mint City</button>
        <button id="clearBtn" class="accent"><span class="material-icons">delete_sweep</span>Clear</button>
        <button id="refreshBtn"><span class="material-icons">refresh</span>Refresh Minted</button>
      </div>

      <div id="status" class="status"></div>
    </div>
  </main>

  <!-- Loading toast shown while city polygon is being fetched -->
  <div id="cityLoading" class="toast" role="status" aria-live="assertive" aria-atomic="true">
    <span class="spinner" aria-hidden="true"></span>
    <span class="material-icons" aria-hidden="true">location_city</span>
    <span class="text">Please wait, loading city…</span>
  </div>

  <script type="module">
    // Ethers global
    const { ethers } = window;

    // Polygon Mainnet
    const POLYGON_PARAMS = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com/'],
      blockExplorerUrls: ['https://polygonscan.com/']
    };

    // Contract
    const CONTRACT_ADDRESS = "0xb7d9E197905A0Fe7A59d82029eEFCBfDa631E2CC";
    const CONTRACT_ABI = [
      "function mintWithURI(string tokenURI) external payable returns (uint256)",
      "function mintPrice() view returns (uint256)"
    ];

    // Only allow selecting cities/towns (not countries)
    const ALLOWED_CITY_TYPES = ['city','town']; // restrict to place:city or place:town

    // Firebase (NEW configuration)
    // Using Firebase v10 modular SDK
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getDatabase, ref, onValue, set, get, child } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-database.js";

    const firebaseConfig = {
      apiKey: "AIzaSyC6wYBu-KOXkDmB-84_7OPtY71zBX4FzRY",
      authDomain: "newnft-47bd7.firebaseapp.com",
      databaseURL: "https://newnft-47bd7-default-rtdb.firebaseio.com",
      projectId: "newnft-47bd7",
      storageBucket: "newnft-47bd7.firebasestorage.app",
      messagingSenderId: "172043823738",
      appId: "1:172043823738:web:daf1fcfb7862d7d8f029c3",
      measurementId: "G-8VB3DYRNXR"
    };
    const appFB = initializeApp(firebaseConfig);
    const db = getDatabase(appFB);

    // Map / state
    let map;
    let selectionLayer; // L.GeoJSON
    let selected = null; // { id, name, type, center, geojson }
    let isCityLoading = false;

    // Minted cities from Firebase
    const mintedRecords = new Map(); // id -> record
    const mintedLayersById = new Map(); // id -> L.GeoJSON layer
    let myAddress = null;

    // Ethers
    let provider, signer;

    // UI elements
    const connectBtn = document.getElementById('connectBtn');
    const walletEl = document.getElementById('wallet');
    const mintBtn = document.getElementById('mintBtn');
    const clearBtn = document.getElementById('clearBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const statusEl = document.getElementById('status');
    const selectionPill = document.getElementById('selectionPill');
    const ownedCountPill = document.getElementById('ownedCountPill');
    const mintedCountPill = document.getElementById('mintedCountPill');
    const cityLoadingEl = document.getElementById('cityLoading');

    // A layer group holding all minted city polygons
    const mintedLayerGroup = L.layerGroup();

    // Helpers
    function setStatus(msg, type = '') {
      if (!msg) {
        statusEl.textContent = '';
        statusEl.className = 'status';
        return;
      }
      statusEl.className = 'status';
      if (type === 'success') statusEl.classList.add('success');
      if (type === 'error') statusEl.classList.add('error');
      if (type === 'loading') {
        statusEl.classList.add('loading');
        statusEl.innerHTML = `<span class="spinner"></span><span>${msg}</span>`;
      } else {
        statusEl.textContent = msg;
      }
    }
    function toFixed5(n) { return (Math.round(n * 100000) / 100000).toFixed(5); }
    function escapeHTML(s) { return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }
    function showCityLoading(text = 'Please wait, loading city…') {
      cityLoadingEl.querySelector('.text').textContent = text;
      cityLoadingEl.style.display = 'inline-flex';
    }
    function hideCityLoading() {
      cityLoadingEl.style.display = 'none';
    }
    function shortenName(name) {
      const n = String(name || '');
      if (n.length <= 60) return n;
      const firstComma = n.indexOf(',');
      if (firstComma > 0) return n.slice(0, firstComma) + '…';
      return n.slice(0, 57) + '…';
    }

    // Map init
    function initMap() {
      if (!window.L) { setStatus('Leaflet failed to load.', 'error'); return; }
      map = L.map('map', { center: [20, 0], zoom: 3, zoomControl: true, worldCopyJump: true });
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 18, attribution: '&copy; OpenStreetMap'
      })
      .on('tileerror', () => setStatus('Tile load error (network/rate limit).', 'error'))
      .addTo(map);

      // Add minted layer group to map (but we will populate it only after wallet connects)
      mintedLayerGroup.addTo(map);

      map.on('click', onMapClick);
      setTimeout(() => map.invalidateSize(), 300);
      setStatus('Click on the map to select a city.', 'success');
    }

    // City lookup via Nominatim reverse + polygon
    async function onMapClick(e) {
      if (isCityLoading) return;
      const { lat, lng } = e.latlng;

      isCityLoading = true;
      showCityLoading('Please wait, loading city…');
      setStatus('Looking up city polygon for this location...', 'loading');

      try {
        const area = await reverseGeocodeCityWithPolygon(lat, lng);
        if (!area) {
          setStatus('No city found here. Zoom in and click near a city center.', 'error');
          return;
        }
        selectArea(area);
        setStatus('City selected. You can mint it.', 'success');
      } catch (err) {
        console.error(err);
        setStatus('City lookup failed. Try again.', 'error');
      } finally {
        isCityLoading = false;
        hideCityLoading();
      }
    }

    async function reverseGeocodeCityWithPolygon(lat, lng) {
      // Aim for city/town level
      const url = new URL('https://nominatim.openstreetmap.org/reverse');
      url.searchParams.set('format', 'jsonv2');
      url.searchParams.set('lat', lat);
      url.searchParams.set('lon', lng);
      url.searchParams.set('zoom', 12); // city/town focus
      url.searchParams.set('polygon_geojson', '1');
      url.searchParams.set('addressdetails', '1');

      const res = await fetch(url.toString(), { headers: { 'Accept-Language': 'en' } });
      if (!res.ok) throw new Error('Nominatim reverse failed');
      const data = await res.json();

      const cls = data.class || '';        // expect 'place'
      const typ = (data.type || '').toLowerCase(); // expect 'city' or 'town'
      if (cls !== 'place' || !ALLOWED_CITY_TYPES.includes(typ)) {
        // Not a city/town — disallow
        return null;
      }

      const geojson = data.geojson || data.geometry;
      if (!geojson || !geojson.type || !geojson.coordinates) return null;

      const osm_id = data.osm_id;
      const osm_type = (data.osm_type || '').toLowerCase(); // node|way|relation
      const dispName = data.display_name || 'Unknown city';
      const center = { lat: Number(data.lat), lng: Number(data.lon) };
      const id = makeAreaId(osm_type, osm_id);
      return { id, name: dispName, type: `${cls}:${typ}`, center, geojson };
    }

    function makeAreaId(osmType, osmId) {
      return `osm:${osmType}:${osmId}`;
    }

    function areaStyleMinted(isOwnedByMe = false) {
      return {
        color: '#1f2937',
        weight: 1,
        opacity: 1,
        fillColor: isOwnedByMe ? '#059669' : '#d97706', // green if mine, orange if minted by others
        fillOpacity: 0.55
      };
    }
    function areaStyleSelected() {
      return { color: '#1f2937', weight: 1, opacity: 1, fillColor: '#4f46e5', fillOpacity: 0.55 };
    }
    function areaStyleUnselected() {
      return { color: '#1f2937', weight: 1, opacity: 1, fillColor: '#28314f', fillOpacity: 0.55 };
    }

    function selectArea(area) {
      selected = area;

      if (selectionLayer) {
        try { selectionLayer.remove(); } catch {}
        selectionLayer = null;
      }

      const alreadyMinted = mintedRecords.has(area.id);
      const isMine = alreadyMinted && addressesEqual(mintedRecords.get(area.id)?.owner, myAddress);

      selectionLayer = L.geoJSON(area.geojson, {
        style: alreadyMinted ? areaStyleMinted(isMine) : areaStyleSelected
      }).addTo(map);

      const bounds = selectionLayer.getBounds();
      if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [16, 16] });
      } else {
        map.setView([area.center.lat, area.center.lng], Math.max(map.getZoom(), 12));
      }

      selectionLayer.bindPopup(`
        <div style="min-width:220px;">
          <div style="font-weight:800;margin-bottom:6px;">${escapeHTML(shortenName(area.name))}</div>
          <div style="font-size:12px;color:#94a3b8;">Center: ${toFixed5(area.center.lat)}, ${toFixed5(area.center.lng)}</div>
          <div style="font-size:12px;color:#cbd5e1;margin-top:6px;">${isMine ? 'You own this city' : alreadyMinted ? 'Already minted' : 'Not minted yet'}</div>
          <div style="font-size:11px;color:#64748b;margin-top:6px;">ID: ${escapeHTML(area.id)}</div>
        </div>
      `).openPopup();

      // Update pill + buttons
      selectionPill.style.display = 'inline-flex';
      selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">location_city</span> ${escapeHTML(shortenName(area.name))} · ${isMine ? 'You own' : alreadyMinted ? 'Minted' : 'Unminted'}`;
      mintBtn.disabled = !myAddress || alreadyMinted;
    }

    // Wallet
    async function switchToPolygon() {
      if (!window.ethereum) return false;
      try {
        await window.ethereum.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: POLYGON_PARAMS.chainId }] });
        return true;
      } catch (e) {
        if (e.code === 4902) {
          try {
            await window.ethereum.request({ method: 'wallet_addEthereumChain', params: [POLYGON_PARAMS] });
            return true;
          } catch { setStatus('Failed to add Polygon network', 'error'); return false; }
        }
        setStatus('Failed to switch network', 'error'); return false;
      }
    }

    async function connectWallet() {
      if (!window.ethereum) { setStatus('Please install MetaMask to continue', 'error'); return; }
      try {
        setStatus('Connecting wallet...', 'loading');
        const switched = await switchToPolygon();
        if (!switched) return;

        provider = new ethers.providers.Web3Provider(window.ethereum);
        await provider.send('eth_requestAccounts', []);
        signer = provider.getSigner();
        myAddress = await signer.getAddress();

        connectBtn.disabled = true;
        connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
        walletEl.textContent = `${myAddress.slice(0,6)}...${myAddress.slice(-4)}`;

        setStatus('Wallet connected. Loading minted cities from Firebase...', 'loading');

        // Start Firebase listener to show minted NFTs (cities) when wallet is connected
        beginMintedFirebaseListener();

        // React to account changes
        if (window.ethereum && window.ethereum.on) {
          window.ethereum.on('accountsChanged', async (accounts) => {
            if (accounts && accounts[0]) {
              myAddress = accounts[0];
              walletEl.textContent = `${myAddress.slice(0,6)}...${myAddress.slice(-4)}`;
              restyleMintedLayers(); // update ownership coloring
              // Update selection state/button
              if (selected) {
                const alreadyMinted = mintedRecords.has(selected.id);
                const isMine = alreadyMinted && addressesEqual(mintedRecords.get(selected.id)?.owner, myAddress);
                if (selectionLayer) selectionLayer.setStyle(alreadyMinted ? areaStyleMinted(isMine) : areaStyleSelected);
                mintBtn.disabled = !myAddress || alreadyMinted;
                selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">location_city</span> ${escapeHTML(shortenName(selected.name))} · ${isMine ? 'You own' : alreadyMinted ? 'Minted' : 'Unminted'}`;
              }
            }
          });
        }
      } catch (e) {
        console.error(e);
        setStatus('Wallet connection failed', 'error');
      }
    }

    // Firebase minted cities
    function beginMintedFirebaseListener() {
      const mintedRef = ref(db, 'mintedCities');
      onValue(mintedRef, (snapshot) => {
        // Clear previous cache (rebuild)
        mintedRecords.clear();

        // Keep track of IDs seen in this snapshot to remove stale layers
        const seen = new Set();

        const data = snapshot.val() || {};
        Object.keys(data).forEach((id) => {
          const rec = data[id];
          if (!rec || !rec.geojson) return;
          mintedRecords.set(id, rec);
          seen.add(id);
          upsertMintedLayer(rec);
        });

        // Remove layers that no longer exist in DB
        for (const [id, layer] of mintedLayersById.entries()) {
          if (!seen.has(id)) {
            mintedLayerGroup.removeLayer(layer);
            mintedLayersById.delete(id);
          }
        }

        updateCountsPills();
        setStatus('Minted cities loaded from Firebase.', 'success');

        // If current selection is minted, update its style
        if (selected) {
          const alreadyMinted = mintedRecords.has(selected.id);
          const isMine = alreadyMinted && addressesEqual(mintedRecords.get(selected.id)?.owner, myAddress);
          if (selectionLayer) selectionLayer.setStyle(alreadyMinted ? areaStyleMinted(isMine) : areaStyleSelected);
          mintBtn.disabled = !myAddress || alreadyMinted;
          selectionPill.style.display = 'inline-flex';
          selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">location_city</span> ${escapeHTML(shortenName(selected.name))} · ${isMine ? 'You own' : alreadyMinted ? 'Minted' : 'Unminted'}`;
        }
      }, (err) => {
        console.error('Firebase onValue error:', err);
        setStatus('Failed to load minted cities from Firebase.', 'error');
      });
    }

    function upsertMintedLayer(rec) {
      const id = rec.id;
      const isMine = myAddress && addressesEqual(rec.owner, myAddress);

      if (mintedLayersById.has(id)) {
        // Update style and popup
        const layer = mintedLayersById.get(id);
        layer.setStyle(areaStyleMinted(isMine));
        layer.bindPopup(mintedPopupHTML(rec));
        return;
      }

      // Create new layer
      try {
        const layer = L.geoJSON(rec.geojson, { style: areaStyleMinted(isMine) });
        layer.bindPopup(mintedPopupHTML(rec));
        layer.addTo(mintedLayerGroup);
        mintedLayersById.set(id, layer);
      } catch (e) {
        console.warn('Failed to add minted layer for', id, e);
      }
    }

    function mintedPopupHTML(rec) {
      const ownerShort = rec.owner ? `${rec.owner.slice(0,6)}...${rec.owner.slice(-4)}` : 'unknown';
      const name = escapeHTML(shortenName(rec.name));
      const id = escapeHTML(rec.id);
      return `
        <div style="min-width:220px;">
          <div style="font-weight:800;margin-bottom:6px;">${name}</div>
          <div style="font-size:12px;color:#94a3b8;">Owner: ${ownerShort}</div>
          <div style="font-size:11px;color:#64748b;margin-top:6px;">ID: ${id}</div>
        </div>
      `;
    }

    function restyleMintedLayers() {
      for (const [id, layer] of mintedLayersById.entries()) {
        const rec = mintedRecords.get(id);
        const isMine = rec && myAddress && addressesEqual(rec.owner, myAddress);
        layer.setStyle(areaStyleMinted(isMine));
      }
      updateCountsPills();
    }

    function updateCountsPills() {
      const minted = mintedRecords.size;
      let owned = 0;
      if (myAddress) {
        for (const rec of mintedRecords.values()) {
          if (addressesEqual(rec.owner, myAddress)) owned++;
        }
      }
      if (owned > 0) {
        ownedCountPill.style.display = 'inline-flex';
        ownedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;">verified</span> You own: <strong style="margin-left:4px;">${owned}</strong>`;
      } else {
        ownedCountPill.style.display = 'none';
      }
      mintedCountPill.style.display = 'inline-flex';
      mintedCountPill.innerHTML = `<span class="material-icons" style="font-size:16px;">public</span> Minted cities: <strong style="margin-left:4px;">${minted}</strong>`;
    }

    function addressesEqual(a, b) {
      if (!a || !b) return false;
      return String(a).toLowerCase() === String(b).toLowerCase();
    }

    // TokenURI builder (data:application/json) for city
    function buildCityTokenURI(area) {
      const image = buildCitySVG(area);
      const metadata = {
        name: `City: ${shortenName(area.name)}`,
        description: `User-minted city NFT (OSM ${area.type}).`,
        image,
        attributes: [
          { trait_type: "Area ID", value: area.id },
          { trait_type: "Area Type", value: area.type },
          { trait_type: "Center Latitude", value: Number(area.center.lat.toFixed(6)) },
          { trait_type: "Center Longitude", value: Number(area.center.lng.toFixed(6)) }
        ],
        area_id: area.id
      };
      const json = JSON.stringify(metadata);
      return "data:application/json;base64," + btoa(unescape(encodeURIComponent(json)));
    }

    function buildCitySVG(area) {
      const name = escapeHTML(shortenName(area.name));
      const type = escapeHTML(area.type || '');
      const lat = toFixed5(area.center.lat);
      const lng = toFixed5(area.center.lng);
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="800" height="420">
          <defs>
            <linearGradient id="g" x1="0" y1="0" x2="1" y2="1">
              <stop offset="0%" stop-color="#4f46e5"/>
              <stop offset="100%" stop-color="#06b6d4"/>
            </linearGradient>
          </defs>
          <rect width="100%" height="100%" fill="#0b0c1a"/>
          <rect x="20" y="20" width="760" height="380" rx="20" fill="url(#g)" opacity="0.25"/>
          <g font-family="Inter, Arial, sans-serif" fill="#e5e7eb">
            <text x="40" y="150" font-size="40" font-weight="700">${name}</text>
            <text x="40" y="190" font-size="22" fill="#cbd5e1">${type}</text>
            <text x="40" y="225" font-size="22" fill="#cbd5e1">Center: ${lat}, ${lng}</text>
            <g transform="translate(40,270)">
              <rect width="220" height="50" rx="10" fill="#10b981" />
              <text x="18" y="33" font-size="20" font-weight="700" fill="#00110d">NFT City</text>
            </g>
          </g>
        </svg>`;
      return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
    }

    async function mintSelectedCity() {
      try {
        if (!myAddress) { setStatus('Connect wallet first', 'error'); return; }
        if (!selected) { setStatus('Select a city first', 'error'); return; }
        if (mintedRecords.has(selected.id)) { setStatus('This city is already minted', 'error'); return; }

        setStatus('Submitting mint transaction...', 'loading');

        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        let price;
        try { price = await contract.mintPrice(); }
        catch { price = ethers.utils.parseUnits('1', 18); }

        const tokenURI = buildCityTokenURI(selected);
        const tx = await contract.mintWithURI(tokenURI, { value: price });
        await tx.wait();

        // Persist to Firebase so minted NFTs load reliably next time
        const record = {
          id: selected.id,
          name: selected.name,
          type: selected.type,
          center: selected.center,
          geojson: selected.geojson,
          owner: myAddress,
          tokenURI,
          txHash: tx.hash || '',
          mintedAt: Date.now()
        };
        await set(ref(db, `mintedCities/${selected.id}`), record);

        // Local update for instant feedback
        mintedRecords.set(selected.id, record);
        upsertMintedLayer(record);

        if (selectionLayer) {
          selectionLayer.setStyle(areaStyleMinted(true));
          selectionLayer.bindPopup(`
            <div style="min-width:220px;text-align:center;">
              <div style="font-weight:800;margin-bottom:6px;color:#10b981;">City Minted!</div>
              <div style="font-size:13px;margin-bottom:8px;">${escapeHTML(shortenName(selected.name))}</div>
            </div>
          `).openPopup();
        }

        selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">verified</span> ${escapeHTML(shortenName(selected.name))} · You own`;
        mintBtn.disabled = true;
        updateCountsPills();
        setStatus('Success! Your city NFT has been minted.', 'success');
      } catch (e) {
        console.error(e);
        const msg = e?.data?.message || e?.message || 'Unknown error';
        setStatus('Minting failed: ' + msg, 'error');
      }
    }

    async function refreshMinted() {
      // Explicit refresh from Firebase (one-time read)
      try {
        setStatus('Refreshing minted cities...', 'loading');
        const snapshot = await get(child(ref(db), 'mintedCities'));
        const data = snapshot.val() || {};

        // Clear current caches and layers
        mintedRecords.clear();
        mintedLayersById.forEach(layer => mintedLayerGroup.removeLayer(layer));
        mintedLayersById.clear();

        Object.keys(data).forEach((id) => {
          const rec = data[id];
          if (rec && rec.geojson) {
            mintedRecords.set(id, rec);
            upsertMintedLayer(rec);
          }
        });

        updateCountsPills();
        setStatus('Minted cities refreshed.', 'success');

        // Update selection styling/buttons if needed
        if (selected) {
          const alreadyMinted = mintedRecords.has(selected.id);
          const isMine = alreadyMinted && addressesEqual(mintedRecords.get(selected.id)?.owner, myAddress);
          if (selectionLayer) selectionLayer.setStyle(alreadyMinted ? areaStyleMinted(isMine) : areaStyleSelected);
          mintBtn.disabled = !myAddress || alreadyMinted;
          selectionPill.style.display = 'inline-flex';
          selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">location_city</span> ${escapeHTML(shortenName(selected.name))} · ${isMine ? 'You own' : alreadyMinted ? 'Minted' : 'Unminted'}`;
        }
      } catch (e) {
        console.error(e);
        setStatus('Failed to refresh minted cities.', 'error');
      }
    }

    function clearSelection() {
      selected = null;
      if (selectionLayer) {
        try { selectionLayer.remove(); } catch {}
        selectionLayer = null;
      }
      selectionPill.style.display = 'none';
      mintBtn.disabled = true;
      setStatus('Selection cleared. Click another city.', 'success');
    }

    // Bind UI
    connectBtn.addEventListener('click', connectWallet);
    mintBtn.addEventListener('click', mintSelectedCity);
    clearBtn.addEventListener('click', clearSelection);
    refreshBtn.addEventListener('click', refreshMinted);

    // Init
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      if (window.ethereum?.selectedAddress) {
        connectWallet().catch(() => {});
      }
    });
  </script>
</body>
</html>
