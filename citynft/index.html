<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Enhanced NFT Areas ‚Äî Click any area to mint it with dynamic pricing</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
  
  <!-- MapLibre GL JS (Open Source) -->
  <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
  
  <!-- Turf.js for area calculations -->
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  
  <!-- Ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  
  <!-- Firebase (compat SDK) -->
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>
  
  <style>
    :root {
      --primary: #6366f1;
      --primary-dark: #4f46e5;
      --accent: #f59e0b;
      --success: #10b981;
      --error: #ef4444;
      --warning: #f97316;
      --bg: #0f1020;
      --card: #14162b;
      --text: #f8fafc;
      --muted: #94a3b8;
      --border: #253357;
      --radius: 12px;
      --shadow: rgba(0,0,0,0.25);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; margin: 0; }
    
    body {
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 0% 0%, rgba(99,102,241,0.12), transparent 60%),
                  radial-gradient(1200px 600px at 100% 0%, rgba(245,158,11,0.1), transparent 60%),
                  linear-gradient(180deg, #0b0c1a, #0f1020);
      color: var(--text);
      overflow: hidden;
    }

    /* Header */
    header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px 16px; gap: 12px; backdrop-filter: blur(10px);
      background: rgba(20, 22, 43, 0.8); border-bottom: 1px solid var(--border);
      position: relative; z-index: 1000;
    }

    .brand { display: flex; align-items: center; gap: 12px; }
    .logo {
      width: 32px; height: 32px; border-radius: 8px;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      display: grid; place-items: center; box-shadow: 0 4px 12px var(--shadow);
    }
    .logo .material-icons { font-size: 18px; color: #fff; }
    .title h1 { margin: 0; font-size: 18px; font-weight: 700; }
    .title p { margin: 0; font-size: 12px; color: var(--muted); }

    .actions { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    
    button {
      appearance: none; border: 1px solid transparent; border-radius: 8px;
      padding: 10px 14px; font-size: 13px; font-weight: 600; color: #fff; cursor: pointer;
      display: inline-flex; align-items: center; gap: 8px;
      background: rgba(26, 29, 54, 0.8); border-color: #2a3560; 
      transition: all 0.2s ease; backdrop-filter: blur(10px);
    }
    button .material-icons { font-size: 18px; }
    button.primary { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); }
    button.success { background: linear-gradient(135deg, var(--success), #34d399); color: #052318; }
    button.accent { background: linear-gradient(135deg, var(--accent), #fb923c); color: #1a1305; }
    button.warning { background: linear-gradient(135deg, var(--warning), #ea580c); color: #1a0c05; }
    button:hover:not(:disabled) { transform: translateY(-1px); box-shadow: 0 4px 12px var(--shadow); }
    button:active:not(:disabled) { transform: translateY(0px); }
    button:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }

    .pill {
      display: inline-flex; align-items: center; gap: 6px;
      font-size: 12px; padding: 8px 12px; border-radius: 20px; border: 1px solid var(--border);
      background: rgba(15, 19, 41, 0.8); color: #cbd5e1; backdrop-filter: blur(10px);
    }
    .pill.price { background: linear-gradient(135deg, rgba(245,158,11,0.2), rgba(251,146,60,0.2)); }

    /* Main Layout */
    main { 
      display: grid; grid-template-columns: 1fr; gap: 12px; 
      padding: 12px; height: calc(100vh - 80px); overflow: hidden;
    }
    @media (min-width: 1024px) { 
      main { grid-template-columns: 1.8fr 1fr; } 
    }

    /* Map Container */
    .map-container {
      border-radius: var(--radius); border: 1px solid var(--border);
      overflow: hidden; background: #0e1023; box-shadow: 0 8px 20px var(--shadow);
      position: relative; grid-column: 1 / -1;
    }
    @media (min-width: 1024px) { 
      .map-container { grid-column: 1; } 
    }

    #map { width: 100%; height: 100%; }

    /* Control Panel */
    .control-panel {
      display: grid; grid-template-rows: auto 1fr auto; gap: 12px;
      background: rgba(20, 22, 43, 0.9); border: 1px solid var(--border); 
      border-radius: var(--radius); padding: 16px; backdrop-filter: blur(10px);
      box-shadow: 0 8px 20px var(--shadow);
    }
    @media (min-width: 1024px) { 
      .control-panel { grid-column: 2; } 
    }

    .section { display: grid; gap: 10px; }
    .section h3 { margin: 0; font-size: 14px; font-weight: 600; color: var(--text); }

    .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .stat-card {
      background: rgba(15, 19, 41, 0.6); border: 1px solid var(--border);
      border-radius: 8px; padding: 12px; text-align: center;
    }
    .stat-value { font-size: 20px; font-weight: 700; color: var(--primary); }
    .stat-label { font-size: 11px; color: var(--muted); margin-top: 4px; }

    .selection-info {
      background: rgba(15, 19, 41, 0.6); border: 1px solid var(--border);
      border-radius: 8px; padding: 12px; min-height: 120px;
    }
    .selection-info.empty {
      display: grid; place-items: center; text-align: center; color: var(--muted);
    }
    .selection-title { font-weight: 600; margin-bottom: 8px; }
    .selection-detail { font-size: 12px; color: var(--muted); margin: 4px 0; }
    .price-display {
      background: linear-gradient(135deg, rgba(245,158,11,0.15), rgba(251,146,60,0.15));
      border: 1px solid rgba(245,158,11,0.3); border-radius: 6px;
      padding: 8px; margin: 8px 0; text-align: center;
    }
    .price-value { font-size: 16px; font-weight: 700; color: var(--accent); }

    .action-buttons { display: grid; gap: 8px; }

    /* Status and Loading */
    .status {
      min-height: 40px; display: grid; place-items: center; text-align: center;
      font-size: 12px; border-radius: 8px; padding: 10px;
      border: 1px solid #22345a; color: var(--muted);
    }
    .status.success { background: rgba(16,185,129,.12); color: var(--success); border-color: rgba(16,185,129,.35); }
    .status.error { background: rgba(239,68,68,.12); color: var(--error); border-color: rgba(239,68,68,.35); }
    .status.loading { display: inline-flex; align-items: center; gap: 8px; justify-content: center; }

    .spinner {
      width: 16px; height: 16px; border-radius: 50%;
      border: 2px solid rgba(255,255,255,.25); border-top-color: var(--primary);
      animation: spin 1s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Toast Notifications */
    .toast {
      position: fixed; top: 20px; right: 20px; max-width: 350px;
      background: rgba(20, 22, 43, 0.95); border: 1px solid var(--border);
      border-radius: 8px; padding: 12px; backdrop-filter: blur(10px);
      box-shadow: 0 8px 24px var(--shadow); z-index: 10000;
      transform: translateX(400px); transition: transform 0.3s ease;
    }
    .toast.show { transform: translateX(0); }
    .toast.success { border-color: var(--success); }
    .toast.error { border-color: var(--error); }

    /* Map Controls */
    .map-legend {
      position: absolute; bottom: 16px; left: 16px;
      background: rgba(20, 22, 43, 0.9); border: 1px solid var(--border);
      border-radius: 8px; padding: 12px; backdrop-filter: blur(10px);
      max-width: 280px; z-index: 100;
    }
    .legend-title { font-size: 12px; font-weight: 600; margin-bottom: 8px; }
    .legend-items { display: grid; gap: 6px; }
    .legend-item { display: flex; align-items: center; gap: 8px; font-size: 11px; }
    .legend-color { width: 16px; height: 16px; border-radius: 3px; border: 1px solid #334155; }

    .loading-overlay {
      position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: rgba(20, 22, 43, 0.9); border: 1px solid var(--border);
      border-radius: 8px; padding: 16px; backdrop-filter: blur(10px);
      display: none; align-items: center; gap: 12px; z-index: 200;
    }
    .loading-overlay.show { display: flex; }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      header { padding: 8px 12px; }
      .actions { gap: 6px; }
      button { padding: 8px 10px; font-size: 12px; }
      main { padding: 8px; gap: 8px; }
      .control-panel { padding: 12px; }
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <div class="logo"><span class="material-icons">terrain</span></div>
      <div class="title">
        <h1>Enhanced NFT Areas</h1>
        <p>Click any area to mint with dynamic pricing (1-100 POL)</p>
      </div>
    </div>
    <div class="actions">
      <span class="pill price">
        <span class="material-icons">paid</span>
        Dynamic Pricing: <strong>1-100 POL</strong>
      </span>
      <button id="connectBtn" class="primary">
        <span class="material-icons">account_balance_wallet</span>Connect
      </button>
      <span id="wallet" class="pill" style="display:none;"></span>
    </div>
  </header>

  <main>
    <div class="map-container">
      <div id="map"></div>
      <div class="map-legend">
        <div class="legend-title">Area Status</div>
        <div class="legend-items">
          <div class="legend-item">
            <div class="legend-color" style="background:#1e293b;"></div>
            <span>Available</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background:#4f46e5;"></div>
            <span>Selected</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background:#f59e0b;"></div>
            <span>Minted by Others</span>
          </div>
          <div class="legend-item">
            <div class="legend-color" style="background:#10b981;"></div>
            <span>Owned by You</span>
          </div>
        </div>
      </div>
      <div id="loadingOverlay" class="loading-overlay">
        <span class="spinner"></span>
        <span>Loading area data...</span>
      </div>
    </div>

    <div class="control-panel">
      <div class="section">
        <h3>Statistics</h3>
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="totalMinted">0</div>
            <div class="stat-label">Total Minted</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="yourOwned">0</div>
            <div class="stat-label">You Own</div>
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Selected Area</h3>
        <div id="selectionInfo" class="selection-info empty">
          <span class="material-icons" style="font-size:32px;color:var(--muted);margin-bottom:8px;">place</span>
          <div>Click on the map to select an area</div>
        </div>
      </div>

      <div class="section">
        <div class="action-buttons">
          <button id="mintBtn" class="success" disabled>
            <span class="material-icons">rocket_launch</span>Mint Selected Area
          </button>
          <button id="clearBtn" class="accent">
            <span class="material-icons">clear</span>Clear Selection
          </button>
          <button id="refreshBtn">
            <span class="material-icons">refresh</span>Refresh Data
          </button>
        </div>
        <div id="status" class="status"></div>
      </div>
    </div>
  </main>

  <script>
    // Configuration
    const POLYGON_PARAMS = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'POL', symbol: 'POL', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com/'],
      blockExplorerUrls: ['https://polygonscan.com/']
    };

    const CONTRACT_ADDRESS = "0xb7d9E197905A0Fe7A59d82029eEFCBfDa631E2CC";
    const CONTRACT_ABI = [
      "function mintWithURI(string tokenURI) external payable returns (uint256)",
      "function mintPriceForArea(uint256 areaSizeKm2) view returns (uint256)",
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"
    ];

    const firebaseConfig = {
      apiKey: "AIzaSyC6wYBu-KOXkDmB-84_7OPtY71zBX4FzRY",
      authDomain: "newnft-47bd7.firebaseapp.com",
      databaseURL: "https://newnft-47bd7-default-rtdb.firebaseio.com",
      projectId: "newnft-47bd7",
      storageBucket: "newnft-47bd7.firebasestorage.app",
      messagingSenderId: "172043823738",
      appId: "1:172043823738:web:daf1fcfb7862d7d8f029c3",
      measurementId: "G-8VB3DYRNXR"
    };

    // Global state
    let map;
    let selectedArea = null;
    let mintedAreas = new Set();
    let ownedAreas = new Set();
    let web3Provider, signer, userAddress;
    let fbApp, fbDb;
    let nestedAreaFeatures = []; // For tracking areas within larger minted areas

    // UI Elements
    const connectBtn = document.getElementById('connectBtn');
    const walletEl = document.getElementById('wallet');
    const mintBtn = document.getElementById('mintBtn');
    const clearBtn = document.getElementById('clearBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const statusEl = document.getElementById('status');
    const selectionInfo = document.getElementById('selectionInfo');
    const totalMintedEl = document.getElementById('totalMinted');
    const yourOwnedEl = document.getElementById('yourOwned');
    const loadingOverlay = document.getElementById('loadingOverlay');

    // Utility functions
    function showLoading(show = true) {
      loadingOverlay.classList.toggle('show', show);
    }

    function setStatus(msg, type = '') {
      if (!msg) {
        statusEl.textContent = '';
        statusEl.className = 'status';
        return;
      }
      statusEl.className = 'status';
      if (type) statusEl.classList.add(type);
      if (type === 'loading') {
        statusEl.innerHTML = `<span class="spinner"></span><span>${msg}</span>`;
      } else {
        statusEl.textContent = msg;
      }
    }

    function showToast(message, type = 'success') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.innerHTML = `
        <div style="display:flex;align-items:center;gap:8px;">
          <span class="material-icons">${type === 'success' ? 'check_circle' : 'error'}</span>
          <span>${message}</span>
        </div>
      `;
      document.body.appendChild(toast);
      setTimeout(() => toast.classList.add('show'), 100);
      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => document.body.removeChild(toast), 300);
      }, 4000);
    }

    function calculateAreaSize(geojson) {
      try {
        const area = turf.area(geojson);
        return area / 1000000; // Convert to km¬≤
      } catch (e) {
        console.warn('Failed to calculate area:', e);
        return 1; // Default to 1 km¬≤ if calculation fails
      }
    }

    function calculatePrice(areaSizeKm2) {
      // Price formula: logarithmic scale from 1 to 100 POL
      const minPrice = 1;
      const maxPrice = 100;
      const minSize = 0.01; // 0.01 km¬≤
      const maxSize = 10000; // 10,000 km¬≤
      
      const normalizedSize = Math.max(minSize, Math.min(maxSize, areaSizeKm2));
      const logSize = Math.log(normalizedSize / minSize) / Math.log(maxSize / minSize);
      const price = minPrice + (maxPrice - minPrice) * logSize;
      
      return Math.max(minPrice, Math.min(maxPrice, Math.round(price * 100) / 100));
    }

    function formatArea(km2) {
      if (km2 < 0.01) return `${(km2 * 1000000).toFixed(0)} m¬≤`;
      if (km2 < 1) return `${(km2 * 100).toFixed(1)} hectares`;
      return `${km2.toFixed(2)} km¬≤`;
    }

    function shortenName(name, maxLength = 40) {
      if (name.length <= maxLength) return name;
      const firstComma = name.indexOf(',');
      if (firstComma > 0 && firstComma <= maxLength) {
        return name.slice(0, firstComma);
      }
      return name.slice(0, maxLength - 3) + '...';
    }

    // Map initialization with MapLibre GL
    function initMap() {
      map = new maplibregl.Map({
        container: 'map',
        style: {
          version: 8,
          sources: {
            'osm': {
              type: 'raster',
              tiles: ['https://tile.openstreetmap.org/{z}/{x}/{y}.png'],
              tileSize: 256,
              attribution: '¬© OpenStreetMap contributors'
            }
          },
          layers: [
            {
              id: 'osm',
              type: 'raster',
              source: 'osm'
            }
          ]
        },
        center: [0, 20],
        zoom: 2,
        attributionControl: false
      });

      map.addControl(new maplibregl.NavigationControl(), 'top-right');
      map.addControl(new maplibregl.AttributionControl({
        customAttribution: '¬© OpenStreetMap contributors'
      }), 'bottom-right');

      map.on('load', () => {
        setupMapLayers();
        initFirebase();
        setStatus('Click on the map to select an area', 'success');
      });

      map.on('click', onMapClick);
    }

    function setupMapLayers() {
      // Add sources for different area types
      map.addSource('selected-area', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      map.addSource('minted-areas', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      map.addSource('nested-areas', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });

      // Minted areas (lowest z-index)
      map.addLayer({
        id: 'minted-areas-fill',
        type: 'fill',
        source: 'minted-areas',
        paint: {
          'fill-color': [
            'case',
            ['get', 'owned'], '#10b981',
            '#f59e0b'
          ],
          'fill-opacity': 0.4
        }
      });

      map.addLayer({
        id: 'minted-areas-line',
        type: 'line',
        source: 'minted-areas',
        paint: {
          'line-color': [
            'case',
            ['get', 'owned'], '#10b981',
            '#f59e0b'
          ],
          'line-width': 2,
          'line-opacity': 0.8
        }
      });

      // Nested areas (medium z-index) - areas within larger minted areas
      map.addLayer({
        id: 'nested-areas-fill',
        type: 'fill',
        source: 'nested-areas',
        paint: {
          'fill-color': '#4338ca',
          'fill-opacity': 0.3
        }
      });

      map.addLayer({
        id: 'nested-areas-line',
        type: 'line',
        source: 'nested-areas',
        paint: {
          'line-color': '#4338ca',
          'line-width': 1,
          'line-opacity': 0.6,
          'line-dasharray': [2, 2]
        }
      });

      // Selected area (highest z-index)
      map.addLayer({
        id: 'selected-area-fill',
        type: 'fill',
        source: 'selected-area',
        paint: {
          'fill-color': '#4f46e5',
          'fill-opacity': 0.6
        }
      });

      map.addLayer({
        id: 'selected-area-line',
        type: 'line',
        source: 'selected-area',
        paint: {
          'line-color': '#4f46e5',
          'line-width': 3,
          'line-opacity': 1
        }
      });

      // Click handlers
      map.on('click', 'minted-areas-fill', (e) => {
        if (e.features.length > 0) {
          selectExistingArea(e.features[0]);
        }
      });

      map.on('click', 'nested-areas-fill', (e) => {
        if (e.features.length > 0) {
          selectNestedArea(e.features[0]);
        }
      });

      // Hover effects
      map.on('mouseenter', 'minted-areas-fill', () => {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'minted-areas-fill', () => {
        map.getCanvas().style.cursor = '';
      });

      map.on('mouseenter', 'nested-areas-fill', () => {
        map.getCanvas().style.cursor = 'pointer';
      });

      map.on('mouseleave', 'nested-areas-fill', () => {
        map.getCanvas().style.cursor = '';
      });
    }

    async function onMapClick(e) {
      if (e.defaultPrevented) return;
      
      try {
        showLoading(true);
        setStatus('Looking up area...', 'loading');
        
        const { lng, lat } = e.lngLat;
        const area = await reverseGeocodeArea(lat, lng);
        
        if (area) {
          await selectNewArea(area);
          setStatus('Area selected successfully', 'success');
        } else {
          setStatus('No area found at this location', 'error');
        }
      } catch (error) {
        console.error('Error selecting area:', error);
        setStatus('Failed to select area', 'error');
      } finally {
        showLoading(false);
      }
    }

    async function reverseGeocodeArea(lat, lng) {
      const zoom = Math.max(8, Math.min(18, map.getZoom()));
      const url = `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lng}&zoom=${zoom}&polygon_geojson=1&addressdetails=1`;
      
      try {
        await new Promise(resolve => setTimeout(resolve, 100)); // Rate limiting
        
        const response = await fetch(url, {
          headers: { 'Accept-Language': 'en' }
        });
        
        if (!response.ok) throw new Error('Geocoding failed');
        
        const data = await response.json();
        if (!data.geojson || !data.osm_id) return null;
        
        const areaId = `osm_${data.osm_type}_${data.osm_id}`;
        const name = data.display_name || 'Unknown Area';
        const type = `${data.class || 'unknown'}:${data.type || 'unknown'}`;
        
        return {
          id: areaId,
          name: name,
          type: type,
          center: { lat: parseFloat(data.lat), lng: parseFloat(data.lon) },
          geojson: data.geojson,
          osmId: data.osm_id,
          osmType: data.osm_type
        };
      } catch (error) {
        console.error('Reverse geocoding error:', error);
        return null;
      }
    }

    async function selectNewArea(area) {
      selectedArea = area;
      
      // Calculate area size and price
      const sizeKm2 = calculateAreaSize(area.geojson);
      const price = calculatePrice(sizeKm2);
      
      selectedArea.sizeKm2 = sizeKm2;
      selectedArea.price = price;
      selectedArea.minted = mintedAreas.has(area.id);
      selectedArea.owned = ownedAreas.has(area.id);
      
      // Check if this area is within a larger minted area
      selectedArea.isNested = await checkIfNestedInMintedArea(area);
      
      // Update map
      map.getSource('selected-area').setData({
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: area.geojson,
          properties: { ...area }
        }]
      });
      
      // Fit bounds to selected area
      try {
        const bbox = turf.bbox(area.geojson);
        map.fitBounds(bbox, { padding: 50 });
      } catch (e) {
        map.setCenter([area.center.lng, area.center.lat]);
        map.setZoom(Math.max(map.getZoom(), 12));
      }
      
      updateSelectionUI();
      updateMintButton();
    }

    function selectExistingArea(feature) {
      const properties = feature.properties;
      selectedArea = {
        id: properties.id,
        name: properties.name,
        type: properties.type,
        center: properties.center,
        geojson: feature.geometry,
        sizeKm2: properties.sizeKm2,
        price: properties.price,
        minted: true,
        owned: properties.owned,
        isNested: false
      };
      
      // Update selected area source
      map.getSource('selected-area').setData({
        type: 'FeatureCollection',
        features: [feature]
      });
      
      updateSelectionUI();
      updateMintButton();
    }

    function selectNestedArea(feature) {
      const properties = feature.properties;
      selectedArea = {
        id: properties.id,
        name: properties.name,
        type: properties.type,
        center: properties.center,
        geojson: feature.geometry,
        sizeKm2: properties.sizeKm2,
        price: properties.price,
        minted: false,
        owned: false,
        isNested: true,
        parentArea: properties.parentArea
      };
      
      map.getSource('selected-area').setData({
        type: 'FeatureCollection',
        features: [feature]
      });
      
      updateSelectionUI();
      updateMintButton();
    }

    async function checkIfNestedInMintedArea(area) {
      // Check if the selected area is contained within any minted area
      try {
        const areaFeature = turf.feature(area.geojson);
        const mintedFeatures = map.getSource('minted-areas')._data.features;
        
        for (const mintedFeature of mintedFeatures) {
          try {
            if (turf.booleanContains(mintedFeature, areaFeature)) {
              return {
                contained: true,
                parentId: mintedFeature.properties.id,
                parentName: mintedFeature.properties.name
              };
            }
          } catch (e) {
            // Skip invalid geometries
            continue;
          }
        }
        return { contained: false };
      } catch (e) {
        console.warn('Error checking nested area:', e);
        return { contained: false };
      }
    }

    function updateSelectionUI() {
      if (!selectedArea) {
        selectionInfo.className = 'selection-info empty';
        selectionInfo.innerHTML = `
          <span class="material-icons" style="font-size:32px;color:var(--muted);margin-bottom:8px;">place</span>
          <div>Click on the map to select an area</div>
        `;
        return;
      }

      selectionInfo.className = 'selection-info';
      
      const statusText = selectedArea.owned ? 'You own this area' :
                        selectedArea.minted ? 'Already minted' :
                        selectedArea.isNested?.contained ? 'Nested area (mintable)' : 'Available to mint';
      
      const statusColor = selectedArea.owned ? 'var(--success)' :
                         selectedArea.minted ? 'var(--warning)' :
                         selectedArea.isNested?.contained ? 'var(--primary)' : 'var(--accent)';

      selectionInfo.innerHTML = `
        <div class="selection-title">${shortenName(selectedArea.name)}</div>
        <div class="selection-detail">Type: ${selectedArea.type}</div>
        <div class="selection-detail">Size: ${formatArea(selectedArea.sizeKm2)}</div>
        <div class="selection-detail">Center: ${selectedArea.center.lat.toFixed(5)}, ${selectedArea.center.lng.toFixed(5)}</div>
        ${selectedArea.isNested?.contained ? 
          `<div class="selection-detail">Within: ${shortenName(selectedArea.isNested.parentName)}</div>` : ''}
        <div class="selection-detail" style="color:${statusColor};font-weight:600;">${statusText}</div>
        ${!selectedArea.minted ? `
          <div class="price-display">
            <div class="price-value">${selectedArea.price} POL</div>
            <div style="font-size:11px;color:var(--muted);">Mint Price</div>
          </div>
        ` : ''}
      `;
    }

    function updateMintButton() {
      const canMint = userAddress && selectedArea && !selectedArea.minted;
      mintBtn.disabled = !canMint;
      
      if (!userAddress) {
        mintBtn.innerHTML = '<span class="material-icons">account_balance_wallet</span>Connect Wallet First';
      } else if (!selectedArea) {
        mintBtn.innerHTML = '<span class="material-icons">place</span>Select an Area';
      } else if (selectedArea.minted) {
        mintBtn.innerHTML = '<span class="material-icons">check_circle</span>Already Minted';
      } else {
        mintBtn.innerHTML = `<span class="material-icons">rocket_launch</span>Mint for ${selectedArea.price} POL`;
      }
    }

    function clearSelection() {
      selectedArea = null;
      map.getSource('selected-area').setData({
        type: 'FeatureCollection',
        features: []
      });
      updateSelectionUI();
      updateMintButton();
      setStatus('Selection cleared', 'success');
    }

    // Wallet functions
    async function connectWallet() {
      if (!window.ethereum) {
        setStatus('Please install MetaMask', 'error');
        return;
      }

      try {
        setStatus('Connecting wallet...', 'loading');
        
        // Switch to Polygon
        try {
          await window.ethereum.request({
            method: 'wallet_switchEthereumChain',
            params: [{ chainId: POLYGON_PARAMS.chainId }]
          });
        } catch (switchError) {
          if (switchError.code === 4902) {
            await window.ethereum.request({
              method: 'wallet_addEthereumChain',
              params: [POLYGON_PARAMS]
            });
          } else {
            throw switchError;
          }
        }

        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        await web3Provider.send('eth_requestAccounts', []);
        signer = web3Provider.getSigner();
        userAddress = await signer.getAddress();

        connectBtn.style.display = 'none';
        walletEl.style.display = 'inline-flex';
        walletEl.innerHTML = `
          <span class="material-icons">account_balance_wallet</span>
          ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}
        `;

        updateMintButton();
        await refreshMintedAreas();
        setStatus('Wallet connected successfully', 'success');
        showToast('Wallet connected successfully');

        // Listen for account changes
        window.ethereum.on('accountsChanged', (accounts) => {
          if (accounts.length === 0) {
            location.reload();
          } else {
            userAddress = accounts[0];
            walletEl.innerHTML = `
              <span class="material-icons">account_balance_wallet</span>
              ${userAddress.slice(0, 6)}...${userAddress.slice(-4)}
            `;
            refreshMintedAreas();
          }
        });

      } catch (error) {
        console.error('Wallet connection failed:', error);
        setStatus('Failed to connect wallet', 'error');
      }
    }

    // Minting function
    async function mintSelectedArea() {
      if (!selectedArea || !userAddress) return;

      try {
        setStatus('Preparing mint transaction...', 'loading');
        
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
        const priceWei = ethers.utils.parseEther(selectedArea.price.toString());
        
        // Build token metadata
        const metadata = {
          name: `Area: ${shortenName(selectedArea.name)}`,
          description: `NFT representing ${selectedArea.name} (${formatArea(selectedArea.sizeKm2)})`,
          image: generateAreaSVG(selectedArea),
          attributes: [
            { trait_type: "Area ID", value: selectedArea.id },
            { trait_type: "Area Type", value: selectedArea.type },
            { trait_type: "Size (km¬≤)", value: selectedArea.sizeKm2 },
            { trait_type: "Price (POL)", value: selectedArea.price },
            { trait_type: "Center Latitude", value: selectedArea.center.lat },
            { trait_type: "Center Longitude", value: selectedArea.center.lng },
            { trait_type: "Is Nested", value: selectedArea.isNested?.contained || false }
          ],
          area_data: {
            id: selectedArea.id,
            geojson: selectedArea.geojson,
            osm_type: selectedArea.osmType,
            osm_id: selectedArea.osmId
          }
        };

        const tokenURI = `data:application/json;base64,${btoa(JSON.stringify(metadata))}`;
        
        setStatus('Confirming transaction...', 'loading');
        const tx = await contract.mintWithURI(tokenURI, { value: priceWei });
        
        setStatus('Mining transaction...', 'loading');
        const receipt = await tx.wait();
        
        // Update local state
        mintedAreas.add(selectedArea.id);
        ownedAreas.add(selectedArea.id);
        selectedArea.minted = true;
        selectedArea.owned = true;
        
        // Write to Firebase
        await writeMintedAreaToFirebase(selectedArea, userAddress);
        
        updateSelectionUI();
        updateMintButton();
        updateStats();
        await refreshMintedAreas();
        
        setStatus('Area minted successfully!', 'success');
        showToast(`Successfully minted ${shortenName(selectedArea.name)}!`);

      } catch (error) {
        console.error('Minting failed:', error);
        const message = error.message || 'Unknown error occurred';
        setStatus(`Minting failed: ${message}`, 'error');
        showToast('Minting failed', 'error');
      }
    }

    function generateAreaSVG(area) {
      const name = shortenName(area.name, 30);
      const type = area.type;
      const size = formatArea(area.sizeKm2);
      const price = area.price;

      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="400" height="400" viewBox="0 0 400 400">
          <defs>
            <linearGradient id="bg" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" style="stop-color:#4f46e5;stop-opacity:1" />
              <stop offset="100%" style="stop-color:#06b6d4;stop-opacity:1" />
            </linearGradient>
          </defs>
          <rect width="400" height="400" fill="url(#bg)"/>
          <rect x="20" y="20" width="360" height="360" rx="20" fill="rgba(255,255,255,0.1)" stroke="rgba(255,255,255,0.2)" stroke-width="2"/>
          
          <text x="200" y="80" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="24" font-weight="bold">${name}</text>
          <text x="200" y="120" text-anchor="middle" fill="rgba(255,255,255,0.8)" font-family="Arial, sans-serif" font-size="16">${type}</text>
          <text x="200" y="160" text-anchor="middle" fill="rgba(255,255,255,0.8)" font-family="Arial, sans-serif" font-size="16">Size: ${size}</text>
          <text x="200" y="200" text-anchor="middle" fill="rgba(255,255,255,0.8)" font-family="Arial, sans-serif" font-size="16">Price: ${price} POL</text>
          
          <circle cx="200" cy="280" r="60" fill="rgba(255,255,255,0.2)"/>
          <text x="200" y="290" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="32">üèîÔ∏è</text>
          
          <text x="200" y="350" text-anchor="middle" fill="rgba(255,255,255,0.6)" font-family="Arial, sans-serif" font-size="14">Enhanced NFT Areas</text>
        </svg>
      `;

      return `data:image/svg+xml;base64,${btoa(svg)}`;
    }

    // Firebase functions
    function initFirebase() {
      try {
        fbApp = firebase.initializeApp(firebaseConfig);
        fbDb = firebase.database();
        
        // Listen for real-time updates
        fbDb.ref('areas').on('value', (snapshot) => {
          const data = snapshot.val();
          if (data) {
            updateMintedAreasFromFirebase(data);
          }
        });
        
        refreshMintedAreas();
      } catch (error) {
        console.error('Firebase initialization failed:', error);
      }
    }

    async function writeMintedAreaToFirebase(area, owner) {
      if (!fbDb) return;
      
      try {
        const areaData = {
          id: area.id,
          name: area.name,
          type: area.type,
          sizeKm2: area.sizeKm2,
          price: area.price,
          center: area.center,
          geojson: area.geojson,
          owner: owner,
          mintedAt: Date.now(),
          isNested: area.isNested?.contained || false,
          parentArea: area.isNested?.parentId || null
        };
        
        await fbDb.ref(`areas/${area.id}`).set(areaData);
      } catch (error) {
        console.error('Failed to write to Firebase:', error);
      }
    }

    function updateMintedAreasFromFirebase(data) {
      const features = [];
      const nestedFeatures = [];
      
      mintedAreas.clear();
      ownedAreas.clear();
      
      Object.values(data).forEach(area => {
        mintedAreas.add(area.id);
        if (userAddress && area.owner.toLowerCase() === userAddress.toLowerCase()) {
          ownedAreas.add(area.id);
        }
        
        const feature = {
          type: 'Feature',
          geometry: area.geojson,
          properties: {
            id: area.id,
            name: area.name,
            type: area.type,
            sizeKm2: area.sizeKm2,
            price: area.price,
            center: area.center,
            owned: userAddress && area.owner.toLowerCase() === userAddress.toLowerCase()
          }
        };
        
        if (area.isNested) {
          nestedFeatures.push(feature);
        } else {
          features.push(feature);
        }
      });
      
      // Update map sources
      map.getSource('minted-areas').setData({
        type: 'FeatureCollection',
        features: features
      });
      
      map.getSource('nested-areas').setData({
        type: 'FeatureCollection',
        features: nestedFeatures
      });
      
      updateStats();
      if (selectedArea) {
        selectedArea.minted = mintedAreas.has(selectedArea.id);
        selectedArea.owned = ownedAreas.has(selectedArea.id);
        updateSelectionUI();
        updateMintButton();
      }
    }

    async function refreshMintedAreas() {
      try {
        setStatus('Refreshing minted areas...', 'loading');
        
        if (!fbDb) {
          setStatus('Database not connected', 'error');
          return;
        }
        
        const snapshot = await fbDb.ref('areas').once('value');
        const data = snapshot.val();
        
        if (data) {
          updateMintedAreasFromFirebase(data);
        }
        
        setStatus('Data refreshed successfully', 'success');
      } catch (error) {
        console.error('Failed to refresh areas:', error);
        setStatus('Failed to refresh data', 'error');
      }
    }

    function updateStats() {
      totalMintedEl.textContent = mintedAreas.size;
      yourOwnedEl.textContent = ownedAreas.size;
    }

    // Event listeners
    connectBtn.addEventListener('click', connectWallet);
    mintBtn.addEventListener('click', mintSelectedArea);
    clearBtn.addEventListener('click', clearSelection);
    refreshBtn.addEventListener('click', refreshMintedAreas);

    // Initialize the app
    document.addEventListener('DOMContentLoaded', () => {
      initMap();
      updateStats();
      
      // Auto-connect if wallet is already connected
      if (window.ethereum?.selectedAddress) {
        connectWallet();
      }
    });
  </script>
</body>
</html>
