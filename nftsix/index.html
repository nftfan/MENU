<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NFT FANS 2026 // RAINBOW RUNNER</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">
  <style>
    :root {
      --rainbow: linear-gradient(120deg, #ff4d79, #ff9f0a, #fcee0a, #00f0ff, #8b5cf6, #ff4d79);
      --bg: #050505;
      --panel: #0d0f1a;
      --text: #f5f7ff;
      --muted: #9fb0d6;
      --err: #ff4f7a;
      --ok: #8df7c4;
    }
    * { box-sizing: border-box; }
    body {
      margin:0;
      font-family:'Courier New',monospace;
      min-height:100vh;
      padding:10px;
      background: radial-gradient(circle at 10% 20%, rgba(255,77,121,0.18), transparent 35%),
                  radial-gradient(circle at 90% 10%, rgba(139,92,246,0.18), transparent 35%),
                  var(--bg);
      color: var(--text);
      font-size: 10px;
      text-transform: uppercase;
      display:flex; justify-content:center;
    }
    @keyframes glow { 0%{box-shadow:0 0 8px rgba(255,255,255,0.2);} 50%{box-shadow:0 0 18px rgba(255,255,255,0.35);} 100%{box-shadow:0 0 8px rgba(255,255,255,0.2);} }
    @keyframes hue { 0%{filter:hue-rotate(0deg);} 100%{filter:hue-rotate(360deg);} }

    .layout{width:100%;max-width:1000px;}
    header{
      display:flex;justify-content:space-between;align-items:flex-end;
      border-bottom:2px solid #fff2;
      padding-bottom:8px;margin-bottom:10px;gap:10px;
    }
    h1{
      margin:0;font-size:10px;line-height:1;
      padding:3px 8px;
      background:var(--rainbow);
      color:#050505;
      font-weight:900;
      letter-spacing:0.5px;
      animation:hue 6s linear infinite;
    }
    .status-bar{display:flex;gap:8px;align-items:center;}
    .pill{
      padding:4px 10px;
      border:1px solid #fff2;
      border-radius:999px;
      background: #0b1221;
      color: var(--muted);
      display:flex;align-items:center;gap:4px;
    }
    .pill i{font-size:12px;}
    .btn{
      font-family:inherit;font-size:10px;font-weight:900;
      text-transform:uppercase;
      background:transparent;color:#fff;
      border:2px solid transparent;
      padding:6px 14px;cursor:pointer;position:relative;
      transition:all .14s;
      background-image: var(--rainbow);
      border-image: var(--rainbow) 1;
      clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
      animation: glow 2.8s ease-in-out infinite;
    }
    .btn:hover:not(:disabled){filter:brightness(1.1);}
    .btn:active:not(:disabled){transform:translate(1px,1px);}
    .btn:disabled{opacity:0.35;cursor:not-allowed;animation:none;}
    .btn-mint{
      width:100%;margin-top:8px;padding:8px;
      background: var(--rainbow);color:#050505;border:none;font-weight:900;
    }
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px;}
    .card{
      background:var(--panel);
      border:1px solid #fff1;
      padding:6px;
      position:relative;
      animation: glow 3.6s ease-in-out infinite;
    }
    .frame{
      width:100%;aspect-ratio:1/1;background:#000;border:1px solid #111;
      display:flex;align-items:center;justify-content:center;margin-bottom:6px;position:relative;
    }
    .frame img, .frame video{width:100%;height:100%;object-fit:contain;display:block;}
    .info-row{display:flex;justify-content:space-between;align-items:center;padding-left:4px;margin-bottom:4px;border-left:2px solid #00f0ff44;}
    .title{font-weight:bold;color:#fff;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:110px;}
    .price{color:#8df7ff;}
    .status{margin-bottom:10px;color:#8df7ff;border-left:2px solid #00f0ff44;padding-left:8px;min-height:14px;}
    .status.err{color:var(--err);border-color:var(--err);}
    .controls{display:flex;gap:8px;align-items:center;margin-bottom:8px;}
    .select{
      background:#0b0b0b;color:#8df7ff;border:1px solid #00f0ff66;
      padding:6px 8px;font-size:10px;text-transform:uppercase;letter-spacing:0.5px;
    }
  </style>
</head>
<body>
  <div class="layout">
    <header>
      <div style="display:flex;flex-direction:column;gap:4px;">
        <h1>NFT FANS 2026</h1>
        <div style="font-size:9px;color:#888;">// POLYGON MAINNET [137]</div>
      </div>
      <div class="status-bar">
        <div id="addr" class="pill"><i class="material-icons-round">link_off</i><span>DISCONNECTED</span></div>
        <button id="connectBtn" class="btn">LINK START</button>
      </div>
    </header>

    <div class="controls">
      <div style="color:#fcee0a;font-weight:700;">SORT</div>
      <select id="sortSelect" class="select">
        <option value="date_desc">DATE ↓</option>
        <option value="date_asc">DATE ↑</option>
        <option value="price_desc">PRICE ↓</option>
        <option value="price_asc">PRICE ↑</option>
      </select>
      <div id="netStatus" class="pill"><i class="material-icons-round">visibility</i><span>READ-ONLY RPC</span></div>
    </div>

    <div id="status" class="status">SYSTEM READY...</div>
    <div id="grid" class="grid"></div>
  </div>

  <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.8.0/firebase-database-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.11.1/dist/ethers.umd.min.js"></script>

  <script>
    /* CONFIG */
    const firebaseConfig = {
      apiKey: "AIzaSyBuBB-Cha7eLG1O7SxOTfFt8e6hVAWjkxI",
      authDomain: "tokentransfer-4a9b3.firebaseapp.com",
      databaseURL: "https://tokentransfer-4a9b3-default-rtdb.firebaseio.com",
      projectId: "tokentransfer-4a9b3",
      storageBucket: "tokentransfer-4a9b3.firebasestorage.app",
      messagingSenderId: "205455490321",
      appId: "1:205455490321:web:9919f5dde059316c9320b0",
      measurementId: "G-Y6CVEDL9XH"
    };
    const CONTRACT_ADDRESS = "0xe220Bc80B77769407d127A195920D527200674e0";
    const EXPECTED_CHAIN_ID = 137;
    const READ_RPC = "https://polygon-rpc.com";

    const ABI = [
      "function mint(string tokenURI, uint256 priceWei) payable",
      "function totalMinted() view returns (uint256)",
      "function isMintedURI(string tokenURI) view returns (bool)"
    ];

    /* STATE */
    let provider, signer, contract, userAddress;
    const readProvider = new ethers.JsonRpcProvider(READ_RPC);
    const readContract = new ethers.Contract(CONTRACT_ADDRESS, ABI, readProvider);
    const db = firebase.initializeApp(firebaseConfig).database();

    const gridEl = document.getElementById('grid');
    const statusEl = document.getElementById('status');
    const addrEl = document.getElementById('addr');
    const connectBtn = document.getElementById('connectBtn');
    const sortSelect = document.getElementById('sortSelect');
    const netStatus = document.getElementById('netStatus');

    let currentEntries = [];
    const mintedMap = new Map(); // uri -> bool

    function setStatus(msg, cls = "") {
      statusEl.className = `status ${cls}`;
      statusEl.textContent = `>> ${msg.toUpperCase()}`;
    }
    function shorten(addr) { return addr ? addr.slice(0,6)+"..."+addr.slice(-4) : "DISCONNECTED"; }

    async function switchToPolygon() {
      const chainIdHex = "0x89"; // 137
      try {
        await window.ethereum.request({ method: "wallet_switchEthereumChain", params: [{ chainId: chainIdHex }] });
      } catch (err) {
        if (err.code === 4902) {
          await window.ethereum.request({
            method: "wallet_addEthereumChain",
            params: [{
              chainId: chainIdHex,
              chainName: "Polygon Mainnet",
              nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
              rpcUrls: [READ_RPC],
              blockExplorerUrls: ["https://polygonscan.com"]
            }]
          });
        } else {
          throw err;
        }
      }
    }

    async function ensureWallet() {
      if (!window.ethereum) { setStatus("NO WEB3 INTERFACE FOUND","err"); throw new Error("No wallet"); }
      await switchToPolygon();
      provider = new ethers.BrowserProvider(window.ethereum,"any");
      const network = await provider.getNetwork();
      if (Number(network.chainId) !== EXPECTED_CHAIN_ID) { setStatus("NET_ERR: SWITCH FAILED","err"); throw new Error("Wrong network"); }
      const accounts = await provider.send("eth_requestAccounts", []);
      signer = await provider.getSigner();
      userAddress = accounts[0];
      addrEl.innerHTML = `<i class="material-icons-round">link</i><span>${shorten(userAddress)}</span>`;
      contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
    }

    connectBtn.addEventListener('click', async () => {
      connectBtn.disabled = true;
      setStatus("INITIALIZING UPLINK...");
      try { await ensureWallet(); setStatus("CONNECTION ESTABLISHED","ok"); connectBtn.textContent = "CONNECTED"; }
      catch(e){ 
        console.error(e); 
        addrEl.innerHTML = `<i class="material-icons-round">link_off</i><span>DISCONNECTED</span>`;
        setStatus("CONNECTION FAILED","err");
        connectBtn.textContent = "LINK START";
      }
      finally{ connectBtn.disabled = false; }
    });

    async function mint(tokenURI, pricePol) {
      if (!tokenURI) return setStatus("ERR: NULL URI DATA","err");
      if (typeof pricePol === "undefined" || pricePol === null || pricePol === "") return setStatus("ERR: PRICE MISSING","err");
      let priceWei;
      try { priceWei = ethers.parseEther(pricePol.toString()); }
      catch { return setStatus("ERR: BAD PRICE FORMAT","err"); }
      setStatus("AWAITING BIO-SIG (WALLET)...");
      try {
        await ensureWallet();
        const tx = await contract.mint(tokenURI, priceWei, { value: priceWei, gasLimit: 500000 }); // Increased gas limit
        setStatus("TX PENDING... STANDBY");
        await tx.wait();
        setStatus("MINT CONFIRMED. ASSET SECURED.","ok");
        mintedMap.set(tokenURI, true);
        renderList(); // refresh buttons
      } catch (err) {
        console.error(err);
        if (err && err.message) {
          setStatus("TX FAILED: " + err.message, "err");
        } else {
          setStatus("TX FAILED / REJECTED","err");
        }
      }
    }

    /**
     * Check if string is probably a video url by extension
     */
    function isLikelyVideo(url) {
      if (!url) return false;
      // handled extensions (covers most common video types)
      const videoExts = ['.mp4', '.webm', '.ogg', '.mov', '.m4v'];
      const lower = url.split('?')[0].toLowerCase();
      return videoExts.some(ext => lower.endsWith(ext))
        || lower.includes('video')
        || (lower.startsWith('https://coming-blush-wolverine.myfilebase.com/ipfs/') && !/\.(png|jpg|jpeg|gif|svg|webp)\b/i.test(lower));
    }

    function renderCard(id, data) {
      const card = document.createElement('div');
      card.className = 'card';

      const frame = document.createElement('div');
      frame.className = 'frame';
      // Render image or video
      const url = data.imageUrl || '';
      if (isLikelyVideo(url)) {
        const video = document.createElement('video');
        video.src = url;
        video.setAttribute('controls', 'controls');
        video.setAttribute('playsinline', 'playsinline');
        video.setAttribute('preload', 'metadata');
        video.style.background = "#101010";
        card.style.overflow = "hidden";
        // Optionally, autoload poster if provided as data.posterUrl
        if (data.posterUrl) video.setAttribute('poster', data.posterUrl);
        frame.appendChild(video);
      } else {
        const img = document.createElement('img');
        img.src = url;
        img.alt = 'ASSET';
        frame.appendChild(img);
      }
      card.appendChild(frame);

      const info = document.createElement('div');
      info.className = 'info-row';

      const title = document.createElement('div');
      title.className = 'title';
      title.textContent = (data.title || 'UNKNOWN').toUpperCase();
      info.appendChild(title);

      const price = document.createElement('div');
      price.className = 'price';
      const displayPrice = (typeof data.price !== "undefined" && data.price !== null && data.price !== "") ? `${data.price} POL` : "? POL";
      price.textContent = displayPrice;
      info.appendChild(price);
      card.appendChild(info);

      const btn = document.createElement('button');
      btn.className = 'btn btn-mint';
      const already = mintedMap.get(url) === true;
      btn.textContent = already ? 'MINTED' : 'MINT ASSET';
      btn.disabled = already;
      btn.onclick = () => !already && mint(url, data.price);
      card.appendChild(btn);

      return card;
    }

    function sortEntries(entries, mode) {
      return entries.slice().sort((a,b)=>{
        const da = a[1].createdAt || 0, db = b[1].createdAt || 0;
        const pa = parseFloat(a[1].price || "0"), pb = parseFloat(b[1].price || "0");
        switch(mode){
          case "date_asc": return da - db;
          case "price_desc": return pb - pa;
          case "price_asc": return pa - pb;
          case "date_desc":
          default: return db - da;
        }
      });
    }

    async function updateMintedStatuses(entries) {
      try {
        const checks = entries.map(([_, d]) => {
          const uri = d.imageUrl || "";
          if (!uri) return Promise.resolve([uri,false]);
          return readContract.isMintedURI(uri).then(v => [uri, v]).catch(()=>[uri,false]);
        });
        const results = await Promise.all(checks);
        results.forEach(([uri, val]) => mintedMap.set(uri, val));
        netStatus.innerHTML = `<i class="material-icons-round">visibility</i><span>READ-ONLY RPC OK</span>`;
        netStatus.style.borderColor = "#00f0ff";
        netStatus.style.color = "#00f0ff";
      } catch {
        netStatus.innerHTML = `<i class="material-icons-round">error</i><span>READ RPC ERROR</span>`;
        netStatus.style.borderColor = "#ff4f7a";
        netStatus.style.color = "#ff4f7a";
      }
    }

    function renderList() {
      gridEl.innerHTML = "";
      const mode = sortSelect.value;
      const sorted = sortEntries(currentEntries, mode);
      sorted.forEach(([id, data]) => gridEl.appendChild(renderCard(id, data)));
      setStatus(`DB SYNC COMPLETE: ${sorted.length} RECORDS`,"ok");
    }

    sortSelect.addEventListener('change', renderList);

    db.ref("nfts").orderByChild("createdAt").on("value", async (snapshot) => {
      const val = snapshot.val();
      if (!val) {
        currentEntries = [];
        gridEl.innerHTML = "";
        setStatus("DATABASE EMPTY","");
        return;
      }
      currentEntries = Object.entries(val);
      await updateMintedStatuses(currentEntries);
      renderList();
    }, (err) => {
      console.error(err);
      setStatus("DB READ ERROR","err");
    });
  </script>
</body>
</html>
