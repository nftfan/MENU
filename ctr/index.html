<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CyberTerritories — Mint your digital land</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;600;700&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
  <!-- Leaflet -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- Ethers -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Firebase (compat SDK) -->
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.13.1/firebase-database-compat.js"></script>
  <style>
    :root {
      --primary: #00f9ff;
      --primary-glow: rgba(0, 249, 255, 0.5);
      --primary-dark: #00b2ff;
      --accent: #ff2cf0;
      --accent-glow: rgba(255, 44, 240, 0.5);
      --success: #12ff9b;
      --success-glow: rgba(18, 255, 155, 0.4);
      --error: #ff3860;
      --error-glow: rgba(255, 56, 96, 0.4);
      --bg: #0c0b1d;
      --bg-dark: #07061a;
      --card: #12122a;
      --text: #eef2ff;
      --muted: #8f9cce;
      --border: #3e3f82;
      --border-glow: rgba(0, 249, 255, 0.2);
      --radius: 12px;
      --shadow: rgba(0, 0, 0, 0.4);
      --neon-shadow: 0 0 10px var(--primary-glow);
      --accent-shadow: 0 0 10px var(--accent-glow);
    }

    * { box-sizing: border-box; }
    
    html, body { 
      height: 100%; 
      scroll-behavior: smooth; 
      overscroll-behavior: none; 
      -webkit-tap-highlight-color: transparent;
    }
    
    body {
      margin: 0;
      font-family: 'Rajdhani', sans-serif;
      background: var(--bg-dark);
      color: var(--text);
      line-height: 1.4;
      overflow-x: hidden;
      letter-spacing: 0.2px;
      font-weight: 500;
    }

    #app-container {
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      background: radial-gradient(800px at 15% 15%, rgba(0, 249, 255, 0.08), transparent 70%),
                  radial-gradient(600px at 85% 20%, rgba(255, 44, 240, 0.08), transparent 70%),
                  linear-gradient(180deg, var(--bg-dark), var(--bg));
    }

    /* Cyberpunk animated background grid */
    .cyber-grid {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: -1;
      background-image: 
        linear-gradient(rgba(0, 249, 255, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 249, 255, 0.03) 1px, transparent 1px);
      background-size: 40px 40px;
      background-position: center center;
      perspective: 1000px;
      transform-style: preserve-3d;
      animation: gridPulse 20s infinite linear;
    }
    
    @keyframes gridPulse {
      0% { background-size: 40px 40px; }
      50% { background-size: 42px 42px; }
      100% { background-size: 40px 40px; }
    }

    /* Header */
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px;
      position: relative;
      z-index: 10;
    }

    .brand { 
      display: flex; 
      align-items: center; 
      gap: 12px; 
    }
    
    .logo {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      display: grid;
      place-items: center;
      box-shadow: 0 0 15px rgba(0, 249, 255, 0.4);
      position: relative;
      overflow: hidden;
    }
    
    .logo::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(transparent, var(--primary), transparent 30%);
      animation: rotate 4s linear infinite;
    }
    
    .logo::after {
      content: '';
      position: absolute;
      inset: 3px;
      border-radius: 6px;
      background: var(--bg-dark);
    }
    
    .logo .material-icons { 
      font-size: 22px;
      color: var(--primary);
      position: relative;
      z-index: 2;
      text-shadow: 0 0 8px var(--primary-glow);
    }

    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .title h1 { 
      margin: 0;
      font-size: 24px;
      font-weight: 700;
      font-family: 'Orbitron', sans-serif;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 5px rgba(0, 249, 255, 0.3);
    }
    
    .title p { 
      margin: 0;
      font-size: 14px;
      color: var(--muted);
    }

    .actions { 
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    /* Buttons */
    button {
      appearance: none;
      border: 1px solid transparent;
      border-radius: 8px;
      padding: 10px 14px;
      font-size: 14px;
      font-weight: 600;
      font-family: 'Rajdhani', sans-serif;
      color: var(--text);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: rgba(32, 33, 77, 0.6);
      border-color: var(--border);
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    button::after {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: 0.5s;
    }
    
    button:hover::after {
      left: 100%;
    }
    
    button .material-icons { font-size: 18px; }
    
    button.primary { 
      background: linear-gradient(135deg, var(--primary-dark), var(--primary));
      border-color: var(--primary);
      box-shadow: 0 0 10px var(--primary-glow);
      text-shadow: 0 0 5px var(--primary);
    }
    
    button.success { 
      background: linear-gradient(135deg, var(--success), #00ddb9);
      border-color: var(--success);
      box-shadow: 0 0 10px var(--success-glow);
      color: #07172c;
      font-weight: 700;
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
    }
    
    button.accent { 
      background: linear-gradient(135deg, var(--accent), #ff6afc);
      border-color: var(--accent);
      box-shadow: 0 0 10px var(--accent-glow);
      color: #07172c;
      font-weight: 700;
      text-shadow: 0 0 2px rgba(255, 255, 255, 0.5);
    }
    
    button:disabled { 
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none;
    }
    
    button:not(:disabled):active { 
      transform: translateY(1px) scale(0.98);
    }

    .wallet { 
      color: var(--primary);
      font-size: 14px;
      font-weight: 700;
      text-shadow: 0 0 5px var(--primary-glow);
      background: rgba(0, 249, 255, 0.1);
      padding: 4px 10px;
      border-radius: 8px;
      border: 1px solid rgba(0, 249, 255, 0.3);
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: rgba(15, 16, 40, 0.7);
      color: var(--muted);
      backdrop-filter: blur(5px);
    }
    
    .pill .material-icons {
      font-size: 16px;
      color: var(--primary);
    }

    /* Main content */
    main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
      padding: 0 16px 16px;
      flex: 1;
    }
    
    @media (min-width: 980px) {
      main {
        grid-template-columns: 1.6fr 1fr;
        max-width: 1440px;
        margin: 0 auto;
        width: 100%;
      }
    }

    /* Map container with neon border glow */
    .map-container {
      position: relative;
      width: 100%;
      height: 70vh;
      border-radius: var(--radius);
      grid-column: 1 / -1;
      overflow: hidden;
      background: var(--card);
      padding: 2px;
      background: linear-gradient(135deg, var(--primary), var(--accent));
      box-shadow: 0 0 25px rgba(0, 0, 0, 0.5),
                 0 0 15px var(--primary-glow);
    }
    
    #map {
      height: 100%;
      width: 100%;
      border-radius: calc(var(--radius) - 2px);
      overflow: hidden;
      background: #070814;
    }
    
    /* Custom map attribution style */
    .leaflet-control-attribution {
      background: rgba(7, 8, 30, 0.7) !important;
      color: var(--muted) !important;
      font-family: 'Rajdhani', sans-serif;
      font-size: 10px;
      backdrop-filter: blur(5px);
      border-radius: 4px !important;
      padding: 2px 5px !important;
    }
    
    .leaflet-control-attribution a {
      color: var(--primary) !important;
    }
    
    /* Custom zoom control style */
    .leaflet-control-zoom {
      border: none !important;
      border-radius: 8px !important;
      overflow: hidden;
    }
    
    .leaflet-control-zoom a {
      background: rgba(15, 16, 40, 0.9) !important;
      color: var(--primary) !important;
      border: 1px solid var(--border) !important;
      transition: all 0.2s ease !important;
    }
    
    .leaflet-control-zoom a:hover {
      background: rgba(30, 31, 70, 0.9) !important;
      color: var(--text) !important;
    }

    /* Map popup style */
    .leaflet-popup-content-wrapper {
      background: rgba(15, 16, 40, 0.95) !important;
      border-radius: 10px !important;
      border: 1px solid var(--border) !important;
      backdrop-filter: blur(10px) !important;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.5) !important;
    }
    
    .leaflet-popup-content {
      color: var(--text) !important;
      font-family: 'Rajdhani', sans-serif !important;
      margin: 12px 16px !important;
    }
    
    .leaflet-popup-tip {
      background: rgba(15, 16, 40, 0.95) !important;
      border: 1px solid var(--border) !important;
    }
    
    .leaflet-popup-close-button {
      color: var(--primary) !important;
    }

    /* Info panel */
    .panel {
      background: rgba(18, 18, 42, 0.75);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      display: grid;
      gap: 16px;
      backdrop-filter: blur(10px);
      box-shadow: 0 0 25px var(--shadow);
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .panel::after {
      content: '';
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      height: 2px;
      background: linear-gradient(90deg, transparent, var(--primary), var(--accent), transparent);
      z-index: 2;
      box-shadow: 0 0 15px var(--primary-glow);
    }
    
    .row { 
      display: grid;
      gap: 12px;
    }
    
    .row.inline { 
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(62, 63, 130, 0.3);
    }
    
    .panel-header h2 {
      margin: 0;
      font-family: 'Orbitron', sans-serif;
      font-size: 18px;
      color: var(--primary);
      text-transform: uppercase;
      letter-spacing: 1px;
      text-shadow: 0 0 5px var(--primary-glow);
    }

    /* Legend */
    .legend {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      align-items: center;
      font-size: 14px;
      color: var(--muted);
    }
    
    .legend .key { 
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    
    .legend .box { 
      width: 16px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
    }
    
    /* Status indicator */
    .status {
      min-height: 46px;
      display: grid;
      place-items: center;
      text-align: center;
      font-size: 14px;
      border-radius: 8px;
      padding: 12px;
      background: rgba(8, 9, 33, 0.5);
      border: 1px solid rgba(62, 63, 130, 0.3);
      color: var(--muted);
    }
    
    .status.success { 
      background: rgba(18, 255, 155, 0.07);
      color: var(--success);
      border-color: rgba(18, 255, 155, 0.25);
      box-shadow: 0 0 10px rgba(18, 255, 155, 0.1);
    }
    
    .status.error { 
      background: rgba(255, 56, 96, 0.07);
      color: var(--error);
      border-color: rgba(255, 56, 96, 0.25);
      box-shadow: 0 0 10px rgba(255, 56, 96, 0.1);
    }
    
    .status.loading { 
      display: inline-flex;
      align-items: center;
      gap: 10px;
      justify-content: center;
    }
    
    .spinner {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-left-color: var(--primary);
      animation: spin 1s linear infinite;
      box-shadow: 0 0 10px var(--primary-glow);
    }
    
    @keyframes spin { 
      to { transform: rotate(360deg); }
    }

    /* Toast notifications */
    .toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: none;
      align-items: center;
      gap: 10px;
      padding: 12px 16px;
      background: rgba(12, 13, 38, 0.9);
      color: var(--text);
      border-left: 3px solid var(--primary);
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3),
                 0 0 10px var(--primary-glow);
      z-index: 9999;
      font-size: 14px;
      backdrop-filter: blur(10px);
      animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translate(-50%, -10px); }
      to { opacity: 1; transform: translate(-50%, 0); }
    }
    
    .toast .spinner { 
      width: 18px;
      height: 18px;
      border-width: 2px;
    }
    
    .toast .material-icons { 
      font-size: 20px;
      color: var(--primary);
      text-shadow: 0 0 5px var(--primary-glow);
    }

    /* Mobile optimizations */
    @media (max-width: 640px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
      
      .actions {
        width: 100%;
        justify-content: space-between;
      }
      
      main {
        padding: 0 12px 12px;
        gap: 12px;
      }
      
      .map-container {
        height: 60vh;
      }
      
      button {
        padding: 8px 12px;
        font-size: 13px;
      }
      
      .panel {
        padding: 12px;
      }
      
      .legend {
        font-size: 12px;
        gap: 10px;
      }
      
      .status {
        font-size: 13px;
        padding: 10px;
        min-height: 42px;
      }
    }

    /* Cyberpunk glitch effect for headings */
    @keyframes glitch {
      0% { transform: translate(0); }
      20% { transform: translate(-2px, 1px); }
      40% { transform: translate(-2px, -1px); }
      60% { transform: translate(2px, 1px); }
      80% { transform: translate(2px, -1px); }
      100% { transform: translate(0); }
    }
    
    .glitch-text {
      position: relative;
      display: inline-block;
    }
    
    .glitch-text:hover::before,
    .glitch-text:hover::after {
      content: attr(data-text);
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, var(--primary), var(--accent));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .glitch-text:hover::before {
      animation: glitch 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) both infinite;
      text-shadow: 0 0 5px var(--primary-glow);
      clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
      transform: translate(-2px, -2px);
    }
    
    .glitch-text:hover::after {
      animation: glitch 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94) reverse both infinite;
      text-shadow: 0 0 5px var(--accent-glow);
      clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
      transform: translate(2px, 2px);
    }
  </style>
</head>
<body>
  <div id="app-container">
    <div class="cyber-grid"></div>
    <header>
      <div class="brand">
        <div class="logo"><span class="material-icons">language</span></div>
        <div class="title">
          <h1 class="glitch-text" data-text="CyberTerritories">CyberTerritories</h1>
          <p>Mint your digital land in the metaverse</p>
        </div>
      </div>
      <div class="actions">
        <span class="pill">
          <span class="material-icons">paid</span> 
          <span>Mint Price: <strong style="margin-left:4px;color:var(--primary);">1 $POL</strong></span>
        </span>
        <button id="connectBtn" class="primary">
          <span class="material-icons">account_balance_wallet</span>Connect
        </button>
        <span id="wallet" class="wallet"></span>
      </div>
    </header>

    <main>
      <div class="map-container">
        <div id="map" aria-label="Map"></div>
      </div>

      <div class="panel">
        <div class="panel-header">
          <h2>Territory Control</h2>
        </div>
        
        <div class="row">
          <div class="legend">
            <div class="key"><span class="box" style="background:#191d3b;box-shadow:0 0 3px rgba(0,249,255,0.2);"></span> Not selected</div>
            <div class="key"><span class="box" style="background:#0055ff;box-shadow:0 0 5px #0055ff;"></span> Selected</div>
            <div class="key"><span class="box" style="background:#ff2cf0;box-shadow:0 0 5px rgba(255,44,240,0.5);"></span> Minted</div>
            <div class="key"><span class="box" style="background:#12ff9b;box-shadow:0 0 5px rgba(18,255,155,0.5);"></span> You own</div>
          </div>
        </div>

        <div class="row inline">
          <span id="selectionPill" class="pill" style="display:none;"></span>
          <span id="ownedCountPill" class="pill" style="display:none;"></span>
          <span id="mintedCountPill" class="pill" style="display:none;"></span>
        </div>

        <div class="row inline">
          <button id="mintBtn" class="success" disabled>
            <span class="material-icons">rocket_launch</span>Mint Territory
          </button>
          <button id="clearBtn" class="accent">
            <span class="material-icons">delete_sweep</span>Clear
          </button>
          <button id="refreshBtn">
            <span class="material-icons">refresh</span>Refresh
          </button>
        </div>

        <div id="status" class="status">Select a territory on the map to claim it</div>
      </div>
    </main>
  </div>

  <!-- Loading toast -->
  <div id="cityLoading" class="toast" role="status" aria-live="assertive" aria-atomic="true">
    <span class="spinner" aria-hidden="true"></span>
    <span class="material-icons" aria-hidden="true">location_city</span>
    <span class="text">Loading territory data...</span>
  </div>

  <script>
    // Polygon Mainnet
    const POLYGON_PARAMS = {
      chainId: '0x89',
      chainName: 'Polygon Mainnet',
      nativeCurrency: { name: 'MATIC', symbol: 'MATIC', decimals: 18 },
      rpcUrls: ['https://polygon-rpc.com/'],
      blockExplorerUrls: ['https://polygonscan.com/']
    };

    // Contract
    const CONTRACT_ADDRESS = "0xb7d9E197905A0Fe7A59d82029eEFCBfDa631E2CC";
    const CONTRACT_ABI = [
      "function mintWithURI(string tokenURI) external payable returns (uint256)",
      "function mintPrice() view returns (uint256)",
      "function tokenURI(uint256 tokenId) view returns (string)",
      "function ownerOf(uint256 tokenId) view returns (address)",
      "event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)"
    ];
    const START_BLOCK = 0;

    // Firebase configuration
    const firebaseConfig = {
      apiKey: "AIzaSyC6wYBu-KOXkDmB-84_7OPtY71zBX4FzRY",
      authDomain: "newnft-47bd7.firebaseapp.com",
      databaseURL: "https://newnft-47bd7-default-rtdb.firebaseio.com",
      projectId: "newnft-47bd7",
      storageBucket: "newnft-47bd7.firebasestorage.app",
      messagingSenderId: "172043823738",
      appId: "1:172043823738:web:daf1fcfb7862d7d8f029c3",
      measurementId: "G-8VB3DYRNXR"
    };

    // Map / state
    let map;
    let selectionLayer; // L.GeoJSON for selected area
    let selected = null; // { id, name, type, center, geojson }
    let mintedAreaIds = new Set(); // all minted area ids
    let myOwnedAreaIds = new Set(); // area ids I own
    let isCityLoading = false;

    // Layers for minted NFTs on map
    let mintedLayerGroup; // L.LayerGroup
    const mintedLayersByAreaId = new Map(); // areaId -> L.GeoJSON
    const areaOwnerByAreaId = new Map(); // areaId -> ownerLower

    // Caches for OSM polygons
    const polygonCache = new Map(); // areaId -> GeoJSON
    const polygonFetchPromises = new Map(); // areaId -> Promise<GeoJSON>

    // Ethers
    let web3Provider, readProvider, signer, userAddress;

    // Firebase
    let fbApp, fbDb;
    let allNftsRef = null;

    // UI
    const connectBtn = document.getElementById('connectBtn');
    const walletEl = document.getElementById('wallet');
    const mintBtn = document.getElementById('mintBtn');
    const clearBtn = document.getElementById('clearBtn');
    const refreshBtn = document.getElementById('refreshBtn');
    const statusEl = document.getElementById('status');
    const selectionPill = document.getElementById('selectionPill');
    const ownedCountPill = document.getElementById('ownedCountPill');
    const mintedCountPill = document.getElementById('mintedCountPill');
    const cityLoadingEl = document.getElementById('cityLoading');

    function showCityLoading(text = 'Loading territory data...') {
      cityLoadingEl.querySelector('.text').textContent = text;
      cityLoadingEl.style.display = 'inline-flex';
      setTimeout(() => {
        if (cityLoadingEl.style.display !== 'none') {
          hideCityLoading();
        }
      }, 20000); // Safety timeout to hide toast if loading takes too long
    }
    
    function hideCityLoading() {
      cityLoadingEl.style.display = 'none';
    }

    function setStatus(msg, type = '') {
      if (!msg) {
        statusEl.textContent = '';
        statusEl.className = 'status';
        return;
      }
      statusEl.className = 'status';
      if (type === 'success') statusEl.classList.add('success');
      if (type === 'error') statusEl.classList.add('error');
      if (type === 'loading') {
        statusEl.classList.add('loading');
        statusEl.innerHTML = `<span class="spinner"></span><span>${msg}</span>`;
      } else {
        statusEl.textContent = msg;
      }
    }
    
    function toFixed5(n) { return (Math.round(n * 100000) / 100000).toFixed(5); }
    function escapeHTML(s) { return String(s || '').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#039;'); }
    function shortAddr(a) { return a ? `${a.slice(0,6)}...${a.slice(-4)}` : ''; }

    function initMap() {
      if (!window.L) { 
        setStatus('Leaflet map library failed to load.', 'error');
        return;
      }
      
      // Cyberpunk-style map
      map = L.map('map', {
        center: [20, 0],
        zoom: 3,
        zoomControl: true,
        worldCopyJump: false,
        maxBounds: [[-90, -180], [90, 180]],
        minZoom: 2,
        maxBoundsViscosity: 1.0
      });

      // Create a custom dark cyberpunk tile layer
      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        maxZoom: 19,
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>',
        subdomains: 'abcd',
      }).addTo(map);

      // Create minted layer group
      mintedLayerGroup = L.layerGroup().addTo(map);
      
      // Map event listeners
      map.on('click', onMapClick);
      
      // Fix map size issues
      setTimeout(() => map.invalidateSize(), 300);
      
      setStatus('Click on the map to select a territory', 'success');
    }

    async function onMapClick(e) {
      if (isCityLoading) return; // prevent multiple concurrent lookups
      
      const { lat, lng } = e.latlng;
      try {
        isCityLoading = true;
        showCityLoading('Loading territory data...');
        setStatus('Looking up territory for this location...', 'loading');

        const area = await reverseGeocodeWithPolygon(lat, lng);

        if (!area) {
          setStatus('No polygon found here. Try clicking closer to a city center or administrative area.', 'error');
          return;
        }
        
        selectArea(area);
        setStatus('Territory selected. You can mint it now.', 'success');
      } catch (err) {
        console.error(err);
        setStatus('Territory lookup failed. Please try again.', 'error');
      } finally {
        isCityLoading = false;
        hideCityLoading();
      }
    }

    // Reverse geocode to polygon (Nominatim)
    async function reverseGeocodeWithPolygon(lat, lng) {
      const z = map.getZoom();
      let zoomParam = 10;
      
      if (z >= 14) zoomParam = 14;
      else if (z >= 12) zoomParam = 12;
      else if (z >= 10) zoomParam = 10;
      else if (z >= 7) zoomParam = 8;
      else zoomParam = 5;

      const url = new URL('https://nominatim.openstreetmap.org/reverse');
      url.searchParams.set('format', 'jsonv2');
      url.searchParams.set('lat', lat);
      url.searchParams.set('lon', lng);
      url.searchParams.set('zoom', zoomParam);
      url.searchParams.set('polygon_geojson', '1');
      url.searchParams.set('addressdetails', '1');

      const res = await fetch(url.toString(), { 
        headers: { 
          'Accept-Language': 'en',
          'User-Agent': 'CyberTerritories/1.0'
        } 
      });
      
      if (!res.ok) throw new Error('Nominatim reverse geocoding failed');
      
      const data = await res.json();

      const geojson = data.geojson || data.geometry;
      if (!geojson || !geojson.type || !geojson.coordinates) return null;

      const osm_id = data.osm_id;
      const osm_type = data.osm_type;
      const dispName = data.display_name || 'Unknown area';
      const cls = data.class || '';
      const typ = data.type || '';
      const center = { lat: Number(data.lat), lng: Number(data.lon) };
      const id = makeAreaId(osm_type, osm_id);
      
      return { id, name: dispName, type: `${cls}:${typ}`, center, geojson };
    }

    function makeAreaId(osmType, osmId) {
      const t = (osmType || '').toLowerCase();
      return `osm:${t}:${osmId}`;
    }

    function areaStyle(isMinted, isMine, isSelected) {
      let fill = '#191d3b'; // default - dark blue
      let weight = 1.5;
      let opacity = 0.7;
      let fillOpacity = 0.5;
      
      if (isMinted) {
        fill = '#ff2cf0'; // pink/magenta
        weight = 2;
      }
      
      if (isMine) {
        fill = '#12ff9b'; // neon green
        weight = 2;
      }
      
      if (isSelected && !isMinted && !isMine) {
        fill = '#0055ff'; // bright blue
        weight = 2.5;
        opacity = 1;
        fillOpacity = 0.6;
      }
      
      return { 
        color: '#3a3f6d', 
        weight, 
        opacity, 
        fillColor: fill, 
        fillOpacity,
        dashArray: isSelected ? undefined : '3',
      };
    }

    function shortenName(name) {
      const n = String(name || '');
      if (n.length <= 60) return n;
      const firstComma = n.indexOf(',');
      if (firstComma > 0) return n.slice(0, firstComma) + '…';
      return n.slice(0, 57) + '…';
    }

    function selectArea(area) {
      selected = area;

      if (selectionLayer) {
        try { selectionLayer.remove(); } catch {}
        selectionLayer = null;
      }
      
      const isMinted = mintedAreaIds.has(area.id);
      const isMine = myOwnedAreaIds.has(area.id);

      selectionLayer = L.geoJSON(area.geojson, { 
        style: () => areaStyle(isMinted, isMine, true) 
      }).addTo(map);

      const bounds = selectionLayer.getBounds();
      if (bounds.isValid()) {
        map.fitBounds(bounds, { padding: [16, 16], maxZoom: 14 });
      } else {
        map.setView([area.center.lat, area.center.lng], Math.max(map.getZoom(), 12));
      }

      // Cyberpunk-styled popup
      selectionLayer.bindPopup(`
        <div style="min-width:250px;">
          <div style="font-weight:800;margin-bottom:8px;font-family:'Orbitron',sans-serif;color:${isMine ? '#12ff9b' : isMinted ? '#ff2cf0' : '#00f9ff'};text-shadow:0 0 5px rgba(0,249,255,0.4);font-size:15px;">${escapeHTML(shortenName(area.name))}</div>
          <div style="font-size:13px;color:#8f9cce;margin:8px 0;">Center: <span style="color:#eef2ff">${toFixed5(area.center.lat)}, ${toFixed5(area.center.lng)}</span></div>
          <div style="font-size:13px;color:#eef2ff;margin-top:10px;padding:6px 10px;border-radius:6px;background:rgba(0,0,0,0.2);border-left:3px solid ${isMine ? '#12ff9b' : isMinted ? '#ff2cf0' : '#00f9ff'}">${isMine ? '✓ You own this territory' : isMinted ? '⚠ Already minted by another user' : '✦ Available for minting'}</div>
          <div style="font-size:11px;color:#5a5f8a;margin-top:10px;">ID: ${escapeHTML(area.id)}</div>
        </div>
      `).openPopup();

      // Update selection pill
      selectionPill.style.display = 'inline-flex';
      selectionPill.innerHTML = `<span class="material-icons" style="font-size:16px;">${isMine ? 'verified' : isMinted ? 'gavel' : 'place'}</span> ${escapeHTML(shortenName(area.name))} · <span style="color:${isMine ? 'var(--success)' : isMinted ? 'var(--accent)' : 'var(--primary)'};">${isMine ? 'You own' : isMinted ? 'Minted' : 'Available'}</span>`;
      
      // Update mint button state
      mintBtn.disabled = !userAddress || isMinted;
    }

    // Wallet
    async function switchToPolygon() {
      if (!window.ethereum) return false;
      
      try {
        await window.ethereum.request({ 
          method: 'wallet_switchEthereumChain', 
          params: [{ chainId: POLYGON_PARAMS.chainId }] 
        });
        return true;
      } catch (e) {
        if (e.code === 4902) {
          try {
            await window.ethereum.request({ 
              method: 'wallet_addEthereumChain', 
              params: [POLYGON_PARAMS] 
            });
            return true;
          } catch { 
            setStatus('Failed to add Polygon network', 'error');
            return false; 
          }
        }
        setStatus('Failed to switch network', 'error');
        return false;
      }
    }

    async function connectWallet() {
      if (!window.ethereum) { 
        setStatus('Please install MetaMask to continue', 'error');
        return;
      }
      
      try {
        setStatus('Connecting wallet...', 'loading');
        const switched = await switchToPolygon();
        if (!switched) return;

        web3Provider = new ethers.providers.Web3Provider(window.ethereum);
        await web3Provider.send('eth_requestAccounts', []);
        signer = web3Provider.getSigner();
        userAddress = await signer.getAddress();

        connectBtn.disabled = true;
        connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
        walletEl.textContent = `${userAddress.slice(0,6)}...${userAddress.slice(-4)}`;

        readProvider = new ethers.providers.JsonRpcProvider(POLYGON_PARAMS.rpcUrls[0]);

        setStatus('Wallet connected. Loading minted territories...', 'loading');
        await refreshMinted(true); // also syncs to Firebase

        // Re-style any existing minted polygons for current ownership
        restyleAllMintedPolygons();

        if (selected) {
          const isMinted = mintedAreaIds.has(selected.id);
          mintBtn.disabled = isMinted;
        } else {
          mintBtn.disabled = true;
        }

        // Listen for account changes
        if (window.ethereum && typeof window.ethereum.on === 'function') {
          window.ethereum.removeListener?.('accountsChanged', onAccountsChanged);
          window.ethereum.on('accountsChanged', onAccountsChanged);
        }
      } catch (e) {
        console.error(e);
        setStatus('Wallet connection failed', 'error');
      }
    }

    function onAccountsChanged(accounts) {
      userAddress = (accounts && accounts[0]) ? accounts[0] : null;
      
      if (userAddress) {
        walletEl.textContent = shortAddr(userAddress);
        connectBtn.disabled = true;
        connectBtn.innerHTML = '<span class="material-icons">check_circle</span>Connected';
        // Update my ownership set and restyle polygons
        recomputeMyOwnershipFromOwners();
        restyleAllMintedPolygons();
      } else {
        walletEl.textContent = '';
        connectBtn.disabled = false;
        connectBtn.innerHTML = '<span class="material-icons">account_balance_wallet</span>Connect';
        myOwnedAreaIds.clear();
        restyleAllMintedPolygons();
      }
    }

    // TokenURI helpers
    function buildAreaTokenURI(area) {
      const image = buildAreaSVG(area);
      const metadata = {
        name: `Territory: ${shortenName(area.name)}`,
        description: `Digital territory NFT (from OSM) — ${area.type}`,
        image,
        attributes: [
          { trait_type: "Area ID", value: area.id },
          { trait_type: "Area Type", value: area.type },
          { trait_type: "Center Latitude", value: Number(area.center.lat.toFixed(6)) },
          { trait_type: "Center Longitude", value: Number(area.center.lng.toFixed(6)) }
        ],
        area_id: area.id
      };
      const json = JSON.stringify(metadata);
      return "data:application/json;base64," + btoa(unescape(encodeURIComponent(json)));
    }

    function buildAreaSVG(area) {
      const name = escapeHTML(shortenName(area.name));
      const type = escapeHTML(area.type || '');
      const lat = toFixed5(area.center.lat);
      const lng = toFixed5(area.center.lng);
      
      // Cyberpunk-styled SVG
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="800" height="420" viewBox="0 0 800 420">
          <defs>
            <linearGradient id="bgGrad" x1="0%" y1="0%" x2="100%" y2="100%">
              <stop offset="0%" stop-color="#070814" />
              <stop offset="100%" stop-color="#12122a" />
            </linearGradient>
            <linearGradient id="titleGrad" x1="0%" y1="0%" x2="100%" y2="0%">
              <stop offset="0%" stop-color="#00f9ff" />
              <stop offset="100%" stop-color="#0055ff" />
            </linearGradient>
            <filter id="glow">
              <feGaussianBlur stdDeviation="3" result="blur" />
              <feFlood flood-color="#00f9ff" flood-opacity="0.3" result="color" />
              <feComposite in="color" in2="blur" operator="in" result="glow" />
              <feMerge>
                <feMergeNode in="glow" />
                <feMergeNode in="SourceGraphic" />
              </feMerge>
            </filter>
            <pattern id="grid" width="40" height="40" patternUnits="userSpaceOnUse">
              <path d="M 40 0 L 0 0 0 40" fill="none" stroke="#3a3f6d" stroke-width="0.5" opacity="0.3" />
            </pattern>
          </defs>
          
          <!-- Background -->
          <rect width="800" height="420" fill="url(#bgGrad)" />
          <rect width="800" height="420" fill="url(#grid)" />
          
          <!-- Border glow -->
          <rect x="10" y="10" width="780" height="400" rx="15" fill="none" 
                stroke="url(#titleGrad)" stroke-width="2" filter="url(#glow)" />
          
          <!-- Content -->
          <g font-family="'Orbitron', sans-serif">
            <text x="40" y="80" font-size="28" font-weight="700" fill="url(#titleGrad)" filter="url(#glow)">
              CYBER TERRITORY
            </text>
            <text x="40" y="130" font-size="40" font-weight="900" fill="#eef2ff">${name}</text>
            <text x="40" y="175" font-size="20" fill="#8f9cce">${type}</text>
            <text x="40" y="220" font-size="18" fill="#8f9cce">Location: ${lat}, ${lng}</text>
            
            <!-- Badge -->
            <g transform="translate(40,270)">
              <rect width="260" height="60" rx="10" fill="none" stroke="#00f9ff" stroke-width="2" />
              <rect x="1" y="1" width="258" height="58" rx="9" fill="rgba(0,249,255,0.1)" />
              <text x="30" y="38" font-size="22" font-weight="700" fill="#00f9ff" filter="url(#glow)">DIGITAL TERRITORY</text>
            </g>
            
            <!-- QR code simulation -->
            <g transform="translate(670,40)">
              <rect width="80" height="80" rx="5" stroke="#00f9ff" stroke-width="2" fill="none" />
              <path d="M670,40h80v80h-80z" fill="url(#grid)" />
              <rect x="690" y="60" width="40" height="40" rx="5" fill="#00f9ff" opacity="0.5" />
            </g>
            
            <!-- Bottom section -->
            <g transform="translate(40,360)">
              <text font-size="14" fill="#8f9cce" font-family="'Rajdhani', sans-serif">
                ID: ${area.id.substring(0, 20)}...
              </text>
            </g>
            
            <!-- Decorative elements -->
            <line x1="40" y1="100" x2="350" y2="100" stroke="#00f9ff" stroke-width="1" opacity="0.5" />
            <line x1="40" y1="240" x2="500" y2="240" stroke="#00f9ff" stroke-width="1" opacity="0.5" />
          </g>
        </svg>`;
      
      return "data:image/svg+xml;base64," + btoa(unescape(encodeURIComponent(svg)));
    }

    // Mint flow
    async function mintSelectedArea() {
      try {
        if (!userAddress) { 
          setStatus('Please connect your wallet first', 'error');
          return;
        }
        
        if (!selected) { 
          setStatus('Select a territory on the map first', 'error');
          return;
        }
        
        if (mintedAreaIds.has(selected.id)) { 
          setStatus('This territory is already minted', 'error');
          return;
        }

        setStatus('Submitting mint transaction...', 'loading');
        const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

        let price;
        try { 
          price = await contract.mintPrice();
        } catch { 
          price = ethers.utils.parseUnits('1', 18);
        }

        const tokenURI = buildAreaTokenURI(selected);
        const tx = await contract.mintWithURI(tokenURI, { value: price });
        
        setStatus('Transaction sent! Waiting for confirmation...', 'loading');
        const receipt = await tx.wait();

        // Try to grab tokenId from the Transfer event
        let mintedTokenId = null;
        try {
          const ev = receipt.events?.find(e => e.event === 'Transfer');
          mintedTokenId = ev?.args?.tokenId?.toString() || null;
        } catch {}

        mintedAreaIds.add(selected.id);
        myOwnedAreaIds.add(selected.id);
        updateCountsPills();

        if (selectionLayer) {
          selectionLayer.setStyle(() => areaStyle(true, true, true));
          selectionLayer.bindPopup(`
            <div style="min-width:250px;text-align:center;">
              <div style="font-weight:800;margin:8px 0;color:#12ff9b;font-family:'Orbitron',sans-serif;font-size:16px;text-shadow:0 0 8px rgba(18,255,155,0.6);">TERRITORY MINTED!</div>
              <div style="font-size:14px;margin:15px 0;color:#eef2ff;">${escapeHTML(shortenName(selected.name))}</div>
              <a href="https://opensea.io" target="_blank" rel="noopener noreferrer" style="display:inline-block;background:#00f9ff;color:#07061a;text-decoration:none;padding:8px 15px;border-radius:6px;font-weight:700;text-shadow:none;font-family:'Rajdhani',sans-serif;">View on marketplace →</a>
            </div>
          `).openPopup();
        }

        selectionPill.innerHTML = `
          <span class="material-icons" style="font-size:16px;color:var(--success);">verified</span> 
          ${escapeHTML(shortenName(selected.name))} · 
          <span style="color:var(--success);">You own</span>
        `;
        
        mintBtn.disabled = true;
        setStatus('Success! Your territory has been minted.', 'success');

        // Write minted NFT to Firebase immediately (best-effort)
        try {
          const meta = await resolveTokenMetadata(tokenURI);
          if (meta) {
            await writeNftToFirebase(mintedTokenId || `temp-${Date.now()}`, userAddress, meta);
          }
        } catch (e) {
          console.warn('Failed to write immediate NFT to Firebase:', e);
        }

        // Refresh from chain and sync to Firebase (other viewers will get it)
        await refreshMinted(true);
      } catch (e) {
        console.error(e);
        const msg = e?.data?.message || e?.message || 'Unknown error';
        setStatus('Minting failed: ' + msg, 'error');
      }
    }

    // Refresh minted from chain and sync to Firebase (source of truth is chain)
    async function refreshMinted(showToast = false) {
      try {
        if (!readProvider) {
          readProvider = new ethers.providers.JsonRpcProvider(POLYGON_PARAMS.rpcUrls[0]);
        }
        
        const contractRead = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, readProvider);
        setStatus('Fetching minted territories...', 'loading');

        const zero = '0x0000000000000000000000000000000000000000';
        const filter = contractRead.filters.Transfer(zero, null);
        const logs = await contractRead.queryFilter(filter, START_BLOCK, 'latest');

        const tokenIds = Array.from(new Set(logs.map(l => l.args?.tokenId?.toString()).filter(Boolean)));

        async function batch(items, size, cb) {
          const out = [];
          for (let i = 0; i < items.length; i += size) {
            const slice = items.slice(i, i + size);
            const res = await Promise.all(slice.map(cb));
            out.push(...res);
            await new Promise(r => setTimeout(r, 120));
          }
          return out;
        }

        // Resolve tokenURI metadata
        const areaIdByToken = new Map();
        const tokenMetaById = new Map();
        
        await batch(tokenIds, 20, async (tid) => {
          try {
            const uri = await contractRead.tokenURI(tid);
            const meta = await resolveTokenMetadata(uri);
            tokenMetaById.set(tid, { uri, meta });
            const areaId = extractAreaId(meta);
            if (areaId) areaIdByToken.set(tid, areaId);
          } catch {}
        });

        // Owners
        const ownerByToken = new Map();
        
        await batch(Array.from(areaIdByToken.keys()), 15, async (tid) => {
          try {
            const owner = await contractRead.ownerOf(tid);
            if (owner) ownerByToken.set(tid, owner);
          } catch {}
        });

        // Update in-memory sets for pills
        mintedAreaIds = new Set(Array.from(areaIdByToken.values()));
        myOwnedAreaIds = new Set();
        
        if (userAddress) {
          for (const [tid, owner] of ownerByToken.entries()) {
            if (owner && owner.toLowerCase() === userAddress.toLowerCase()) {
              const id = areaIdByToken.get(tid);
              if (id) myOwnedAreaIds.add(id);
            }
          }
        }
        
        updateCountsPills();

        // Sync to Firebase (nfts and byOwner)
        await syncAllToFirebase(tokenIds, ownerByToken, tokenMetaById);

        // After sync, polygons will be rendered via Firebase listeners
        if (showToast) setStatus('Minted territories updated.', 'success');
        else setStatus('', '');
      } catch (e) {
        console.error(e);
        setStatus('Failed to refresh minted territories. Try again.', 'error');
      }
    }

    // Metadata helpers
    async function resolveTokenMetadata(uri) {
      if (!uri) return null;
      
      if (uri.startsWith('data:application/json')) {
        const base64 = uri.split(',')[1] || '';
        try { return JSON.parse(atob(base64)); } catch { return null; }
      }
      
      let url = uri;
      if (uri.startsWith('ipfs://')) {
        url = 'https://ipfs.io/ipfs/' + uri.slice('ipfs://'.length);
      }
      
      const res = await fetch(url);
      try { return await res.json(); } catch { return null; }
    }
    
    function extractAreaId(meta) {
      if (!meta) return null;
      if (meta.area_id) return String(meta.area_id);
      if (Array.isArray(meta.attributes)) {
        for (const a of meta.attributes) {
          const key = (a.trait_type || a.trait || '').toLowerCase();
          if (key.includes('area id')) return String(a.value);
        }
      }
      return null;
    }
    
    function extractCenter(meta) {
      let lat = null, lng = null;
      if (Array.isArray(meta?.attributes)) {
        for (const a of meta.attributes) {
          const k = (a.trait_type || a.trait || '').toLowerCase();
          if (k.includes('center latitude')) lat = Number(a.value);
          if (k.includes('center longitude')) lng = Number(a.value);
        }
      }
      return (Number.isFinite(lat) && Number.isFinite(lng)) ? { lat, lng } : null;
    }

    function updateCountsPills() {
      const owned = myOwnedAreaIds.size;
      const minted = mintedAreaIds.size;
      
      if (owned > 0) {
        ownedCountPill.style.display = 'inline-flex';
        ownedCountPill.innerHTML = `
          <span class="material-icons" style="font-size:16px;color:var(--success);">verified</span>
          You own: <strong style="margin-left:4px;color:var(--success);">${owned}</strong>
        `;
      } else {
        ownedCountPill.style.display = 'none';
      }
      
      mintedCountPill.style.display = 'inline-flex';
      mintedCountPill.innerHTML = `
        <span class="material-icons" style="font-size:16px;">public</span>
        Total minted: <strong style="margin-left:4px;color:var(--primary);">${minted}</strong>
      `;
    }

    function clearSelection() {
      selected = null;
      
      if (selectionLayer) {
        try { selectionLayer.remove(); } catch {}
        selectionLayer = null;
      }
      
      selectionPill.style.display = 'none';
      mintBtn.disabled = true;
      setStatus('Selection cleared. Click another area to select it.', 'success');
    }

    // Firebase init and realtime listeners (map-only rendering)
    function initFirebase() {
      try {
        fbApp = firebase.initializeApp(firebaseConfig);
        fbDb = firebase.database();
        subscribeMintedOnFirebase();
      } catch (e) {
        console.error('Firebase init failed', e);
      }
    }

    function subscribeMintedOnFirebase() {
      if (!fbDb) return;
      
      if (allNftsRef) {
        allNftsRef.off();
      }
      
      allNftsRef = fbDb.ref('nfts');

      allNftsRef.on('child_added', (snap) => {
        const tokenId = snap.key;
        const data = snap.val() || {};
        upsertMintedAreaOnMap(tokenId, data);
      });
      
      allNftsRef.on('child_changed', (snap) => {
        const tokenId = snap.key;
        const data =
